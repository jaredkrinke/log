<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Reflections at 50 (programming languages)</title>
<meta name="description" content="Find out if writing code in 50 different programming languages was a good idea!" />
<meta name="keywords" content="100-languages" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../css/style.css" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reflections at 50 (programming languages)",
  "abstract": "Find out if writing code in 50 different programming languages was a good idea!",
  "keywords": "programming-languages,100-languages",
  "datePublished": "2024-05-14"
}
</script>
</head>
<body>
<header>
<h1><a href="../../index.html">Schemescape</a></h1>
<p>Development log of a life-long coder</p>

<nav>
<strong>Topics:&nbsp;</strong>
<ul>
<li><a href="../../posts/programming-languages/index.html">programming-languages</a></li>
<li><a href="../../posts/100-languages/index.html">100-languages</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href="../../posts/programming-languages/50-different-languages.html">Reflections at 50 (programming languages)</a></h1>
<p><time datetime="2024-05-14">May 14, 2024</time></p>
</header>
<p>Over the past two months, I've <a href="../100-languages/index.html">written code in 50 different programming languages</a> (with an eventual goal to <a href="100-languages.html">get to 100</a>). Here are my thoughts thus far.</p>
<h1 id="overview">Overview</h1>
<p>I started this journey because I wanted to <strong>try new programming languages</strong> in a low-stakes setting. Rather than learn a language in depth, I'm just writing a page of code, <strong>to see what either the programming paradigm or development experience is like</strong>. Since I'm focused on new (to me) languages/paradigms, the majority of the languages aren't even in the top 100 programming languages in the <a href="https://www.tiobe.com/tiobe-index/">TIOBE Programming Community index</a>. I'm definitely <em>not</em> trying to improve my job prospects!</p>
<h2 id="positives">Positives</h2>
<p>Overall, this experiment has been a success. Prior to starting, I thought I'd <em>already</em> used a wide variety of programming languages, but <strong>I'd never <em>actually used</em> an array-based language, and I didn't even know what concatenative languages were</strong> (thought I'd briefly heard of Forth)! I'd also never experienced column- or line-based input or written right-to-left text.</p>
<p><strong>If you've got the time and desire novel programming experiences, this is a worthwhile journey!</strong></p>
<h2 id="negatives">Negatives</h2>
<p>The last sentence implied it, but <strong>repeatedly starting over from scratch--often in new paradigms--takes time</strong>. I'd say that on average I spent <em>at least</em> two or three hours with each language--and often more. Frequently, it was worthwhile, but stumbling through Smalltalk-like UI and syntax felt more tedious than educational, for example.</p>
<p>It's not obvious, but <strong>I also spent a fair amount of time discovering, selecting, and occasionally shelving languages</strong>.</p>
<h2 id="the-road-ahead">The road ahead</h2>
<p>Additionally, now that I'm 50 languages in, <strong>the novelty is wearing off a bit</strong>. This is welcome, in that the learning process is less taxing, but I'll need to ensure this doesn't just become a slog to 100. If I stop learning and/or enjoying the process, I should quit. <strong>Fifty programming languages is no small feat</strong>, anyway--though I'll feel a bit silly having a repository named &quot;100-languages&quot; if I never quite get there.</p>
<p>Tangentially related: I feel like <strong>there is a distinct possibility that I will end up creating a new programming language</strong> either during or after this exercise. The world definitely needs another Lisp (or maybe Forth)!</p>
<h2 id="languages-by-category">Languages by category</h2>
<p>For the record, here is a rough categorization of the languages I've used so far (with categories based mostly on <a href="https://madhadron.com/programming/seven_ur_languages.html">this article</a>). Note these classifications are subjective!</p>
<ul>
<li><strong>Assembly</strong>: WebAssembly, x86 (&quot;real&quot;/16-bit), Uxntal</li>
<li><strong>Imperative</strong>: Fortran, COBOL, Perl, WebGPU Shading Language, Awk, Commodore BASIC, BBC BASIC, TCL, Bash, Turbo Pascal, Hare, wax, Nim</li>
<li><strong>Homoiconic</strong>: SectorLISP, fe, Rebol, Boron, Cakelisp</li>
<li><strong>Functional</strong>: Standard ML, Unison, Julia, Pkl, Roc, Haskell, Idris, F#</li>
<li><strong>Object-oriented</strong>: Squeak, Wren, Self</li>
<li><strong>Concatenative</strong>: Gforth, PostScript, RetroForth, Uxntal, Factor, Min</li>
<li><strong>Array-based</strong>: J, Lil, APL</li>
<li><strong>Declarative</strong>: SQL, XSLT, Verilog</li>
<li><strong>Block/flow-based</strong>: Scratch, XOD</li>
<li><strong>Esoteric</strong>: SIC-1 Assembly Language, EXA, Piet, قلب (Qalb), 文言 (wenyan)</li>
</ul>
<p>Excluding intentionally esoteric ones, <strong>the most mind-bending for me have been concatenative and array-based languages</strong>, probably due to my inexperience with them. Dependently-typed languages would probably have been mind-bending if I'd spent more time and actually learned them.</p>
<h1 id="programming-language-observations">Programming language observations</h1>
<p>Being a newbie nearly 50 times in quick succession theoretically gives me a unique perspective on programming languages. Here are a few observations.</p>
<h2 id="ramping-up">Ramping up</h2>
<p>Overall, for me as an experienced programmer, <strong>the most helpful thing for ramping up has been, unsurprisingly, quality documentation</strong>. Specifically: having <strong>searchable documentation that is clearly organized, using familiar language</strong> (e.g. outlining basic syntax, enumerating control flow options, and diligently documenting the standard library).</p>
<p>The languages I struggled most with seemed to focus their documentation too much on tutorials and examples (usually unrelated to what I wanted to do--which is fair) or they used long-winded prose. In one case, the &quot;hello world&quot; example contained a URL that wasn't even explained--that just made me more confused, rather than less. Thankfully, none of the languages tried to rely on videos or chat apps for &quot;documentation&quot;!</p>
<h2 id="no-one-cares-about-footprint">No one cares about footprint</h2>
<p>It's disheartening, but most programming languages don't seem to care about the disk/memory footprints of their environments or, often, their resulting binaries. I don't enjoy slow software, but, these days, <strong>my old computers are more impacted by bloat than sluggishness</strong>.</p>
<p>Hare and Rebol are nice counterexamples, and embeddable scripting languages are also usually pretty light. And let's not forget the old, but <a href="https://prog21.dadgum.com/116.html">famously lightweight Turbo Pascal environment</a>!</p>
<h2 id="so-so-many-languages">So, so many languages</h2>
<p>Despite my frequent complaints, the quality of virtually all languages I've tried is impressive--even the hobby languages are eminently usable! The amount of work involved is staggering.</p>
<p><strong>Perhaps people create new programming languages for the same reason they create art, i.e. because they can't <em>not</em> do it?</strong></p>
<h1 id="parting-thoughts">Parting thoughts</h1>
<p>Now that I've sampled a lot of different programming languages, I'm more confident about matching problems to appropriate languages. In the recent past, I've tried to <a href="future-proof-languages.html">find the one true language that I can use for everything</a>, but that's honestly misguided--most of the time, at least--and especially for hobby projects in wildly different domains.</p>
<p>I guess the good news is that I've now convinced myself that <strong>I could <em>probably</em> make do with <em>any</em> programming language, so maybe I can finally stop <a href="../misc/my-hobby-is-bikeshedding.html">bike-shedding</a> <a href="future-proof-languages.html">about</a> <a href="future-proof-languages-2.html">programming</a> <a href="future-proof-languages-3.html">languages</a></strong>.</p>

<footer>
<p>&crarr; <a href="../../index.html">Back to home</a></p>
</footer>
</article>
</main>

</body>
</html>
