<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Extreme Typing in TypeScript</title>
<meta name="description" content="Solving a Project Euler problem entirely within TypeScript&#39;s type system. Because I couldn&#39;t not do it!" />
<meta name="keywords" content="100-languages" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../css/style.css" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Extreme Typing in TypeScript",
  "abstract": "Solving a Project Euler problem entirely within TypeScript's type system. Because I couldn't not do it!",
  "keywords": "programming-languages,100-languages",
  "datePublished": "2024-06-05"
}
</script>
</head>
<body>
<header>
<h1><a href="../../index.html">Schemescape</a></h1>
<p>Development log of a life-long coder</p>

<nav>
<strong>Topics:&nbsp;</strong>
<ul>
<li><a href="../../posts/programming-languages/index.html">programming-languages</a></li>
<li><a href="../../posts/100-languages/index.html">100-languages</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href="../../posts/programming-languages/extreme-typing-in-typescript.html">Extreme Typing in TypeScript</a></h1>
<p><time datetime="2024-06-05">June 5, 2024</time></p>
</header>
<p><strong>TypeScript brought sanity to the JavaScript world</strong>, standardizing how JavaScript APIs are documented. TypeScript&#39;s gradual typing system has shown that <strong>a little bit of typing can go a long way</strong> towards increasing productivity.</p>
<p>So if <em>a little bit</em> of typing is a good thing, then <em>more</em> must be better, right?</p>
<p>Welcome to <strong>Extreme Typing</strong>.</p>
<h1 id="extreme-typing">Extreme Typing</h1>
<p>Extreme Typing is about <strong>using the type system available to you <em>to the fullest extent permitted by law</em></strong>. In fact, it&#39;s about <em>only</em> using the type system. For everything.</p>
<p>In the context of TypeScript, this means that you can finally enjoy the modern wonder of TypeScript <strong>without ever having to deal with that crusty, clumsy, old language called JavaScript</strong>. Yes, today in TypeScript, it is possible to do the following <em>without ever having to touch JavaScript</em>:</p>
<ul>
<li>Perform arithmetic</li>
<li>Apply logic</li>
<li>Parse strings</li>
</ul>
<h1 id="extremely-typed-poker">Extremely typed poker</h1>
<p>For my most recent <a href="100-languages.html">programming language experiment</a>, I tackled <a href="https://projecteuler.net/problem=54">Project Euler problem 54</a> (&quot;Poker Hands&quot;), entirely from the comfort of TypeScript&#39;s type system.</p>
<p>The problem encodes 1,000 rounds of Poker and the goal is to determine how many hands the first player wins (following the rules of Poker). Here&#39;s a line of sample input:</p>
<pre><code class="language-txt">2D 9C AS AH AC 3D 6D 7D TD QD
</code></pre>
<p>Separating the two hands and moving the cards around, this yields <code>AS AH AC 9C 2D</code> vs. <code>QD TD 7D 6D 3D</code>, i.e. the first player has 3 aces and the second player has a flush. The second player wins.</p>
<p><strong>So how can we decode and evaluate 1,000 rounds of Poker using only types?</strong></p>
<h2 id="overview">Overview</h2>
<p>I settled on the following process:</p>
<ol>
<li>Split text into lines</li>
<li>Parse all 10 cards on each line</li>
<li>Group cards by rank and suit</li>
<li>Determine the (ahem) type (and tie-breakers) of each poker hand</li>
<li>Compare the two hands to identify the winner</li>
<li>Count the number of first player wins</li>
<li>Finally, batch the input to avoid tripping TypeScript&#39;s recursion depth limits</li>
</ol>
<p>Details follow.</p>
<h2 id="splitting-lines">Splitting lines</h2>
<p>Apparently, <strong>it is now possible to parse strings within TypeScript&#39;s type system</strong>. Given that it&#39;s <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#tail-recursion-elimination-on-conditional-types">mentioned in the official docs</a>, I assume it&#39;s supported. Note that I don&#39;t fully understand the limitations of this approach. It&#39;s certainly not magic.</p>
<p>In my case, I knew ahead of time the set of all possible characters in the input file, so I was able to define a type that is the union of all possible characters:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RanksDescending</span> = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;T&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Rank</span> = <span class="hljs-title class_">RanksDescending</span>[<span class="hljs-built_in">number</span>];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Suit</span> = <span class="hljs-string">&quot;C&quot;</span> | <span class="hljs-string">&quot;D&quot;</span> | <span class="hljs-string">&quot;H&quot;</span> | <span class="hljs-string">&quot;S&quot;</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">NonNewline</span> = <span class="hljs-title class_">Rank</span> | <span class="hljs-title class_">Suit</span> | <span class="hljs-string">&quot; &quot;</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Character</span> = <span class="hljs-string">&quot;\n&quot;</span> | <span class="hljs-title class_">NonNewline</span>;
</code></pre>
<p>Armed with these types, it&#39;s possible to <strong>accumulate strings character-by-character, breaking on <code>\n</code></strong> (and using tail calls, as described in the previous link):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SplitLines</span>&lt;<span class="hljs-title class_">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Line</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>, <span class="hljs-title class_">Output</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>[]&gt; =
    <span class="hljs-title class_">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">&quot;&quot;</span>
        ? [...<span class="hljs-title class_">Output</span>, <span class="hljs-title class_">Line</span>] <span class="hljs-comment">// Done reading input; add final line</span>
        : <span class="hljs-title class_">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer C <span class="hljs-keyword">extends</span> Character}</span><span class="hljs-subst">${infer Rest}</span>`</span>
            ? C <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonNewline</span>
                ? <span class="hljs-title class_">SplitLines</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-string">`<span class="hljs-subst">${Line}</span><span class="hljs-subst">${C}</span>`</span>, <span class="hljs-title class_">Output</span>&gt; <span class="hljs-comment">// Not a newline: accumulate into Line</span>
                : <span class="hljs-title class_">SplitLines</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-string">&quot;&quot;</span>, [...<span class="hljs-title class_">Output</span>, <span class="hljs-title class_">Line</span>]&gt; <span class="hljs-comment">// Newline: reset accumulator; add Line to Output</span>
            : <span class="hljs-built_in">never</span>;
</code></pre>
<p>Each line can then be processed individually.</p>
<h2 id="parsing-cards">Parsing cards</h2>
<p>Parsing cards <strong>arguably uses TypeScript features as intended</strong> (to read in two characters):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Card</span> = { <span class="hljs-attr">rank</span>: <span class="hljs-title class_">Rank</span>, <span class="hljs-attr">suit</span>: <span class="hljs-title class_">Suit</span> };
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ParseCard</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =
    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer CardRank <span class="hljs-keyword">extends</span> Rank}</span><span class="hljs-subst">${infer CardSuit <span class="hljs-keyword">extends</span> Suit}</span>`</span>
        ? { <span class="hljs-attr">rank</span>: <span class="hljs-title class_">CardRank</span>, <span class="hljs-attr">suit</span>: <span class="hljs-title class_">CardSuit</span> }
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>I let the next two steps leak into my &quot;parse lines&quot; code, so ignore <code>DataFromHand</code> and <code>EvaluationFromData</code> in this code to read 10 cards (5 for each hand):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ProcessLine</span>&lt;L <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =
    L <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer A1}</span> <span class="hljs-subst">${infer A2}</span> <span class="hljs-subst">${infer A3}</span> <span class="hljs-subst">${infer A4}</span> <span class="hljs-subst">${infer A5}</span> <span class="hljs-subst">${infer B1}</span> <span class="hljs-subst">${infer B2}</span> <span class="hljs-subst">${infer B3}</span> <span class="hljs-subst">${infer B4}</span> <span class="hljs-subst">${infer B5}</span>`</span>
        ? [
            <span class="hljs-title class_">EvaluationFromData</span>&lt;<span class="hljs-title class_">DataFromHand</span>&lt;[<span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">A1</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">A2</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">A3</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">A4</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">A5</span>&gt;]&gt;&gt;,
            <span class="hljs-title class_">EvaluationFromData</span>&lt;<span class="hljs-title class_">DataFromHand</span>&lt;[<span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">B1</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">B2</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">B3</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">B4</span>&gt;, <span class="hljs-title class_">ParseCard</span>&lt;<span class="hljs-variable constant_">B5</span>&gt;]&gt;&gt;,
        ]
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>With that, parsing is complete: each line is now two hands of five cards.</p>
<h2 id="grouping-cards">Grouping cards</h2>
<p><strong>Grouping cards by rank and suit got a bit hairy</strong>. In fact, I had to rewrite the &quot;is this a flush?&quot; check a few times because certain approaches would silently fail when referenced from other types (it&#39;s possible these are bugs in the TypeScript compiler, but opening an &quot;I can&#39;t run poker in the type system&quot; bug would likely be a waste of everyone&#39;s time).</p>
<p>Regardless, my approach was to <strong>walk an ordered array of ranks and then count cards matching that rank</strong>, removing &quot;empty&quot; (count of zero) ranks at the end. This involved a few utility types for selecting (&quot;keeping&quot;) items from an array and counting the number of items in an array (ignore the unary number part--I&#39;ll get to that in due time).</p>
<p>Using the examples hands from earlier, the result is something like:</p>
<ul>
<li>First player: 3 aces, 1 nine, 1 two</li>
<li>Second player: 1 queen, 1 ten, 1 seven, 1 six, 1 three</li>
</ul>
<p>Relevant code:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Equal</span>&lt;A, B&gt; = A <span class="hljs-keyword">extends</span> B ? B <span class="hljs-keyword">extends</span> A ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span> : <span class="hljs-literal">false</span>;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ArrayLength</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[]&gt; = <span class="hljs-title class_">UnaryToNumber</span>&lt;A&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ArrayKeep</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[], <span class="hljs-title class_">Item</span>&gt; =
    A <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span>]
        ? <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Item</span>
            ? [<span class="hljs-title class_">First</span>, ...<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>&gt;]
            : <span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">Rest</span>, <span class="hljs-title class_">Item</span>&gt;
        : [];
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Hand</span> = <span class="hljs-title class_">Card</span>[];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">RankCount</span> = { <span class="hljs-attr">rank</span>: <span class="hljs-title class_">Rank</span>, <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Data</span> = { <span class="hljs-attr">counts</span>: <span class="hljs-title class_">RankCount</span>[], <span class="hljs-attr">flush</span>: <span class="hljs-built_in">boolean</span> };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountRank</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>, R <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>&gt; = { <span class="hljs-attr">rank</span>: R, <span class="hljs-attr">count</span>: <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;H, <span class="hljs-title class_">CardOfRank</span>&lt;R&gt;&gt;&gt; };
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountRanksRecursive</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>, R <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[], <span class="hljs-title class_">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RankCount</span>[]&gt; = R <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]] ? <span class="hljs-title class_">CountRanksRecursive</span>&lt;H, <span class="hljs-title class_">Rest</span>, [...<span class="hljs-title class_">Result</span>, <span class="hljs-title class_">CountRank</span>&lt;H, <span class="hljs-title class_">First</span>&gt;]&gt; : <span class="hljs-title class_">Result</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountRanks</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>&gt; = <span class="hljs-title class_">CountRanksRecursive</span>&lt;H, <span class="hljs-title class_">RanksDescending</span>, []&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">SortedRankCounts</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>&gt; = <span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">CountRanks</span>&lt;H&gt;, { <span class="hljs-attr">count</span>: (<span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> | <span class="hljs-number">4</span>) }&gt;;
</code></pre>
<p>Why &quot;keep&quot; counts of 1 through 4 instead of removing counts of 0? Because this approach worked and removing zeroes didn&#39;t. <strong>I don&#39;t know why</strong> (especially since it worked when used directly--just not when referenced transitively).</p>
<p>Next, I also needed to track whether a hand was a flush or not (N.B. checking all five cards&#39; suits for equality also didn&#39;t work unless directly referenced--still no idea why):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Or</span>&lt;A, B&gt; = A <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-literal">true</span> : B <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Or4</span>&lt;A, B, C, D&gt; = <span class="hljs-title class_">Or</span>&lt;A, <span class="hljs-title class_">Or</span>&lt;B, <span class="hljs-title class_">Or</span>&lt;C, D&gt;&gt;&gt;;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FlushOfSuit</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>, S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Suit</span>&gt; = <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-number">5</span>, <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;H, { <span class="hljs-attr">suit</span>: S }&gt;&gt;&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Flush</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>&gt; = <span class="hljs-title class_">Or4</span>&lt;<span class="hljs-title class_">FlushOfSuit</span>&lt;H, <span class="hljs-string">&quot;C&quot;</span>&gt;, <span class="hljs-title class_">FlushOfSuit</span>&lt;H, <span class="hljs-string">&quot;S&quot;</span>&gt;, <span class="hljs-title class_">FlushOfSuit</span>&lt;H, <span class="hljs-string">&quot;H&quot;</span>&gt;, <span class="hljs-title class_">FlushOfSuit</span>&lt;H, <span class="hljs-string">&quot;D&quot;</span>&gt;&gt;;
</code></pre>
<p>Final output type for this stage:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">DataFromHand</span>&lt;H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hand</span>&gt; = { <span class="hljs-attr">counts</span>: <span class="hljs-title class_">SortedRankCounts</span>&lt;H&gt;, <span class="hljs-attr">flush</span>: <span class="hljs-title class_">Flush</span>&lt;H&gt; };
</code></pre>
<h2 id="analyzing-hands">Analyzing hands</h2>
<p>Armed with the sorted ranks and counts of cards (along with a flag indicating a flush), it was possible to start identifying the &quot;types&quot; (pun intended) of poker hands.</p>
<p>Here are a few simple examples that just see how many ranks have a count of N:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">And</span>&lt;A, B&gt; = A <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? B <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span> : <span class="hljs-literal">false</span>;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">RankCountOfCount</span>&lt;C&gt; = { <span class="hljs-attr">count</span>: C };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsFourOf</span>AKind&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; = <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;<span class="hljs-number">4</span>&gt;&gt;&gt;&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsTwoPair</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; = <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-number">2</span>, <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;<span class="hljs-number">2</span>&gt;&gt;&gt;&gt;;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">HasThreeOf</span>AKind&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; = <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;<span class="hljs-number">3</span>&gt;&gt;&gt;&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">HasOnePair</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; = <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-number">1</span>, <span class="hljs-title class_">ArrayLength</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;<span class="hljs-number">2</span>&gt;&gt;&gt;&gt;;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">IsFullHouse</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; = <span class="hljs-title class_">And</span>&lt;<span class="hljs-title class_">HasThreeOf</span>AKind&lt;D&gt;, <span class="hljs-title class_">HasOnePair</span>&lt;D&gt;&gt;;
</code></pre>
<p>Identifying straights seemed tricky, so I just hard-coded them all:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IsStraight</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; =
    D <span class="hljs-keyword">extends</span> { <span class="hljs-attr">counts</span>: infer <span class="hljs-title class_">DataCounts</span> }
        ? <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;A&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;5&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;4&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;3&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;2&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;6&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;5&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;4&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;3&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;2&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;7&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;6&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;5&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;4&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;3&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;8&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;7&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;6&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;5&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;4&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;9&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;8&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;7&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;6&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;5&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;T&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;9&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;8&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;7&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;6&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;J&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;T&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;9&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;8&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;7&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;Q&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;J&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;T&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;9&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;8&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;K&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;Q&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;J&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;T&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;9&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-title class_">DataCounts</span> <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;A&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;K&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;Q&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;J&quot;</span> }, { <span class="hljs-attr">rank</span>: <span class="hljs-string">&quot;T&quot;</span> }] ? <span class="hljs-literal">true</span>
        : <span class="hljs-literal">false</span>
    : <span class="hljs-literal">false</span>;
</code></pre>
<p>But I also needed to supply tie-breakers, so here are some utilities for retrieving the (previously sorted) rank(s) of cardinality N:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">RankFor</span>NOfAKind&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>, N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; = <span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;N&gt;&gt; <span class="hljs-keyword">extends</span> [{ <span class="hljs-attr">rank</span>: infer R <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span> }] ? R : <span class="hljs-built_in">never</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">RanksForNsOf</span>AKind&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>, N <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>&gt; = <span class="hljs-title class_">RanksFromRankCounts</span>&lt;<span class="hljs-title class_">ArrayKeep</span>&lt;<span class="hljs-title class_">RankCountsFromData</span>&lt;D&gt;, <span class="hljs-title class_">RankCountOfCount</span>&lt;N&gt;&gt;&gt;;
</code></pre>
<p>And I needed to handle the fact that aces can be low <em>or</em> high in a straight:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">If</span>&lt;C, T, F&gt; = C <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? T : F;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">RankForStraight</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; =
    D <span class="hljs-keyword">extends</span> { <span class="hljs-attr">counts</span>: [{ <span class="hljs-attr">rank</span>: infer <span class="hljs-title class_">FirstRank</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span> }, { <span class="hljs-attr">rank</span>: infer <span class="hljs-title class_">SecondRank</span> }, ...infer <span class="hljs-title class_">Rest</span>] }
        <span class="hljs-comment">// Note the special case for straights that *begin* with an ace</span>
        ? <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">And</span>&lt;<span class="hljs-title class_">Equal</span>&lt;<span class="hljs-title class_">FirstRank</span>, <span class="hljs-string">&quot;A&quot;</span>&gt;, <span class="hljs-title class_">Equal</span>&lt;<span class="hljs-title class_">SecondRank</span>, <span class="hljs-string">&quot;5&quot;</span>&gt;&gt;, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-title class_">FirstRank</span>&gt;
        : <span class="hljs-built_in">never</span>;
</code></pre>
<p>Finally, here&#39;s the closest to a lookup table I was able to create:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">EvaluationFromData</span>&lt;D <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Data</span>&gt; =
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsStraightFlush</span>&lt;D&gt;,  { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;straightFlush&quot;</span>,    <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankForStraight</span>&lt;D&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsFourOf</span>AKind&lt;D&gt;,    { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;fourOfAKind&quot;</span>,      <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">4</span>&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsFullHouse</span>&lt;D&gt;,      { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;fullHouse&quot;</span>,        <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">3</span>&gt;, <span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">2</span>&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsFlush</span>&lt;D&gt;,          { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;flush&quot;</span>,            <span class="hljs-attr">tieBreakers</span>: <span class="hljs-title class_">RanksForNsOf</span>AKind&lt;D, <span class="hljs-number">1</span>&gt; },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsStraight</span>&lt;D&gt;,       { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;straight&quot;</span>,         <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankForStraight</span>&lt;D&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">HasThreeOf</span>AKind&lt;D&gt;,  { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;threeOfAKind&quot;</span>,     <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">3</span>&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">IsTwoPair</span>&lt;D&gt;,        { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;twoPair&quot;</span>,          <span class="hljs-attr">tieBreakers</span>: [...<span class="hljs-title class_">RanksForNsOf</span>AKind&lt;D, <span class="hljs-number">2</span>&gt;, <span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">1</span>&gt;] },
    <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">HasOnePair</span>&lt;D&gt;,       { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;pair&quot;</span>,             <span class="hljs-attr">tieBreakers</span>: [<span class="hljs-title class_">RankFor</span>NOfAKind&lt;D, <span class="hljs-number">2</span>&gt;, ...<span class="hljs-title class_">RanksForNsOf</span>AKind&lt;D, <span class="hljs-number">1</span>&gt;] },
    <span class="hljs-comment">/* High card */</span>         { <span class="hljs-attr">handType</span>: <span class="hljs-string">&quot;highCard&quot;</span>,         <span class="hljs-attr">tieBreakers</span>: <span class="hljs-title class_">RanksForNsOf</span>AKind&lt;D, <span class="hljs-number">1</span>&gt; }&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;
</code></pre>
<p>The output of this stage is the &quot;type&quot; of the hand (two pair, flush, high card, etc.) and any tie-breakers that might be needed.</p>
<h2 id="comparing-hands">Comparing hands</h2>
<p>Similar to sorting ranks, both ranks and poker hand &quot;types&quot; are compared relatively by walking the ordered array until a &quot;winner&quot; is found. <strong>Despite sounding very simple, it took an entire page of code</strong>:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GreaterRankRecursive</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, R <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]&gt; =
    R <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]]
        ? A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
            ? B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
                ? <span class="hljs-literal">false</span>     <span class="hljs-comment">// A = B</span>
                : <span class="hljs-literal">true</span>      <span class="hljs-comment">// A &gt; B</span>
            : B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
                ? <span class="hljs-literal">false</span>     <span class="hljs-comment">// A &lt; B</span>
                : <span class="hljs-title class_">GreaterRankRecursive</span>&lt;A, B, <span class="hljs-title class_">Rest</span>&gt; <span class="hljs-comment">// Neither A nor B match; try next lower rank</span>
        : <span class="hljs-literal">false</span>; <span class="hljs-comment">// Probably should have used `never` here</span>

<span class="hljs-keyword">type</span> <span class="hljs-title class_">GreaterRank</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>&gt; = <span class="hljs-title class_">GreaterRankRecursive</span>&lt;A, B, <span class="hljs-title class_">RanksDescending</span>&gt;;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">GreaterRanks</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[], B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]&gt; =
    A <span class="hljs-keyword">extends</span> [infer ARank <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, ...infer ARest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]]
        ? B <span class="hljs-keyword">extends</span> [infer BRank <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>, ...infer BRest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[]]
            ? <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">GreaterRank</span>&lt;ARank, BRank&gt;,
                <span class="hljs-literal">true</span>,       <span class="hljs-comment">// A &gt; B</span>
                <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">GreaterRank</span>&lt;BRank, ARank&gt;,
                    <span class="hljs-literal">false</span>,  <span class="hljs-comment">// A &lt; B</span>
                    <span class="hljs-title class_">GreaterRanks</span>&lt;ARest, BRest&gt;&gt;&gt; <span class="hljs-comment">// A = B</span>
            : <span class="hljs-built_in">never</span>
        : <span class="hljs-literal">false</span>; <span class="hljs-comment">// No more tie-breakers; treat as &quot;not a win for A&quot;</span>

<span class="hljs-comment">// Basically the same as GreaterRankRecursive</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">BetterHandType</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>, H <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>[]&gt; =
    H <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span>, ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>[]]
        ? A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
            ? B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
                ? <span class="hljs-literal">false</span>
                : <span class="hljs-literal">true</span>
            : B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">First</span>
                ? <span class="hljs-literal">false</span>
                : <span class="hljs-title class_">BetterHandType</span>&lt;A, B, <span class="hljs-title class_">Rest</span>&gt;
        : <span class="hljs-literal">false</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">BetterEvaluation</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>, B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>&gt; =
    A <span class="hljs-keyword">extends</span> { <span class="hljs-attr">handType</span>: infer <span class="hljs-variable constant_">AH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>, <span class="hljs-attr">tieBreakers</span>: infer <span class="hljs-variable constant_">AT</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[] }
        ? B <span class="hljs-keyword">extends</span> { <span class="hljs-attr">handType</span>: infer <span class="hljs-variable constant_">BH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandType</span>, <span class="hljs-attr">tieBreakers</span>: infer <span class="hljs-variable constant_">BT</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Rank</span>[] }
            ? <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">BetterHandType</span>&lt;<span class="hljs-variable constant_">AH</span>, <span class="hljs-variable constant_">BH</span>, <span class="hljs-title class_">HandTypesDescending</span>&gt;,
                <span class="hljs-literal">true</span>,       <span class="hljs-comment">// A has the better hand type</span>
                <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">BetterHandType</span>&lt;<span class="hljs-variable constant_">BH</span>, <span class="hljs-variable constant_">AH</span>, <span class="hljs-title class_">HandTypesDescending</span>&gt;,
                    <span class="hljs-literal">false</span>,  <span class="hljs-comment">// B has the better hand type</span>
                    <span class="hljs-title class_">GreaterRanks</span>&lt;<span class="hljs-variable constant_">AT</span>, <span class="hljs-variable constant_">BT</span>&gt;&gt;&gt; <span class="hljs-comment">// Same hand types; compare tie-breakers</span>
            : <span class="hljs-built_in">never</span>
        : <span class="hljs-built_in">never</span>;
</code></pre>
<h2 id="counting-wins">Counting wins</h2>
<p>Counting involves numbers, and <strong>I didn&#39;t see an obvious way to perform arithmetic in TypeScript&#39;s type system</strong>. So I had to (<a href="100-languages-2.html">once again</a>) implement my own arithmetic. Fortunately, I was able to simply use a unary encoding based on array length (this works for values up to ~500):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnaryZero</span> = [];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnaryNumber</span> = <span class="hljs-built_in">any</span>[];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnaryToNumber</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>&gt; = T <span class="hljs-keyword">extends</span> { <span class="hljs-attr">length</span>: infer L <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> } ? L : <span class="hljs-built_in">never</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnaryIncrement</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>&gt; = [...T, <span class="hljs-built_in">any</span>];
<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnaryOne</span> = <span class="hljs-title class_">UnaryIncrement</span>&lt;<span class="hljs-title class_">UnaryZero</span>&gt;;
</code></pre>
<p>I tracked wins in an array of (unary) zeroes (losses) or ones (wins):</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ScoreRound</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>[]&gt; =
    A <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">First</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>, infer <span class="hljs-title class_">Second</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>]
        ? <span class="hljs-title class_">If</span>&lt;<span class="hljs-title class_">BetterEvaluation</span>&lt;<span class="hljs-title class_">First</span>, <span class="hljs-title class_">Second</span>&gt;,
            <span class="hljs-title class_">UnaryOne</span>,
            <span class="hljs-title class_">UnaryZero</span>&gt;
        : <span class="hljs-built_in">never</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ScoreRoundsRecursive</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>[][], S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>[]&gt; =
    A <span class="hljs-keyword">extends</span> [infer <span class="hljs-title class_">Line</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>[], ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>[][]]
        ? <span class="hljs-title class_">ScoreRoundsRecursive</span>&lt;<span class="hljs-title class_">Rest</span>, [...S, <span class="hljs-title class_">ScoreRound</span>&lt;<span class="hljs-title class_">Line</span>&gt;]&gt;
        : S;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ScoreRounds</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Evaluation</span>[][]&gt; = <span class="hljs-title class_">ScoreRoundsRecursive</span>&lt;A, []&gt;;
</code></pre>
<h2 id="batching">Batching</h2>
<p>Sadly, I wasn&#39;t able to solve the entire problem in one go because <strong>TypeScript (even with tail call elimination) has limits on recursion depth</strong>. My solution was to process batches of 25 lines at a time (40 batches in total), and then simply sum the sub-scores from each batch.</p>
<p>N.B. I used JavaScript to split the input file into batches. Sorry! I am a fraud.</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnarySumRecursive</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>[], S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>&gt; =
    A <span class="hljs-keyword">extends</span> [infer T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>, ...infer <span class="hljs-title class_">Rest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>[]]
        ? <span class="hljs-title class_">UnarySumRecursive</span>&lt;<span class="hljs-title class_">Rest</span>, [...T, ...S]&gt;
        : S;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">UnarySum</span>&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnaryNumber</span>[]&gt; = <span class="hljs-title class_">UnarySumRecursive</span>&lt;A, <span class="hljs-title class_">UnaryZero</span>&gt;;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">ScoreBlock</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">UnarySum</span>&lt;<span class="hljs-title class_">ScoreRounds</span>&lt;<span class="hljs-title class_">ProcessLines</span>&lt;<span class="hljs-title class_">SplitLines</span>&lt;S, <span class="hljs-string">&quot;&quot;</span>, []&gt;&gt;&gt;&gt;;

<span class="hljs-keyword">type</span> t1 = <span class="hljs-title class_">ScoreBlock</span>&lt;<span class="hljs-string">&quot;8C TS KC 9H 4S 7D 2S 5D 3S AC\n5C AD 5D AC 9C 7C 5H 8D TD KS\n ...&quot;</span>&gt;;
<span class="hljs-keyword">type</span> t2 = <span class="hljs-title class_">ScoreBlock</span>&lt;<span class="hljs-string">&quot;5H 6H 2S KS 3D 5D JD 7H JS 8H\nKH 4H AS JS QS QC TC 6D 7C KS\n ...&quot;</span>&gt;;
...
<span class="hljs-keyword">type</span> <span class="hljs-title class_">CorrectAnswer</span> = <span class="hljs-title class_">UnaryToNumber</span>&lt;<span class="hljs-title class_">UnarySum</span>&lt;[t1, t2, ..., t40]&gt;&gt;;
</code></pre>
<p>In the end, I just needed to hover over the <code>CorrectAnswer</code> type in my editor and (eventually), it showed me the correct answer.</p>
<h2 id="on-the-command-line">On the command line</h2>
<p>It&#39;s also possible to have <code>tsc</code> emit the answer by forcing a type-checking error by supplying a known-incorrect value:</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">guess</span>: <span class="hljs-title class_">CorrectAnswer</span> = <span class="hljs-number">42</span>; <span class="hljs-comment">// Definitely not correct!</span>
</code></pre>
<p>Running <code>tsc</code> produces the following output (<strong>spoiler alert!</strong>):</p>
<pre><code class="language-txt">error TS2322: Type &#x27;42&#x27; is not assignable to type &#x27;376&#x27;.
</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p><strong>Extreme Typing: it&#39;s a thing!</strong></p>
<p>Resources:</p>
<ul>
<li><a href="https://github.com/jaredkrinke/100-languages/blob/main/src/p54.ts">Source code for my solution</a></li>
<li><a href="https://www.learningtypescript.com/articles/extreme-explorations-of-typescripts-type-system">Extreme Explorations of TypeScript&#39;s Type System</a></li>
<li><a href="https://github.com/arielhs/ts-arithmetic">Type Level Arithmetic</a></li>
</ul>

<footer>
<p>&crarr; <a href="../../index.html">Back to home</a></p>
</footer>
</article>
</main>

</body>
</html>
