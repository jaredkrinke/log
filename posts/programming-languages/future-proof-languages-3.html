<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Future-proof programming languages, part 3</title>
<meta name="description" content="Finally! I&#39;ve landed on my set of future-proof languages." />
<meta name="keywords" content="zig,rust" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../css/style.css" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Future-proof programming languages, part 3",
  "abstract": "Finally! I've landed on my set of future-proof languages.",
  "keywords": "programming-languages,zig,rust",
  "datePublished": "2023-03-03"
}
</script>
</head>
<body>
<header>
<h1><a href="../../index.html">Schemescape</a></h1>
<p>Development log of a life-long coder</p>

<nav>
<strong>Topics:&nbsp;</strong>
<ul>
<li><a href="../../posts/programming-languages/index.html">programming-languages</a></li>
<li><a href="../../posts/zig/index.html">zig</a></li>
<li><a href="../../posts/rust/index.html">rust</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href="../../posts/programming-languages/future-proof-languages-3.html">Future-proof programming languages, part 3</a></h1>
<p><time datetime="2023-03-03">March 3, 2023</time></p>
</header>
<p>In <a href="future-proof-languages.html">part 1</a>, I narrowed down a list of popular programming languages to the ones I liked and that I  thought would still be useful in the future. In <a href="future-proof-languages-2.html">part 2</a>, I recorded some initial impressions, and added a few more languages to the mix.</p>
<p>In this update, I&#39;m recording my experiences with a trivial program in each language, with an eye towards possibly incorporating one or more of these languages into my <a href="minimal-dev-env-2.html">minimal development environment</a>.</p>
<h1 id="scenarios-and-metrics">Scenarios and metrics</h1>
<p><strong>This post is not an attempt to definitively benchmark or objectively compare programming languages in depth!</strong> Instead, I&#39;m playing around with each language and environment to see which ones are even worth my consideration. Specifically, I&#39;m looking at:</p>
<ul>
<li>SDK size (measured on x86_64 Alpine Linux), as a proxy for <strong>simplicity</strong></li>
<li>&quot;Hello, world!&quot; program size, as a proxy for <strong>overhead</strong></li>
<li>Stand-alone executable size, as a proxy for <strong>ease of deployment</strong></li>
<li>Cross-compiling for a Raspberry Pi B, as a proxy for <strong>portability</strong> and <strong>developer experience</strong></li>
</ul>
<h1 id="results">Results</h1>
<p>For reference, my Alpine Linux baseline image was around 150 MB. Here are the results, ordered by descending SDK size:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>SDK size</th>
<th>Program size</th>
<th>Stand-alone size</th>
<th>Build on Pi?</th>
<th>Cross-compile for Pi?</th>
</tr>
</thead>
<tbody><tr>
<td>Rust</td>
<td>650 MB</td>
<td>300 KB</td>
<td>?</td>
<td>Probably</td>
<td>Mostly easy</td>
</tr>
<tr>
<td>Go</td>
<td>550 MB</td>
<td>1.2 MB</td>
<td>1.2 MB</td>
<td>Yes</td>
<td>Easy</td>
</tr>
<tr>
<td>C#</td>
<td>510 MB</td>
<td>75 KB</td>
<td>67 MB</td>
<td>No</td>
<td>Failed</td>
</tr>
<tr>
<td>Zig</td>
<td>335 MB</td>
<td>800 KB</td>
<td>800 KB</td>
<td>No</td>
<td>Mostly easy</td>
</tr>
<tr>
<td>C++</td>
<td>230 MB</td>
<td>14 KB</td>
<td>940 KB</td>
<td>Yes</td>
<td>Tedious</td>
</tr>
<tr>
<td>C</td>
<td>144 MB</td>
<td>14 KB</td>
<td>13 KB</td>
<td>Yes</td>
<td>Tedious</td>
</tr>
<tr>
<td>Python</td>
<td>75 MB</td>
<td>1 KB</td>
<td>7 MB</td>
<td>Yes</td>
<td>Unnecessary</td>
</tr>
<tr>
<td>JavaScript (Node)</td>
<td>60 MB</td>
<td>1KB</td>
<td>80 MB</td>
<td>Yes</td>
<td>Unnecessary</td>
</tr>
<tr>
<td>Lisp (SBCL)</td>
<td>45 MB</td>
<td>1KB</td>
<td>40 MB</td>
<td>Probably</td>
<td>No</td>
</tr>
<tr>
<td>Tcl</td>
<td>8 MB</td>
<td>1 KB</td>
<td>?</td>
<td>Yes</td>
<td>Unnecessary</td>
</tr>
<tr>
<td>Lua</td>
<td>1 MB</td>
<td>1 KB</td>
<td>1 MB</td>
<td>Yes</td>
<td>Unnecessary</td>
</tr>
</tbody></table>
<h2 id="sdk-size">SDK size</h2>
<p>Just looking at SDK size, Rust is an outlier. Even compared to a similarly complex language like C++, the Rust SDK is absolutely huge. At the moment, I don&#39;t know why the SDK is so big. Even after allowing for a build tool, custom linker, and standard library, the Rust SDK is disappointingly heavy. This unfortunately matches my <a href="rust-first-experience.html">previous experience with Rust on Windows</a>. <strong>Update</strong>: Using the &quot;minimal&quot; profile, the SDK was closer to 650 MB for native compilation and another 150 MB for cross-compilation.</p>
<p>Obviously, it&#39;s not fair to compare the compile-to-native languages to scripting languages, but comparisons within each category seem appropriate. Go is the second largest, but it comes with some impressive features: the ability to trivially cross-compile and <a href="https://pkg.go.dev/std">a large standard library</a>. Go&#39;s offering seems on par with C#, but with a better &quot;compile to native code&quot; story (and, obviously, larger differences in the programming languages themselves).</p>
<p>Zig is larger than I expected for a simple language, but it can cross-compile for different architectures (similar to Go), and <a href="https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j">Zig can even compile C/C++ code</a>, so it&#39;s arguably worth the footprint.</p>
<p>Looking at interpreted languages, the results are pretty similar except for Tcl and Lua (both of which don&#39;t come with much of a standard library).</p>
<h2 id="hello-world-program-size">&quot;Hello, world!&quot; program size</h2>
<p>The Go binary shows one of Go&#39;s weaknesses -- it&#39;s compiled to native, but it has to include the entire runtime in each binary. This isn&#39;t a deal-breaker for me, so I&#39;m not too concerned.</p>
<p>I <em>am</em> curious why the Zig binary is so large, but I haven&#39;t investigated any further yet. Given that Zig supports &quot;freestanding&quot; binaries, I&#39;m sure it&#39;s possible to create minimal binaries with Zig.</p>
<p>The C++ binary using &quot;iostream&quot; was unacceptably big, but using &quot;stdio.h&quot; gets it back in line with C, in the low double-digit kilobytes.</p>
<h2 id="stand-alone-executable-size">Stand-alone executable size</h2>
<p>Deployment is probably my least favorite part of software. Obviously, there are exceptions, but in most cases, a &quot;program that does X&quot; would be most convenient as a single executable (or at least a single zip file) that just does X. Here, I&#39;m looking at fully statically-linked or bundled binaries.</p>
<p>Native languages generally compile to a single binary. I didn&#39;t try to get a fully static binary from Rust, but I&#39;ve read that it&#39;s possible. C certainly is good at producing small executables (in the past, this was a prerequisite!).</p>
<p>The other languages show some interesting results: JavaScript and C# appear to be the most bloated, closely followed by SBCL (a Common Lisp implementation). But for JavaScript there are multiple runtimes--80 MB is for Deno, but QuickJS is under 1 MB--so JavaScript supports indirectly optimizing for either size or speed. Lisp has a similar story, although I didn&#39;t investigate it in depth. Python was impressively slim (definitely a surprise for me!).</p>
<p>That leaves C# which, sadly, just appears to be bloated. For the record, I couldn&#39;t get a Tcl bundle working, but I suspect it would be &lt; 10 MB.</p>
<h2 id="developing-on-a-raspberry-pi">Developing <em>on</em> a Raspberry Pi</h2>
<p>Note: this section is about developing/compiling <em>on</em> a Raspberry Pi B.</p>
<p>The only languages that appeared to not be trivial to compile on a Raspberry Pi B with Alpine Linux were C# (this appears to be an unsupported platform) and Zig (theoretically, you might be able to bootstrap an environment, but I haven&#39;t attempted that yet).</p>
<h2 id="cross-compiling-for-a-raspberry-pi">Cross-compiling for a Raspberry Pi</h2>
<p>Although I&#39;m interested in developing directly on a Pi (as part of <a href="minimal-dev-env.html">my minimal development environment</a>), it&#39;s likely I&#39;ll end up doing some development on a (faster) desktop, and then want to run the output on a Pi. Results here are easily categorized:</p>
<ul>
<li>Cross-compiling not needed<ul>
<li>JavaScript (QuickJS, Node, but <em>not</em> Deno)</li>
<li>Lua</li>
<li>Python</li>
<li>Tcl</li>
</ul>
</li>
<li>Trivial to cross-compile<ul>
<li>Go</li>
<li>Rust (note: requires <a href="https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux">editing Cargo&#39;s config file</a>)</li>
<li>Zig (<a href="https://github.com/ziglang/zig/issues/4875">except for C/C++ code</a>)</li>
</ul>
</li>
<li>Tedious, but possible to cross-compile<ul>
<li>C</li>
<li>C++</li>
</ul>
</li>
<li>Cross-compile failed/didn&#39;t work/not possible<ul>
<li>C# (executable failed to run)</li>
<li>SBCL (not necessary with runtime, but not possible <em>without</em> a runtime)</li>
</ul>
</li>
</ul>
<p>Scripting languages sort of get a free pass here, but there are almost certainly large differences in ease of deployment.</p>
<p>Go and Zig have excellent tooling for cross-compiling. And if Zig can eventually support cross-compiling C/C++ code without requiring a separate toolchain, that would be huge! <strong>Update</strong>: Cross-compilation for Rust worked well, once I found out <a href="https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux">how to tell Rust to use its bundled linker</a>.</p>
<p>C/C++ support cross-compiling through a painful process of setting up an entire compilation environment for the target. It&#39;s tedious and annoying, and I hope I never have to do it again.</p>
<p>As for C#, I suspect there&#39;s some way to get them to successfully cross-compile for a Pi, but neither worked for me. I put SBCL in the last category because it seems to require running on the target in order to produce a bundle.</p>
<h1 id="analysis">Analysis</h1>
<p>Subjectively, I was least impressed with the following languages, so they&#39;ve been cut:</p>
<ul>
<li>C#: big and bloated, with poor support for Raspberry Pi -- it&#39;s a shame because I really like C# and the .NET standard library</li>
<li>Lisp: unimpressive bundle size/cross-compiling story -- but honestly, it&#39;s too esoteric for me, and the community is highly fragmented</li>
<li>Tcl: inconvenient tooling and, sadly, not popular enough to ensure it doesn&#39;t fade away</li>
</ul>
<p>I&#39;ll tackle the remaining languages in two categories: native/compiled/statically typed vs. interpreted/dynamically typed.</p>
<h2 id="native-languages">Native languages</h2>
<p>Here are the remaining native languages, along with my favorite and least favorite qualities:</p>
<ul>
<li>C: simple and portable, but requires macros for many abstractions (and has an error-prone standard library)</li>
<li>C++: powerful abstractions, but an inconsistent standard library</li>
<li>Go: excellent tooling, but I still don&#39;t like the overhead of a garbage collector for native code</li>
<li>Rust: memory safety without a garbage collector, but the SDK is enormous (and supposedly slow)</li>
<li>Zig: efficient tooling, but immature (likely with breaking changes)</li>
</ul>
<h3 id="c-and-rust">C++ and Rust</h3>
<p>If I need powerful abstractions, C++ and Rust are the candidates. At the moment, I&#39;m leaning towards giving Rust a try (despite the gigantic SDK). I&#39;m familiar with C++, and it&#39;s certainly capable, but Rust&#39;s memory safety guarantees are worth exploring in depth. Hopefully that doesn&#39;t end up being a mistake...</p>
<h3 id="c-go-zig">C, Go, Zig</h3>
<p>If I&#39;m just looking for a simple and fast language, that would leave C, Go, and Zig. C is almost certainly future-proof for another decade or two and the SDK is reasonably sized. I&#39;m less sure about Go and Zig, despite their efficient tooling. I&#39;m skeptical of Go&#39;s niche (native code, but with a garbage collector). Zig seems too immature, but its C/C++ compatibility is attractive.</p>
<p>Overall, Rust&#39;s unique combination of safety and speed is compelling, and I&#39;m sure I&#39;ll end up using it eventually. I&#39;ll probably also need to use C where it&#39;s already entrenched.</p>
<h2 id="interpreted-languages">Interpreted languages</h2>
<p>Here are the remaining interpreted/dynamic languages:</p>
<ul>
<li>Python: ubiquitous, with a large standard library, but the language has a lot of warts and a history of compatibility problems</li>
<li>JavaScript/TypeScript: the only option for the web, with a convenient type system in TypeScript, but without a standard library and runtime (and the module story is <em>still</em> fragmented!)</li>
<li>Lua: minimalist, but no standard library</li>
</ul>
<p>These languages are almost a battery inclusion continuum from &quot;included&quot; to &quot;sold separately&quot;.</p>
<h3 id="python">Python</h3>
<p>I don&#39;t like Python. But it&#39;s everywhere! Now that Python is convenient on Windows, Python is almost a defacto portable shell scripting language (with a lot more). For example, the <a href="https://github.com/ziglang/zig-bootstrap">Zig bootstrap process</a> requires Python! If it had required Node, people would have lost their minds. I think it&#39;s high time I give in and just embrace Python.</p>
<h3 id="javascript">JavaScript</h3>
<p>JavaScript has somehow leap-frogged Python to become a convenient language, and TypeScript makes it even better for large projects. But I will admit that Node&#39;s API is irritating, and the NPM ecosystem continually has to grapple with the lack of a standard library. Deno&#39;s tooling is excellent, but Deno also breaks compatibility left and right. JavaScript is definitely future-proof, but the non-browser runtimes I&#39;m less sure about.</p>
<h3 id="lua">Lua</h3>
<p>Lua is a great language for embedding, but I&#39;m not sure it can compete with the popularity of Python and JavaScript for general software tasks.</p>
<h3 id="all-of-the-above">All of the above</h3>
<p>Realistically, I&#39;m probably going to use all three of these scripting languages, just for different purposes:</p>
<ul>
<li>Python for tools and scripts</li>
<li>JavaScript on the web</li>
<li>Lua for embedding</li>
</ul>
<h1 id="thats-all">That&#39;s all!</h1>
<p>When I started this investigation, I thought Rust was a shoo-in, but it&#39;s big and not as stable/polished as I&#39;d expected. It&#39;s still at the top of my &quot;native&quot; list, but only because of its unique combination of memory safety and systems-level design.</p>
<p>Prior to digging in a bit more, I wanted to continue avoiding Python in favor of JavaScript/TypeScript (running under Deno where possible, and Node otherwise). I&#39;ve finally given in, and I think I&#39;ll be writing a lot more Python in the future. I&#39;d also written off Lua, but its minimalist design dovetails nicely with my minimal development environment aspirations, so I might give Lua another shot. I&#39;ll happily continue using JavaScript (really TypeScript) for the web, of course.</p>
<h2 id="addendumnotes">Addendum/notes</h2>
<p>The next section is just a collection of notes I made while testing out languages. It&#39;s likely riddled with factual errors.</p>
<h3 id="c">C#</h3>
<ul>
<li>Install involves running a script -- will it pollute my system? Can I fully remove it?</li>
<li>Docker images are provided -- would that be the safest way to try it out?</li>
<li>Not seeing a Dockerfile on GitHub for ARMv6...</li>
<li>What about Mono? Didn&#39;t see any packages starting with &quot;mono&quot; on Alpine Linux...</li>
<li>Cross-compile for Pi didn&#39;t work</li>
</ul>
<h3 id="go">Go</h3>
<ul>
<li>Set <code>GOOS</code> and <code>GOARCH</code> to set OS and architecture for cross-compilation</li>
</ul>
<h3 id="lisp-sbcl">Lisp (SBCL)</h3>
<ul>
<li>Native package</li>
<li>Arrow keys didn&#39;t work in interpreter</li>
<li>It seems like producing a self-contained, native executable for a different platform is frequently not supported by Lisps</li>
</ul>
<h3 id="lua-1">Lua</h3>
<ul>
<li>Has tons of native packages... but is it portable to Windows?</li>
<li>Language server: <a href="https://github.com/LuaLS/lua-language-server">https://github.com/LuaLS/lua-language-server</a> -- note that it&#39;s complicated to build...</li>
</ul>
<h3 id="jsts">JS/TS</h3>
<ul>
<li>Probably will need Node at some point, but that runs on Raspberry Pi</li>
</ul>
<h3 id="python-1">Python</h3>
<ul>
<li>Zig bootstrap requires Python 3, ha!</li>
</ul>
<h3 id="rust">Rust</h3>
<ul>
<li>Try with Alpine package first, since it&#39;s convenient, and easy to remove</li>
<li>Raspberry Pi B Alpine Linux triple: arm-unknown-linux-musleabihf</li>
<li>Attempt to cross-compile failed with &quot;linker `cc` not found&quot; (and suggestions from the web didn&#39;t help)</li>
<li>Cross-compiler setup from rustup was Visual Studio-levels of huge (1.5 GB)</li>
<li>Finally found <a href="https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux">the trick</a> for linking during cross-compilation: point Cargo to &quot;rust-lld&quot; (which is installed with the toolchain)</li>
</ul>
<h3 id="tcl">Tcl</h3>
<ul>
<li>Couldn&#39;t figure out how to make a TclKit...</li>
</ul>
<h3 id="zig">Zig</h3>
<ul>
<li>No build for armv6l, but old build for armv6kz</li>
<li>Crashes on C compile--also very slow to compile</li>
<li>Hello world didn&#39;t work--also kind of slow to compile</li>
<li>Might try bootstrapping from my desktop, but probably too immature at the moment</li>
<li>Cross compile to Raspberry Pi B with Alpine Linux: <code>zig build -Dtarget=arm-linux-musleabihf -Dcpu=arm1176jzf_s</code></li>
<li>Cross-compiling C code <a href="https://github.com/ziglang/zig/issues/4875">doesn&#39;t appear to be possible at the moment</a></li>
</ul>

<footer>
<p>&crarr; <a href="../../index.html">Back to home</a></p>
</footer>
</article>
</main>

</body>
</html>
