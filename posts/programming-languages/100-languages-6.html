<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Project Euler in your BIOS</title>
<meta name="description" content="Or: 100 languages, week 4: return of the boot sector." />
<meta name="keywords" content="100-languages" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../css/style.css" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Project Euler in your BIOS",
  "abstract": "Or: 100 languages, week 4: return of the boot sector.",
  "keywords": "programming-languages,100-languages",
  "datePublished": "2024-04-11"
}
</script>
</head>
<body>
<header>
<h1><a href="../../index.html">Schemescape</a></h1>
<p>Development log of a life-long coder</p>

<nav>
<strong>Topics:&nbsp;</strong>
<ul>
<li><a href="../../posts/programming-languages/index.html">programming-languages</a></li>
<li><a href="../../posts/100-languages/index.html">100-languages</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href="../../posts/programming-languages/100-languages-6.html">Project Euler in your BIOS</a></h1>
<p><time datetime="2024-04-11">April 11, 2024</time></p>
</header>
<p>I'm still trying to <a href="100-languages.html">write code in 100 different programming languages</a>. See <a href="https://github.com/jaredkrinke/100-languages">this repository</a> for a summary table and links to code.</p>
<p>As always, <strong>none of this is groundbreaking</strong>, but it <em>is</em> fun to see my code running in places I hadn't considered before, like (this time) during the PC boot sequence or <a href="100-languages-5.html#postscript">within a PostScript document</a>.</p>
<h1 id="week-4">Week 4</h1>
<p>The calendar says this week isn't over yet, but I doubt I'll finish any more problems this week. Also, I'm compelled to share my first x86 assembly program.</p>
<p>After <a href="100-languages-2.html">experiencing SectorLISP</a> on day 2, I've been wanting to try my hand at developing for the (in)famous <a href="https://en.wikipedia.org/wiki/Boot_sector#The_IBM_PC_and_compatible_computers">PC boot sector</a>. Thus, I decided to solve Project Euler problem 26 using <strong>16-bit (&quot;real&quot; mode) x86 assembly</strong> (with the BIOS API for text output).</p>
<h2 id="x86-assembly">x86 assembly</h2>
<h3 id="32-bit-user-mode">32-bit, user mode</h3>
<p>My first stop was to learn about x86 assembly, and I used <a href="https://ratfactor.com/assembly-nights">Assembly Nights on ratfactor.com</a> to get started. By coincidence, like the Assembly Nights author, I was developing on an old netbook (<a href="minimal-dev-env-4.html#hello-netbook">because minimalism</a>). I used <a href="https://nasm.us/">NASM</a> because it seemed popular, and I'm comfortable with &quot;destination first&quot; syntax.</p>
<p><strong>I learned the bare minimum x86 assembly necessary to implement a solution</strong> in 32-bit (&quot;protected&quot; mode)--just <code>mov</code>, <code>push</code>, <code>pop</code>, <code>cmp</code>, <code>call</code>, <code>ret</code>, arithmetic, and conditional/unconditional jumps (along with Linux system calls for writing strings and terminating the process).</p>
<h3 id="16-bit-bare-metal--bios">16-bit, &quot;bare metal&quot; (+ BIOS)</h3>
<p>After that, it was just a simple* matter of porting the 32-bit code to 16-bit mode (removing <code>e</code> from register names and halving the word size). And then I got to experience <strong>the joy of learning about the PC BIOS</strong>.</p>
<p>The web is actually littered with examples of &quot;bare metal&quot; x86 programming (aside: does it count as &quot;bare metal&quot; if you're using the BIOS API?). Annoyingly, <strong>most of the examples I found didn't actually work</strong> for me. There are also many proclamations of required initialization rituals that I didn't (and still don't) understand. Some examples worked in <a href="https://www.qemu.org/">QEMU</a> but not in Hyper-V or <a href="https://justine.lol/blinkenlights/">Blinkenlights</a>. Others inverted that sentence. And then there's real hardware, which is much more fickle.</p>
<p><strong>Here's what actually worked for me</strong>  (about which I'm 100% <em>not</em> confident):</p>
<ul>
<li><em>Do not</em> start with <code>cli</code></li>
<li><em>Do</em> initialize <code>ds</code> and <code>ss</code> segment registers</li>
<li><em>Do</em> initialize  the stack pointer (<code>sp</code>)</li>
</ul>
<p>Here's the code I used (in this case, I chose to have the stack grow down from where boot sector code must start):</p>
<pre><code class="language-asm">    <span class="hl-function_builtin_instruction">mov</span> <span class="hl-constant_builtin_register">ax</span><span class="hl-operator">,</span> <span class="hl-number">0</span>
    <span class="hl-function_builtin_instruction">mov</span> <span class="hl-identifier">ds</span><span class="hl-operator">,</span> <span class="hl-constant_builtin_register">ax</span>
    <span class="hl-function_builtin_instruction">mov</span> <span class="hl-identifier">ss</span><span class="hl-operator">,</span> <span class="hl-constant_builtin_register">ax</span>
    <span class="hl-function_builtin_instruction">mov</span> <span class="hl-identifier">sp</span><span class="hl-operator">,</span> <span class="hl-number">0x7c00</span>
</code></pre>
<p>Then you can set <code>al</code> to a character, <code>ah</code> to <code>0xe</code>, and execute <code>int 0x10</code> to output the character (and be moderately confident that it will actually appear).</p>
<p><strong>The above worked for me on real hardware, QEMU, Blinkenlights, and v86.</strong></p>
<p>*I will admit that the &quot;simple&quot; port to 16-bit actually took me a while because I forgot to update a line that implicitly depended on word size (<code>add si, 4</code> â†’ <code>add si, 2</code>).</p>
<p>Regardless, <a href="https://github.com/jaredkrinke/100-languages/blob/main/src/p26.asm">here's the final code</a>.</p>
<p>You can run the code in your browser using <a href="https://copy.sh/v86/">v86</a> by <a href="https://copy.sh/v86/?profile=custom&amp;fda.url=data:file/octet-stream;base64,uAAAjtiO0LwAfLsAALoAAL4AAIPDAYH76AN0EYnZ6FUAOfB/AuvsicaJ2uvmidDoDQDplQBQg8AwtA7NEFjDUlFTUFa7CgC+AAC6AAD3+1KDxgGD+AB18oP+AHQJWOjU/4PuAevytA6wDc0QsArNEF5YW1law1dWUlFTUL8AALsKALgKADnIfQUPr8Pr97oAAPf5g/oAdB2J0IPHAVC6AACJ5oPGAoPCATn6dNg7BHXyidDrA7gAAIP/AHQGW4PvAev1W1tZWl5fw/Q=">clicking this link</a>. Even better, <a href="https://github.com/jaredkrinke/100-languages/blob/main/src/p26.img">download the assembled boot sector</a>, copy the boot sector onto a USB stick (or floppy drive), and try it on real hardware!</p>
<h3 id="notes">Notes</h3>
<p>I'll end with some notes I made while writing x86 assembly</p>
<ul>
<li><strong>I had to use <em>every</em> register</strong> available to me (not counting <code>bp</code>, which I think I could have technically gotten away with using)</li>
<li><strong>I wish I'd done this sooner</strong>--knowing even just a tiny bit of assembly would have been helpful on numerous occasions</li>
<li>Having registers at my disposal <em>almost</em> made assembly easier to write than Forth (of course, this is more a reflection of my discomfort with stack-based languages--to say nothing of the interactive development benefits a Forth can provide)</li>
</ul>

<footer>
<p>&crarr; <a href="../../index.html">Back to home</a></p>
</footer>
</article>
</main>

</body>
</html>
