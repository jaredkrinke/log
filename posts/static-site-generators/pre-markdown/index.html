<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Schemescape: Static site generation anecdotes</title>
<meta name="description" content="Tales of static site generators in the pre-Markdown age." />
<meta name="keywords" content="linux" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../../css/style.css" />
<link rel="alternate" type="application/rss+xml" href="../../../feed.xml" />
</head>
<body>
<header>
<h1><a href="../../../">Schemescape</a></h1>
<p>Development log of a life-long coder</p>
<nav>
<ul>
<li><a href="../../../posts/static-site-generators">static-site-generators</a></li>
<li><a href="../../../posts/linux">linux</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href=".">Static site generation anecdotes</a></h1>
<p><time datetime="2021-09-12">September 12, 2021</time></p>
</header>
<p>Feel free to skip this post about my personal history with static sites.</p>
<h1 id="static-sites-without-the-generator">Static sites without the generator</h1>
<p>Prior to the year 2000, I maintained a couple of static web sites using just notepad (no build process or even templates). Redesigning a site required editing every page by hand, so I just tried to avoid redesigns entirely. This tedious experience sowed the seeds of my later static site generator projects.</p>
<h1 id="first-attempt">First attempt</h1>
<p>Fast forward to 2001. When free web page hosting was usually limited to a couple of megabytes and static files (uploaded via <a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">FTP</a>) were the only option, I actually created a static site generator. It was written in C++ and allowed you to define custom elements using an XML-like syntax. It was one of my earliest programming projects and it introduced me to the joy of creating yet another string class and the horrors of Autoconf. I published it as open source software and, surprisingly, there was one guy who ended up using it for a large site (mostly just because he could store all his content in one huge file).</p>
<h1 id="new-and-improved">New and improved</h1>
<p>A year later (in 2002), I rewrote the tool--this time with a domain-specific language (still influenced by XML) and the ability to target multiple output formats (HTML, <a href="https://en.wikipedia.org/wiki/Man_page">man pages</a>, and even plain text). I also wisely used the <code>string</code> class from C++&#39;s standard library instead of reinventing the wheel. Despite the improvements, I didn&#39;t end up using this tool very much because, frankly, I didn&#39;t have a lot of content to post anyway. I don&#39;t think anyone else ended up using this version of the tool.</p>
<h1 id="the-unix-way">The UNIX way</h1>
<p>The following year (2003), I was enamored with the UNIX philosophy of stringing together simple text-based tools, so of course I made yet another static site generator. This one (which I never released, and nearly lost recently) had some unique features, including the ability to aggregate content across multiple sites.</p>
<p>Unlike my previous tools, this one was not written in C++; in fact, in wasn&#39;t written in a compiled language at all. In true UNIX fashion, this static site generator composed a bunch of standard UNIX tools, using <a href="https://en.wikipedia.org/wiki/Bourne_shell">Bourne shell</a> script as the glue.</p>
<p>The most user-friendly change was that I switched from XML-like markup to wiki-like plain text formatting (very similar to <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>, which didn&#39;t exist at the time). Despite this huge boost in ergonomics, I went overboard with trying to use standard tools and settled on a decidedly <em>not</em> user-friendly template system based on the ever verbose <a href="https://www.w3.org/Style/XSL/">XSLT</a>. Very contradictory choices...</p>
<p>The workflow was quite a doozy, utilizing a long list of tools:</p>
<ol>
<li>Loop through directories using <code>ls</code> (one for each topic, following symbolic links, if needed)</li>
<li>Escape topic and post names using <code>tr</code> for URL-friendliness</li>
<li>Loop through posts (one directory for each)<ol>
<li>Test if the file had been modified since last generated</li>
<li>Resolve the relative path using <code>$PWD</code> and <code>sed</code></li>
<li>Find the &quot;body&quot; (post content) file and format its last modified time using <code>find</code> and <code>date</code></li>
<li>Create a summary using <code>cat ... |head -c 150</code></li>
<li>Generate structured XML for the post, as follows<ol>
<li>Image files were passed through, but thumbnails were generated using <a href="https://imagemagick.org/index.php">Image Magick</a>&#39;s <code>mogrify</code> tool and captions came from a <code>.caption</code> file sitting next to the image file</li>
<li>The content file used my own text-based format that was similar in spirit to Markdown (but Markdown hadn&#39;t been invented yet!)</li>
<li>My wiki/Markdown-esque format was implemented entirely using regular expressions (via <code>sed</code>), supporting headings, bold text, bulleted lists, and blocks of text or code</li>
<li>There was also some automatic branding and linking using <code>m4</code> for find and replace</li>
<li>(Non-inline) References to other URLs were simply just files containing a URL</li>
</ol>
</li>
</ol>
</li>
<li>Concatenate all the XML files into one big XML file</li>
<li>Generate a home page, an archive page, an RSS feed using XSLT (via <code>xsltproc</code>)</li>
<li>Generate each post that isn&#39;t up to date using XSLT</li>
<li>Upload each modified file by generating FTP commands in a shell script and piping that to <a href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol#SFTP_client">SFTP</a></li>
</ol>
<p>It&#39;s a bit convoluted for sure, but (other than not using Markdown, which didn&#39;t exist until 2004) it relied solely on standard tools. Maybe XSL isn&#39;t everyone&#39;s favorite, but at least I didn&#39;t invent my own template language this time!</p>
<p><strong>Update</strong>: <a href="https://github.com/jaredkrinke/flog">Here&#39;s the code</a></p>
<h1 id="now-what">Now what?</h1>
<p>So what would I do differently today? I already briefly outlined my ideal workflow (using separate files, Markdown, etc.) in the <a href="../overview/">last post</a>, but I didn&#39;t delve into implementation details.</p>
<p>Ideally, I won&#39;t have to create my own static site generator today because there are a lot more &quot;off the shelf&quot; options available in 2021. If I did have to write one, I&#39;d probably use <a href="https://nodejs.org/en/%5B">Node</a> or <a href="https://deno.land/">Deno</a> with <a href="https://www.typescriptlang.org/">TypeScript</a> and possibly <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> for templates. Diagrams would perhaps use <a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a> (rendered to SVG at build time), and the whole thing would have a (gasp) GUI implemented using <a href="https://microsoft.github.io/monaco-editor/">Visual Studio Code&#39;s editor component</a>, packaged in a reasonably sized executable (perhaps using <a href="https://neutralino.js.org/">Neutralino</a>).</p>
<p>Here&#39;s hoping I don&#39;t have to build such a tool!</p>

<footer>
<p><a href="../../../">Back to home</a></p>
</footer>
</article>
</main>
</body>
</html>
