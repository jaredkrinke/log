<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Speeding up md2blog, part 3</title>
<meta name="description" content="I made a rookie mistake while trying to optimize my workflow for building this site." />
<meta name="keywords" content="md2blog,netbooks" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<link rel="stylesheet" href="../../css/style.css" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Speeding up md2blog, part 3",
  "abstract": "I made a rookie mistake while trying to optimize my workflow for building this site.",
  "keywords": "static-site-generators,md2blog,netbooks",
  "datePublished": "2023-04-07"
}
</script>
</head>
<body>
<header>
<h1><a href="../../index.html">Schemescape</a></h1>
<p>Development log of a life-long coder</p>

<nav>
<strong>Topics:&nbsp;</strong>
<ul>
<li><a href="../../posts/static-site-generators/index.html">static-site-generators</a></li>
<li><a href="../../posts/md2blog/index.html">md2blog</a></li>
<li><a href="../../posts/netbooks/index.html">netbooks</a></li>
</ul>
</nav>
</header>
<main>
<article>
<header>
<h1><a href="../../posts/static-site-generators/speeding-up-rebuilds-3.html">Speeding up md2blog, part 3</a></h1>
<p><time datetime="2023-04-07">April 7, 2023</time></p>
</header>
<p>In <a href="speeding-up-rebuilds-2.html">part 2</a>, I added support for incremental builds of this site, based on GNU Make.</p>
<h1 id="original-thought-process">Original thought process</h1>
<p>My reasoning for investigating incremental builds seemed sound:</p>
<ul>
<li>Rebuilding the entire site <em>every time</em> was obviously unnecessary</li>
<li>Based on some measurements, syntax highlighting and processing Markdown were the most time-consuming operations (in that order), by far</li>
<li>Thus, it made sense to avoid re-running these steps for pages that didn&#39;t require updates</li>
</ul>
<p>I went ahead with my experiment fully aware that GNU Make probably wasn&#39;t well-suited to the project (because it creates a new process for each task and Deno, while reasonable, has significant startup overhead). I&#39;m still happy I used Make because this issue has straight-forward mitigations: don&#39;t spin up new processes (e.g. rely on a server) or move the dependency graph into md2blog&#39;s main process.</p>
<h1 id="but">But...</h1>
<p>... I made a rookie mistake. Rather than carefully scrutinizing my workflow, I just charged ahead with optimizing the obvious bottleneck. In the end, I was able to easily get the incremental build down to 3 seconds (N.B. on a 12 year-old netbook). This meant that I could author a new post and view the results on my (slow) computer fairly quickly, to enable fast iteration.</p>
<p>So what&#39;s the problem?</p>
<p>The problem is that I measured a full clean build in isolation, but my actual workflow when using md2blog is to run md2blog as a server that watches the file system and automatically triggers rebuilds, and <em>those</em> subsequent (full) rebuilds are not only about 50% faster (down in the 6 second range), they are also ripe for <em>even simpler</em> optimizations.</p>
<h1 id="a-new-approach">A new approach</h1>
<p>Given that rebuilds in my &quot;edit and test&quot; (hot-reloading server) workflow all run in the same process and most of the work is redundant (rebuilding pages that haven&#39;t changed), and that the most expensive operation (by far) is adding syntax highlighting, one trivial optimization would be to simply <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> the syntax highlighting function.</p>
<p>For memory efficiency, I initially planned to hash input strings and use that as the key to look up results in a cache. This ended up being trickier than I expected because the <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest"><code>crypto.subtle.digest</code></a> function provides its result asynchronously and <a href="https://marked.js.org/using_advanced#highlight">Marked&#39;s highlight callback</a> is synchronous. In the end, I decided this was premature optimization anyway--I&#39;m already going to be caching the entire output in memory, so caching the entire input as well is just a linear increase in memory usage--there&#39;s no need to complicate things.</p>
<p>After writing about 10 lines of trivial code, I had a working cache, and rebuilds were under 3 seconds--faster than my previous convoluted incremental approach. Most of the remaining time was simply validating that internal links are not broken (a step I haven&#39;t implemented in my Makefile yet).</p>
<p>Lesson learned: always measure and optimize the <em>actual</em> scenario--not an artifical (or easier to measure) one!</p>
<h1 id="further-optimizations">Further optimizations</h1>
<p>With this one trivial optimization, I got an acceptably fast workflow, even on a 12 year-old netbook. But there were still two obvious avenues for improvement (that didn&#39;t involve switching languages or runtimes):</p>
<ol>
<li>Move internal link-checking off the critical path of my workflow (either by deferring it or skipping it entirely--broken links will be caught when I do a full &quot;official&quot; build, prior to uploading the site)</li>
<li>Implement real incremental builds, at least for internal rebuilds (done properly, this could even avoid a significant chunk of link-checking work)</li>
</ol>
<p>After moving link-checking off the critical path (#1 above), hot rebuilds now complete in under a second (with link-checking completing a second or two later), so I&#39;m no longer feeling terribly motivated to rearchitect everything around an accurate dependency graph (#2), at least not until I either add enough content to make things feels sluggish once again or I downgrade to an even slower computer.</p>

<footer>
<p>&crarr; <a href="../../index.html">Back to home</a></p>
</footer>
</article>
</main>

</body>
</html>
