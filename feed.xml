<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-05-27T00:03:21.592Z</updated>

<entry>
<title>Lisp Game Jam (Spring 2023)</title>
<id>https://log.schemescape.com/posts/game-development/lisp-game-jam.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/lisp-game-jam.html"/>
<updated>2023-05-26T00:00:00.000Z</updated>
<summary type="text">Might as well try and make a game in Common Lisp, right?</summary>
<content type="html">&lt;p&gt;Recently, I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Common Lisp&lt;/a&gt; and so I&amp;#39;ve been keeping an eye out for practice projects. Fortunately, as I&amp;#39;m writing this, the &lt;a href=&quot;https://itch.io/jam/spring-lisp-game-jam-2023&quot;&gt;Lisp Game Jam (Spring 2023)&lt;/a&gt; is just about to start, so I guess I&amp;#39;m doing that now.&lt;/p&gt;
&lt;p&gt;For the time being, I&amp;#39;ll just describe the (tiny) game I have in mind.  I&amp;#39;m not terribly confident that I&amp;#39;ll be able to complete anything within the next ten days, but I&amp;#39;ll give it a try anyway!&lt;/p&gt;
&lt;h1 id=&quot;a-word-game&quot;&gt;A word game&lt;/h1&gt;
&lt;p&gt;The goal of the game is to look at a bunch of letters and then, as quickly as possible, find the longest word that can be constructed by drawing from the given set of letters (without replacement). Ideally, this would be a real-time, global competition, but I doubt I&amp;#39;ll be able to get anywhere close to that within 10 days (of roughly 1 - 2 hours per day, at best, of development time).&lt;/p&gt;
&lt;p&gt;When I originally had this idea, I gave it the intentionally terrible name of &lt;strong&gt;Longle&lt;/strong&gt; (&amp;quot;long&amp;quot; + &amp;quot;Boggle&amp;quot;). Today, I&amp;#39;m thinking I&amp;#39;ll call it &lt;strong&gt;Thirteen Letters&lt;/strong&gt; (actual number subject to change).&lt;/p&gt;
&lt;h1 id=&quot;plan&quot;&gt;Plan&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s my rough plan for implementing this game:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find or create a word list&lt;/li&gt;
&lt;li&gt;Consider reducing that list (based on observed word frequencies) to a set of difficult, but reasonable, puzzles&lt;/li&gt;
&lt;li&gt;Implement a simple terminal version of the game that just records how long it takes for the player to identify the longest word&lt;/li&gt;
&lt;li&gt;If time permits, create a service to distribute puzzles and record the &lt;em&gt;actual&lt;/em&gt; time taken to get a response&lt;/li&gt;
&lt;li&gt;If time is abundant, create a service to host global competitions with 30 - 60 second rounds and resulting scoreboards&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;progress&quot;&gt;Progress&lt;/h1&gt;
&lt;p&gt;As of right now (May 26th, at least as far as UTC is concerned), I&amp;#39;m struggling with the first item. The best word lists I&amp;#39;ve found so far have been copyrighted works related to Scrabble. Other than obvious legal risks, these lists also have a cap on the length of words. Most of the other word lists I&amp;#39;ve found contain proper nouns, lack inflected nouns/verbs, or contain huge amounts of questionable &amp;quot;words&amp;quot; (for example: &amp;quot;zzzs&amp;quot;).&lt;/p&gt;
&lt;p&gt;For now, I think my best bet is to use the public domain &lt;a href=&quot;https://github.com/elasticdog/yawl&quot;&gt;YAWL&lt;/a&gt; word list, possibly filtered by some arbitrary frequency cutoff based on the Google Trillion Word Corpus via &lt;a href=&quot;http://norvig.com/ngrams/&quot;&gt;Peter Norvig&amp;#39;s web site&lt;/a&gt;. After exploring this a bit, it looks like just ensuring the word is in the top ~300,000 most frequent words may be sufficient to get a set of words that I consider to be legitimate.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Resources for learning Common Lisp</title>
<id>https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html"/>
<updated>2023-05-15T00:00:00.000Z</updated>
<summary type="text">Here are the resources I&apos;ve personally found most helpful for learning Common Lisp.</summary>
<content type="html">&lt;p&gt;In order to test out fully interactive program development (&lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html&quot;&gt;as noted previously&lt;/a&gt;), I&amp;#39;ve been learning Common Lisp. I assumed that it would take a while to catch up on nearly four decades of Common Lisp&amp;#39;s progress and... I was not wrong about that. On the plus side, given the long timeline, there &lt;em&gt;are&lt;/em&gt; a lot of resources available. On the flip side, they&amp;#39;re not always up to date.&lt;/p&gt;
&lt;p&gt;Regardless, here are the resources that I&amp;#39;ve found most helpful over the last couple of weeks. My intention is to keep this list up to date as I go.&lt;/p&gt;
&lt;h1 id=&quot;introductory-materials&quot;&gt;Introductory materials&lt;/h1&gt;
&lt;p&gt;In descending order of how much time I&amp;#39;ve spent studying them (i.e. in completely arbitrary order):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gigamonkeys.com/book/&quot;&gt;&lt;strong&gt;Practical Common Lisp&lt;/strong&gt;&lt;/a&gt; by Peter Seibel&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/cover.html&quot;&gt;&lt;strong&gt;Successful Lisp&lt;/strong&gt;&lt;/a&gt; by David B. Lamkins&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leanpub.com/lovinglisp&quot;&gt;&lt;strong&gt;Loving Common Lisp, or the Savvy Programmer&amp;#39;s Secret Weapon&lt;/strong&gt;&lt;/a&gt; by Mark Watson&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;in-depth-materials&quot;&gt;In-depth materials&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Various topics: &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/&quot;&gt;Common Lisp Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debugging: &lt;a href=&quot;https://malisper.me/debugging-lisp-part-1-recompilation/&quot;&gt;Debugging Lisp (series)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Packaging/libraries: &lt;a href=&quot;https://lispmethods.com/libraries.html&quot;&gt;Source Code Organization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The LOOP macro: &lt;a href=&quot;https://www.ai.sri.com/~pkarp/loop.html&quot;&gt;Tutorial for the Common Lisp Loop Macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON libraries: &lt;a href=&quot;https://sabracrolleton.github.io/json-review.html&quot;&gt;Review of CL JSON libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;resource-collections&quot;&gt;Resource collections:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;List of libraries/tools: &lt;a href=&quot;https://awesome-cl.com/&quot;&gt;Awesome Common Lisp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;List of books: &lt;a href=&quot;https://lisp-lang.org/books/&quot;&gt;lisp-lang.org/books&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;general-reference&quot;&gt;General reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://clhs.lisp.se/Front/index.htm&quot;&gt;Common Lisp HyperSpec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-great-but-what-have-you-been-doing&quot;&gt;That&amp;#39;s great, but what have you been &lt;em&gt;doing&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s mostly a topic for a future post. Briefly: my first project has been building a service that hosts webhooks which implement &lt;a href=&quot;https://play.battlesnake.com/&quot;&gt;Battlesnake&lt;/a&gt; clients. Surely there&amp;#39;s no more noble endeavour than programming games!&lt;/p&gt;
&lt;p&gt;Battlesnake is a competitive programming game where snakes move around a grid collecting food and trying not to collide with each other or the walls. Each snake is implemented as a webhook which is given 500 milliseconds to respond with the direction it would like to move. It&amp;#39;s a simple concept, but that just leaves lots of room for optimization. As an aside, the global leaderboard is a little bit pointless in that it can&amp;#39;t take into account hardware, so for all I know my little netbook is competing with a rack of servers, but I&amp;#39;m still having fun.&lt;/p&gt;
&lt;p&gt;Hopefully I&amp;#39;ll have more to say about Battlesnake and Common Lisp soon!&lt;/p&gt;
</content>
</entry>
<entry>
<title>It&apos;s 2023, so of course I&apos;m learning Common Lisp</title>
<id>https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html"/>
<updated>2023-04-25T00:00:00.000Z</updated>
<summary type="text">I&apos;m traveling back in time to explore an ancient development workflow that is somehow more modern than today&apos;s workflows.</summary>
<content type="html">&lt;p&gt;I&amp;#39;ve &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;spent&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html&quot;&gt;time&lt;/a&gt; contemplating future-proof programming languages because I want to enusre that code I write will be usable in the future. Generally, if I want to build something and share it with others, I&amp;#39;m a pragmatist, so I&amp;#39;ll &lt;del&gt;use JavaScript&lt;/del&gt; choose a programming language that is popular, portable, and convenient.&lt;/p&gt;
&lt;p&gt;But &lt;em&gt;other times&lt;/em&gt;, I just want to have fun and experiment with other programming languages and tools. In that vein, I&amp;#39;ve been monitoring a few single-syllable, intriguing-but-maybe-not-future-proof programming languages such as &lt;a href=&quot;https://nim-lang.org/&quot;&gt;Nim&lt;/a&gt; and &lt;a href=&quot;https://ziglang.org/&quot;&gt;Zig&lt;/a&gt;. Sometimes these experiments open my eyes to new ways of programming or new tools that eventually become indispensible.&lt;/p&gt;
&lt;h1 id=&quot;janet&quot;&gt;Janet&lt;/h1&gt;
&lt;p&gt;Very recently, I ran across a newly-published (free) book about the &lt;a href=&quot;https://janet-lang.org/&quot;&gt;Janet&lt;/a&gt; programming language called &lt;a href=&quot;https://janet.guide/&quot;&gt;Janet for Mortals&lt;/a&gt; and it piqued my interest. Janet is a relatively small Lisp/Clojure-inspired scripting language that tries to fill a similar niche to Lua, but with an actual standard library (and, of course, Lisp-style metaprogramming and compile-time execution via macros).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Janet for Mortals&lt;/strong&gt; is an entertaining and informative read, and it gave me the nudge I needed to become interested in Lisps again. I had previously abandoned using Scheme because, frankly, I ran out of free time for exploratory programming. But while I was reading about Janet, I kept coming back to one question: why should I use Janet instead of an established Lisp, e.g. Scheme?&lt;/p&gt;
&lt;p&gt;For me, the most attractive qualities of Janet (other than general Lispiness) are portability, embeddability, and &lt;a href=&quot;https://janet-lang.org/docs/peg.html&quot;&gt;Parsing Expression Grammars&lt;/a&gt;. Realistically, however, I don&amp;#39;t currently have any need to embed a language, so that leaves portability and parsing. As far as portability, &lt;a href=&quot;http://www.call-cc.org/&quot;&gt;CHICKEN Scheme&lt;/a&gt;, &lt;a href=&quot;https://www.gnu.org/software/clisp/&quot;&gt;CLISP&lt;/a&gt;, and &lt;a href=&quot;http://www.sbcl.org/&quot;&gt;Steel Bank Common Lisp&lt;/a&gt; looked acceptable. For parsing, &lt;a href=&quot;https://bford.info/packrat/&quot;&gt;Packrat&lt;/a&gt; looked reasonable.&lt;/p&gt;
&lt;p&gt;At this point, I started to run out of reasons to pursue Janet instead of an established Lisp.&lt;/p&gt;
&lt;h1 id=&quot;common-lisp&quot;&gt;Common Lisp&lt;/h1&gt;
&lt;p&gt;During my research, I ran across a &lt;a href=&quot;https://mikelevins.github.io/posts/2020-12-18-repl-driven/&quot;&gt;blog post describing Common Lisp&amp;#39;s (mostly) unique REPL-driven workflow&lt;/a&gt;. In that post, the author describes handling a runtime error by just fixing the broken code--in-place, without any restarts:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Try this in your favorite repl:&lt;/p&gt;
&lt;p&gt;Define a function, foo, that calls some other function, bar, that is not yet defined. Now call foo. What happens?&lt;/p&gt;
&lt;p&gt;Obviously, the call to foo breaks, because bar is not defined. But what happens when it breaks?&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;The answer to that question is the differentiating point of repl-driven programming. In an old-fashioned Lisp or Smalltalk environment, the break in foo drops you into a breakloop.&lt;/p&gt;
&lt;p&gt;A breakloop is a full-featured repl, complete with all of the tools of the main repl, but it exists inside the dynamic environment of the broken function. From the breakloop you can roam up and down the suspended call stack, examining all variables that are lexically visible from each stack frame. In fact, you can inspect all live data in the running program.&lt;/p&gt;
&lt;p&gt;What&amp;#39;s more, you can edit all live data in the program. If you think that a break was caused by a wrong value in some particular variable or field, you can interactively change it and resume the suspended function.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;Moreover, because the entire language and development system are available, unrestricted, in the repl, you can define the missing function bar, resume foo, and get a sensible result.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I&amp;#39;ve seen various (often unreliable) &amp;quot;edit and continue&amp;quot; features over the years, but I didn&amp;#39;t realize that Common Lisp was built with this sort of workflow in mind.&lt;/p&gt;
&lt;p&gt;When I first learned to program, I used &amp;quot;printf debugging&amp;quot;, where I&amp;#39;d temporarily add in code to log values, recompile, run, and inspect the output to troubleshoot problems. Eventually, I ran into scenarios where I couldn&amp;#39;t modify the program or rerun it, so I learned to use a debugger. Using a real debugger is definitely the right thing to do, but setting up a debugging environment is often painful (and sometimes impossible).&lt;/p&gt;
&lt;p&gt;Common Lisp seems to take debugging a step further. Sure, I&amp;#39;ve modified memory in a debugger to test out potential fixes, but being able to rewrite code and patch into a live process &lt;em&gt;in a sane way&lt;/em&gt; sounds amazing--almost too good to be true.&lt;/p&gt;
&lt;p&gt;That new workflow is my motivation for learning Common Lisp. I want to try interactively building a program to see if it&amp;#39;s a pleasant way to work.&lt;/p&gt;
&lt;p&gt;Is it a good idea to learn a new programming language and standard library just to explore a new workflow? Maybe not, but I&amp;#39;m not sure there&amp;#39;s a great alternative. I&amp;#39;m sure similar REPL-editor integrations exist in other languages, but I also suspect that they&amp;#39;re buggier because they&amp;#39;ve been bolted on, rather than supported from the beginning. Additionally, if I put in the work and am not satisfied with the workflow after all, I can rest assured that I gave it the best possible chance, using standard tools.&lt;/p&gt;
&lt;p&gt;Regardless, it should be an interesting adventure!&lt;/p&gt;
</content>
</entry>
<entry>
<title>JavaScript runtime startup performance</title>
<id>https://log.schemescape.com/posts/static-site-generators/js-runtimes-startup-perf.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/js-runtimes-startup-perf.html"/>
<updated>2023-04-17T00:00:00.000Z</updated>
<summary type="text">Incremental rebuilds with GNU Make use separate processes for each task. So how does startup time compare between Node, Deno, Bun, and Leano?</summary>
<content type="html">&lt;p&gt;In a previous post, I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;set up incremental builds of this site using GNU Make&lt;/a&gt;. I was able to reduce the incremental build time (for updating a single post, on my &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-4.html#hello-netbook&quot;&gt;twelve year-old netbook&lt;/a&gt;) from 12 seconds (when doing a full rebuild using Deno) to 3 seconds (using Make, and a bunch of smaller scripts, all running under Deno). Unfortunately, the &lt;em&gt;full&lt;/em&gt; rebuild time ballooned from 12 seconds to 90 seconds when using Make.&lt;/p&gt;
&lt;p&gt;Just from watching the console output, it was apparent that Deno&amp;#39;s startup overhead was a likely culprit, so I decided to compare Deno to a few other JavaScript runtimes.&lt;/p&gt;
&lt;h1 id=&quot;hello-startup-performance&quot;&gt;Hello, startup performance!&lt;/h1&gt;
&lt;p&gt;This is a completely unscientific benchmark, but to get a feel for the minimum amount of startup overhead, I decided to compare the time to run a simple &amp;quot;hello, world&amp;quot; program on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node&lt;/a&gt; 18.14.2 (based on &lt;a href=&quot;https://v8.dev/&quot;&gt;V8&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt; 1.31.1 (based on V8)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bun.sh/&quot;&gt;Bun&lt;/a&gt; 0.5.8 (based on &lt;a href=&quot;https://developer.apple.com/documentation/javascriptcore&quot;&gt;JavaScriptCore&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html#success-and-leano&quot;&gt;Leano&lt;/a&gt; (based on &lt;a href=&quot;https://bellard.org/quickjs/&quot;&gt;QuickJS&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are the results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Runtime&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;&amp;quot;Hello, world!&amp;quot; elapsed time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Node&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;360 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Deno&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;240 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Bun&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;(crashed)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Leano&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;20 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Deno being faster than Node definitely matches my subjective experience. Unfortunately for Bun, I wasn&amp;#39;t able to get it to run under Alpine Linux (the official installer seemed to require glibc, and Bun installed via Nix was compiled for a newer instruciton set than what my netbook supports). There appeared to be open issues in Bun&amp;#39;s tracker for both problems.&lt;/p&gt;
&lt;p&gt;Leano is a minimal (and &lt;em&gt;barely&lt;/em&gt; functional) wrapper around QuickJS, so I figured it would be fast for a &amp;quot;hello, world&amp;quot;, but I wasn&amp;#39;t expecting it to be quite &lt;em&gt;that&lt;/em&gt; much faster!&lt;/p&gt;
&lt;p&gt;Of course, this is a contrived example, and it&amp;#39;s not clear how QuickJS will fare once I throw gigantic transpiled and bundled scripts at it.&lt;/p&gt;
&lt;h1 id=&quot;template-performance&quot;&gt;Template performance&lt;/h1&gt;
&lt;p&gt;One step above &amp;quot;hello, world&amp;quot; is the last stage of building this site, templating. All this does is read in JSON and HTML and interpolate them into a bunch of vanilla JS template literals. This seems like an ideal place to test Leano because it&amp;#39;s a lot less JavaScript code than, say, syntax highlighting. Note: I already know from &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-4.html#performance&quot;&gt;a previous experiment&lt;/a&gt; that V8 can be 3 - 5 times faster than QuickJS in a complex scenario like an md2blog full rebuild (presumably due to just-in-time compilation and other optimizations).&lt;/p&gt;
&lt;p&gt;Here are the times needed to apply templates to 84 posts on this site under both Deno and Leano (which use the same API):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Runtime&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Templating elapsed time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Deno&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;25 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Leano&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;These results line up with the previous ones pretty closely: Deno seems to have a startup overhead of 200 - 250 milliseconds, and that adds up when running 80+ processes sequentially. What if I run Make in parallel?&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Runtime&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Templating elapsed time (parallel)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Deno&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;19 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Leano&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Running two tasks in parallel (on my dual-core machine) closes the gap slightly.&lt;/p&gt;
&lt;p&gt;Other simple scripts that took less than a second to run (parsing front matter, generating an index, and creating an Atom feed) showed 30 - 50% improvements.&lt;/p&gt;
&lt;h1 id=&quot;heavy-lifting&quot;&gt;Heavy lifting&lt;/h1&gt;
&lt;p&gt;By far, the most complicated script in the entire pipeline is the one that processes Markdown and applies syntax highlighting to code blocks. Mostly due to embedded grammars, the script for this step weighs in at nearly 2 megabytes of JavaScript.&lt;/p&gt;
&lt;p&gt;This is where Deno&amp;#39;s caching and V8&amp;#39;s JIT shine. Processing a particularly complicated post using Deno (including process creation/termination) took about 1.5 seconds on my netbook, whereas Leano required 3 seconds. I tried precompiling the JavaScript code to QuickJS bytecode (to avoid parsing overhead), but that only saved about 40 milliseconds (I guess parsing is really fast!).&lt;/p&gt;
&lt;h1 id=&quot;final-results&quot;&gt;Final results&lt;/h1&gt;
&lt;p&gt;After moving all the small/trivial scripts over to Leano while leaving Markdown/syntax highlighting to Deno, I was able to improve upon my previous results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Scenario&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Elapsed time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;classic&amp;quot; md2blog&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;make&amp;quot; solely under Deno&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;90 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Incremental build using &amp;quot;make&amp;quot; soley under Deno&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;Full rebuild using &amp;quot;make&amp;quot; using Deno &lt;em&gt;and&lt;/em&gt; Leano&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;70 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;Incremental build using &amp;quot;make&amp;quot; using Deno &lt;em&gt;and&lt;/em&gt; Leano&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1.6 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;In the end, removing Deno&amp;#39;s startup penalty from the process resulted in a modest speedup. Unfortunately, it&amp;#39;s still slower than &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html#further-optimizations&quot;&gt;running a full rebuild under Deno when in &amp;quot;watch&amp;quot; mode&lt;/a&gt;, so, while interesting, this experiment did not lead to any changes in my current workflow.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog, part 3</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html"/>
<updated>2023-04-07T00:00:00.000Z</updated>
<summary type="text">I made a rookie mistake while trying to optimize my workflow for building this site.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;part 2&lt;/a&gt;, I added support for incremental builds of this site, based on GNU Make.&lt;/p&gt;
&lt;h1 id=&quot;original-thought-process&quot;&gt;Original thought process&lt;/h1&gt;
&lt;p&gt;My reasoning for investigating incremental builds seemed sound:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rebuilding the entire site &lt;em&gt;every time&lt;/em&gt; was obviously unnecessary&lt;/li&gt;
&lt;li&gt;Based on some measurements, syntax highlighting and processing Markdown were the most time-consuming operations (in that order), by far&lt;/li&gt;
&lt;li&gt;Thus, it made sense to avoid re-running these steps for pages that didn&amp;#39;t require updates&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I went ahead with my experiment fully aware that GNU Make probably wasn&amp;#39;t well-suited to the project (because it creates a new process for each task and Deno, while reasonable, has significant startup overhead). I&amp;#39;m still happy I used Make because this issue has straight-forward mitigations: don&amp;#39;t spin up new processes (e.g. rely on a server) or move the dependency graph into md2blog&amp;#39;s main process.&lt;/p&gt;
&lt;h1 id=&quot;but&quot;&gt;But...&lt;/h1&gt;
&lt;p&gt;... I made a rookie mistake. Rather than carefully scrutinizing my workflow, I just charged ahead with optimizing the obvious bottleneck. In the end, I was able to easily get the incremental build down to 3 seconds (N.B. on a 12 year-old netbook). This meant that I could author a new post and view the results on my (slow) computer fairly quickly, to enable fast iteration.&lt;/p&gt;
&lt;p&gt;So what&amp;#39;s the problem?&lt;/p&gt;
&lt;p&gt;The problem is that I measured a full clean build in isolation, but my actual workflow when using md2blog is to run md2blog as a server that watches the file system and automatically triggers rebuilds, and &lt;em&gt;those&lt;/em&gt; subsequent (full) rebuilds are not only about 50% faster (down in the 6 second range), they are also ripe for &lt;em&gt;even simpler&lt;/em&gt; optimizations.&lt;/p&gt;
&lt;h1 id=&quot;a-new-approach&quot;&gt;A new approach&lt;/h1&gt;
&lt;p&gt;Given that rebuilds in my &amp;quot;edit and test&amp;quot; (hot-reloading server) workflow all run in the same process and most of the work is redundant (rebuilding pages that haven&amp;#39;t changed), and that the most expensive operation (by far) is adding syntax highlighting, one trivial optimization would be to simply &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoize&lt;/a&gt; the syntax highlighting function.&lt;/p&gt;
&lt;p&gt;For memory efficiency, I initially planned to hash input strings and use that as the key to look up results in a cache. This ended up being trickier than I expected because the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest&quot;&gt;&lt;code&gt;crypto.subtle.digest&lt;/code&gt;&lt;/a&gt; function provides its result asynchronously and &lt;a href=&quot;https://marked.js.org/using_advanced#highlight&quot;&gt;Marked&amp;#39;s highlight callback&lt;/a&gt; is synchronous. In the end, I decided this was premature optimization anyway--I&amp;#39;m already going to be caching the entire output in memory, so caching the entire input as well is just a linear increase in memory usage--there&amp;#39;s no need to complicate things.&lt;/p&gt;
&lt;p&gt;After writing about 10 lines of trivial code, I had a working cache, and rebuilds were under 3 seconds--faster than my previous convoluted incremental approach. Most of the remaining time was simply validating that internal links are not broken (a step I haven&amp;#39;t implemented in my Makefile yet).&lt;/p&gt;
&lt;p&gt;Lesson learned: always measure and optimize the &lt;em&gt;actual&lt;/em&gt; scenario--not an artifical (or easier to measure) one!&lt;/p&gt;
&lt;h1 id=&quot;further-optimizations&quot;&gt;Further optimizations&lt;/h1&gt;
&lt;p&gt;With this one trivial optimization, I got an acceptably fast workflow, even on a 12 year-old netbook. But there were still two obvious avenues for improvement (that didn&amp;#39;t involve switching languages or runtimes):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Move internal link-checking off the critical path of my workflow (either by deferring it or skipping it entirely--broken links will be caught when I do a full &amp;quot;official&amp;quot; build, prior to uploading the site)&lt;/li&gt;
&lt;li&gt;Implement real incremental builds, at least for internal rebuilds (done properly, this could even avoid a significant chunk of link-checking work)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After moving link-checking off the critical path (#1 above), hot rebuilds now complete in under a second (with link-checking completing a second or two later), so I&amp;#39;m no longer feeling terribly motivated to rearchitect everything around an accurate dependency graph (#2), at least not until I either add enough content to make things feels sluggish once again or I downgrade to an even slower computer.&lt;/p&gt;
</content>
</entry>
</feed>
