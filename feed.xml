<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Wed, 06 Oct 2021 21:03:49 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[WebAssembly objects, libraries, and linking (for C code)]]></title><description><![CDATA[<p>In the interest of reusing <a href="../passing-strings-to-c/">some C string handling code I wrote for use in WebAssembly</a>, I&#39;m researching how object files, libraries, and linking work in WebAssembly.</p>
<h1 id="background">Background</h1>
<p>For native C code, the following file types and concepts are used:</p>
<ul>
<li>Header files (.h) define the interfaces used between source files</li>
<li>Source files (.c) implement functionality</li>
<li>Object files (.o) each represent the compiled (using &quot;-c&quot;) output of a single source file</li>
<li>Archive files (.a) contain many object files and are used for build-time linking (static libraries)</li>
<li>Shared objects (.so) or dynamic-link libraries (.dll) support linking at run-time (shared libraries)</li>
</ul>
<p>How does the Clang/LLVM toolchain map these concepts to WebAssembly?</p>
<h1 id="webassembly-object-files">WebAssembly object files</h1>
<p>To my surprise, WebAssembly actually publishes <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md">conventions for creating and linking object files</a>.</p>
<p>I certainly didn&#39;t read that entire document, but I did note that object files are just WebAssembly modules, with custom sections (note: custom sections are only supported in binary &quot;.wasm&quot; format, and not text &quot;.wat&quot; format).</p>
<h2 id="example">Example</h2>
<p>My WebAssembly string library is very simple:</p>
<ul>
<li>It defines <code>wasm_c_string</code> which represents a string on the heap that will be return to the JavaScript host</li>
<li>It exports 2 functions:<ul>
<li><code>allocate_wasm_c_string</code> to allocate a wasm_c_string of a given length</li>
<li><code>create_wasm_c_string</code> to allocate a wasm_c_string that is a copy of any old C string</li>
</ul>
</li>
</ul>
<p>Note that this example requires consumers of the library providing <code>malloc()</code> and <code>free()</code> to the JavaScript host. I don&#39;t export these from my library because I want consumers to be able to supply their own allocator.</p>
<h3 id="c-source-code">C source code</h3>
<p>Here&#39;s the header file (&quot;wasm-c-string.h&quot;):</p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length;
    <span class="hljs-type">char</span> buffer[];
} wasm_c_string;

<span class="hljs-comment">// Allocates an empty wasm_c_string. When done, use &quot;free&quot; to release.</span>
<span class="hljs-keyword">extern</span> wasm_c_string* <span class="hljs-title function_">allocate_wasm_c_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span>;

<span class="hljs-comment">// Creates a new wasm_c_string from an existing C string. When done, use &quot;free&quot; to release.</span>
<span class="hljs-keyword">extern</span> wasm_c_string* <span class="hljs-title function_">create_wasm_c_string</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* source)</span>;</code></pre>
<p>And the source file (&quot;wasm-c-string.c&quot;):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wasm-c-string.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

wasm_c_string* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(allocate_wasm_c_string)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span> {
    wasm_c_string* str = (wasm_c_string*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) + length);
    str-&gt;length = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)length;
    <span class="hljs-keyword">return</span> str;
}

wasm_c_string* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(create_wasm_c_string)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* source)</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-type">size_t</span> sourceLength = <span class="hljs-built_in">strlen</span>(source);
    wasm_c_string* str = allocate_wasm_c_string((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)sourceLength);
    <span class="hljs-built_in">memcpy</span>(&amp;str-&gt;buffer[<span class="hljs-number">0</span>], source, sourceLength);
    <span class="hljs-keyword">return</span> str;
}</code></pre>
<h3 id="compiling">Compiling</h3>
<p>Let&#39;s compile this to an object file (using the <a href="https://github.com/WebAssembly/wasi-sdk">WASI SDK</a>--note the &quot;-c&quot; argument that tells Clang to only output an object file and not invoke the linker):</p>
<pre><code class="language-sh">wasi-sdk\\bin\\clang -Os --sysroot wasi-sdk/share/wasi-sysroot -c wasm-c-string.c</code></pre>
<h3 id="text-format">Text format</h3>
<p>The output file defaults to &quot;wasm-c-string.o&quot; and here&#39;s the (abbreviated) corresponding text format (compliments of the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>&#39;s <code>wasm2wat</code> tool):</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;1;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__indirect_function_table&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">table</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span> funcref<span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;malloc&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;strlen&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;1;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;memcpy&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;2;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$allocate_wasm_c_string</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
...
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$create_wasm_c_string</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
...
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;allocate_wasm_c_string&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$allocate_wasm_c_string</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;create_wasm_c_string&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$create_wasm_c_string</span><span class="hljs-punctuation">)))</span>
</code></pre>
<p>You can see that it&#39;s importing memory, a function table, and C standard library functions, and that it&#39;s exporting my 2 functions.</p>
<h3 id="custom-sections">Custom sections</h3>
<p>But wait, the object file conventions document indicates that there are custom sections that can&#39;t be represented in the text format. So let&#39;s use <code>wasm-objdump</code> (also from WABT):</p>
<pre><code><span class="hljs-string">$</span> <span class="hljs-string">wasm-objdump</span> <span class="hljs-string">-s</span> <span class="hljs-string">wasm-c-string.o</span>

<span class="hljs-attr">wasm-c-string.o:</span>    <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">wasm</span> <span class="hljs-number">0x1</span>

<span class="hljs-string">...</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">0000119:</span> <span class="hljs-string">076c</span> <span class="hljs-string">696e</span> <span class="hljs-string">6b69</span> <span class="hljs-number">6e67</span> <span class="hljs-number">0208 </span><span class="hljs-string">be80</span> <span class="hljs-number">8080 </span><span class="hljs-number">0005</span>  <span class="hljs-string">.linking........</span>
<span class="hljs-attr">0000129:</span> <span class="hljs-string">00a4</span> <span class="hljs-number">0103 </span><span class="hljs-number">1661 </span><span class="hljs-string">6c6c</span> <span class="hljs-string">6f63</span> <span class="hljs-number">6174 </span><span class="hljs-string">655f</span> <span class="hljs-number">7761</span>  <span class="hljs-string">.....allocate_wa</span>
<span class="hljs-attr">0000139:</span> <span class="hljs-string">736d</span> <span class="hljs-string">5f63</span> <span class="hljs-string">5f73</span> <span class="hljs-number">7472 </span><span class="hljs-string">696e</span> <span class="hljs-number">6700 </span><span class="hljs-number">1000 </span><span class="hljs-string">00a4</span>  <span class="hljs-string">sm_c_string.....</span>
<span class="hljs-attr">0000149:</span> <span class="hljs-number">0104 </span><span class="hljs-number">1463 </span><span class="hljs-number">7265 </span><span class="hljs-number">6174 </span><span class="hljs-string">655f</span> <span class="hljs-number">7761 </span><span class="hljs-string">736d</span> <span class="hljs-string">5f63</span>  <span class="hljs-string">...create_wasm_c</span>
<span class="hljs-attr">0000159:</span> <span class="hljs-string">5f73</span> <span class="hljs-number">7472 </span><span class="hljs-string">696e</span> <span class="hljs-number">6700 </span><span class="hljs-number">1001 </span><span class="hljs-number">0010 </span><span class="hljs-number">02</span>         <span class="hljs-string">_string......</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">000016c:</span> <span class="hljs-string">0a72</span> <span class="hljs-string">656c</span> <span class="hljs-string">6f63</span> <span class="hljs-number">2e43</span> <span class="hljs-string">4f44</span> <span class="hljs-number">4504 </span><span class="hljs-number">0400 </span><span class="hljs-string">0b01</span>  <span class="hljs-string">.reloc.CODE.....</span>
<span class="hljs-attr">000017c:</span> <span class="hljs-number">0021 </span><span class="hljs-number">0300 </span><span class="hljs-string">2c01</span> <span class="hljs-number">0042 </span><span class="hljs-number">04</span>                   <span class="hljs-string">.!..,..B.</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">000018b:</span> <span class="hljs-number">0970 </span><span class="hljs-string">726f</span> <span class="hljs-number">6475 </span><span class="hljs-number">6365 </span><span class="hljs-number">7273 </span><span class="hljs-string">010c</span> <span class="hljs-number">7072 </span><span class="hljs-string">6f63</span>  <span class="hljs-string">.producers..proc</span>
<span class="hljs-attr">000019b:</span> <span class="hljs-number">6573 </span><span class="hljs-number">7365 </span><span class="hljs-string">642d</span> <span class="hljs-number">6279 </span><span class="hljs-number">0105 </span><span class="hljs-string">636c</span> <span class="hljs-string">616e</span> <span class="hljs-number">6756  </span><span class="hljs-string">essed-by..clangV</span>
<span class="hljs-attr">00001ab:</span> <span class="hljs-number">3131 </span><span class="hljs-number">2e30</span> <span class="hljs-number">2e30</span> <span class="hljs-number">2028 </span><span class="hljs-number">6874 </span><span class="hljs-number">7470 </span><span class="hljs-string">733a</span> <span class="hljs-string">2f2f</span>  <span class="hljs-number">11.0</span><span class="hljs-number">.0</span> <span class="hljs-string">(https://</span>
<span class="hljs-attr">00001bb:</span> <span class="hljs-number">6769 </span><span class="hljs-number">7468 </span><span class="hljs-number">7562 </span><span class="hljs-number">2e63</span> <span class="hljs-string">6f6d</span> <span class="hljs-string">2f6c</span> <span class="hljs-string">6c76</span> <span class="hljs-string">6d2f</span>  <span class="hljs-string">github.com/llvm/</span>
<span class="hljs-attr">00001cb:</span> <span class="hljs-string">6c6c</span> <span class="hljs-string">766d</span> <span class="hljs-string">2d70</span> <span class="hljs-string">726f</span> <span class="hljs-string">6a65</span> <span class="hljs-number">6374 </span><span class="hljs-number">2031 </span><span class="hljs-number">3736  </span><span class="hljs-string">llvm-project</span> <span class="hljs-number">176</span>
<span class="hljs-attr">00001db:</span> <span class="hljs-number">3234 </span><span class="hljs-number">3962 </span><span class="hljs-number">6436 </span><span class="hljs-number">3733 </span><span class="hljs-number">3261 </span><span class="hljs-number">3830 </span><span class="hljs-number">3434 </span><span class="hljs-number">6434  </span><span class="hljs-string">249bd6732a8044d4</span>
<span class="hljs-attr">00001eb:</span> <span class="hljs-number">3537 </span><span class="hljs-number">3039 </span><span class="hljs-number">3265 </span><span class="hljs-number">6439 </span><span class="hljs-number">3332 </span><span class="hljs-number">3736 </span><span class="hljs-number">3837 </span><span class="hljs-number">3234  </span><span class="hljs-string">57092ed932768724</span>
<span class="hljs-attr">00001fb:</span> <span class="hljs-number">6136 </span><span class="hljs-number">6630 </span><span class="hljs-number">3629                           </span><span class="hljs-string">a6f06)</span>
</code></pre><p>Sure enough, there are custom sections related to linking, relocation, and even a curious &quot;producers&quot; section (that apparently exists to <a href="https://github.com/WebAssembly/tool-conventions/blob/main/ProducersSection.md">allow analysis of toolchain usage in the wild</a>).</p>
<h1 id="webassembly-libraries">WebAssembly libraries</h1>
<p>For something as simple as my 20 line C library, I could probably just distribute the C header and the compiled WebAssembly object file (which is actually a WebAssembly module with custom sections) and be done. What if I have a larger library?</p>
<h2 id="dynamic-libraries">Dynamic libraries</h2>
<p>Once again, to my surprise, WebAssembly publishes <a href="https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md">conventions for dynamically loading libraries</a>, but the document notes there is no stable ABI. That&#39;s ok, I didn&#39;t really need dynamic libraries right now anyway.</p>
<h2 id="static-libraries">Static libraries</h2>
<p>Static libraries for native C code are often just archives (using the <a href="https://en.wikipedia.org/wiki/Ar_%28Unix%29"><code>ar</code></a> archiver tool), perhaps with some additional information to describe the library.</p>
<p>Can I just do the same thing for WebAssembly? It certainly appears so.</p>
<p>If I inspect the WASI SDK, in the WebAssembly sysroot, I actually see both bare objects and archives for the C standard library and friends:</p>
<pre><code class="language-sh">$ ls wasi-sdk/share/wasi-sysroot/lib/wasm32-wasi
crt1-command.o  libc++abi.a                         libdl.a       libutil.a
crt1.o          libc.imports                        libm.a        libwasi-emulated-mman.a
crt1-reactor.o  libc-printscan-long-double.a        libpthread.a  libwasi-emulated-signal.a
libc++.a        libc-printscan-no-floating-point.a  libresolv.a   libxnet.a
libc.a          libcrypt.a                          librt.a</code></pre>
<p>What&#39;s in one of these archives? <code>ar -t libc.a</code> shows a bunch of object files. If I extract an object named &quot;ccos.o&quot; with <code>ar -x libc.a ccos.o</code>, I can use <code>wasm-objdump</code> or <code>wasm2wat</code> to see that it&#39;s just a regular WebAssembly object file.</p>
<p>I&#39;m impressed that the people working on WebAssembly resisted the urge to create entirely new tools, and instead just decided to leverage existing UNIX tools that have been around for a long time.</p>
<h1 id="linking">Linking</h1>
<p>The <a href="https://lld.llvm.org/WebAssembly.html">documentation for wasm-ld</a> is brief, but it does have most of the information you need.</p>
<p>The main tricks are:</p>
<ul>
<li>Pass <code>--no-entry</code> on the command line to indicate there is no <code>_start</code> entry point</li>
<li>By default, only symbols marked with the <code>export-name</code> attribute are exported (see <code>WASM_EXPORT</code> in the C example earlier for a handy macro to add this)</li>
</ul>
<h1 id="summary">Summary</h1>
<p>It turns out that the toolchain for WebAssembly libraries in C is similar to what one would use for native compilation:</p>
<ul>
<li>Publish header files (.h) to define the library&#39;s interface</li>
<li>Compile source files (.c) to object files (.o) using <code>clang</code></li>
<li>If needed, consolidate multiple object files into an archive (.a) using <code>ar</code></li>
<li>Publish either a single object file or (more likely) an archive for users to consume</li>
<li>For an object file, users just add it to the list on their <code>wasm-ld</code> command line</li>
<li>For an archive, consumers add <code>-l&lt;name of archive without extension&gt;</code> to their <code>wasm-ld</code> command line</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/objects-libraries-and-linking</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/objects-libraries-and-linking</guid><pubDate>Wed, 06 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Passing strings to and from WebAssembly using C]]></title><description><![CDATA[<p>As a follow-up to a <a href="../trivial-example/">trivial WebAssembly example in C</a> and <a href="../c-standard-library-example/">an example of using the C standard library in WebAssembly</a>, I&#39;m now investigating passing strings back and forth between the JavaScript host and a WebAssembly module written in C (and compiled with Clang/LLVM).</p>
<p>Links to the code and a live demo are at <a href="#links">the end of the post</a>.</p>
<h1 id="passing-a-string-from-javascript-to-c">Passing a string from JavaScript to C</h1>
<p>Recall that WebAssembly <a href="https://webassembly.github.io/spec/core/syntax/types.html">doesn&#39;t have a string type</a>. How can a C function receive a string when compiled to WebAssembly?</p>
<h2 id="pass-in-by-directly-populating-linear-memory">Pass in by directly populating linear memory</h2>
<p>Also known as: failed attempt #1.</p>
<ol>
<li>Add a null character onto the end of the string</li>
<li>Use the browser&#39;s TextEncoder API to convert a string to a byte sequence</li>
<li>Write the buffer into linear memory</li>
<li>Pass the address of the null-terminated string to C code</li>
<li>C code can read the string as a null-terminated UTF-8 string</li>
</ol>
<p>Obviously, this limits strings to fit in linear memory (where I assume the maximum size is 2^32-1), and requiring a null terminator means embedded nulls aren&#39;t supported. I don&#39;t think these will be a problem for me personally.</p>
<p>I gave this approach a try, but there were several problems with it.</p>
<p>The <a href="https://lld.llvm.org/WebAssembly.html">LLVM WebAssembly documentation</a> hints at it, but inspecting the output of a trivial C program compiled to WebAssembly shows that LLVM&#39;s WebAssembly linker uses linear memory for both the stack and the heap. This makes sense, of course--memory has to come from somewhere. I couldn&#39;t find LLVM documentation to definitively confirm this, but <a href="https://surma.dev/things/c-to-webassembly/">I&#39;ve read that the WebAssembly stack grows downward and has a default size of only 64 KB</a> (customizable with the <code>-z stacksize=&lt;value&gt;</code> option). The heap follows the stack by default.</p>
<p>This means that you don&#39;t really have a place to stuff in your encoded string. I also didn&#39;t see a way to use a separate memory for passing in data to C functions.</p>
<p>The fundamental problem with this approach is that the C-based WebAssembly module needs complete control over its memory, and there doesn&#39;t appear to be a way to access a different memory from C code, as compiled with Clang and LLVM&#39;s WebAssembly linker. There are likely libraries (probably with hand-written WebAssembly) to enable this, but I&#39;d like a simple solution.</p>
<h2 id="pass-on-the-stack">Pass on the stack</h2>
<p>Also known as: very limited approach #2.</p>
<p>Probably not a good idea because you&#39;re limited based on the maximum stack size (mentioned above), but theoretically you could pass in a string on the stack by having your JavaScript code implement whatever calling convention is used by Clang/LLVM for WebAssembly (modifying the stack pointer as a <a href="https://github.com/WebAssembly/mutable-global">mutable global</a>). This seems tedious and not worth the effort unless you have strings that you know will be much smaller than the maximum stack size (or you tell LLVM&#39;s WebAssembly linker to grow the stack upwards (although then you&#39;re limiting your heap size, which is probably even more unexpected to most non-embedded C code that&#39;s laying around).</p>
<p>I won&#39;t dwell on this idea any more since I want to use the default memory layout.</p>
<h2 id="pass-in-via-the-heap">Pass in via the heap</h2>
<p>Also known as: successful attempt #3.</p>
<p>Here&#39;s a new idea: let the C code control its entire address space, but expose functions to let JavaScript allocate some memory.</p>
<ol>
<li>Expose <code>allocate</code> and <code>deallocate</code> functions to let JavaScript allocate and free memory in the heap</li>
<li>Add a null character onto the end of the string</li>
<li>Use the browser&#39;s TextEncoder API to convert a string to a byte sequence</li>
<li>Allocate a buffer (in C address space) for the string (using the exported function <code>allocate</code>)</li>
<li>Write the encoded string into the heap allocation</li>
<li>Call C code to read the string as a null-terminated UTF-8 string</li>
<li>Deallocate/free the string (using the exported function <code>deallocate</code>)</li>
</ol>
<p>This approach adds overhead in the form of allocating for every string passed in, but if the ratio of calls to time spent in each call is low enough, this could be tolerable (and you could always optimize the approach to reuse allocations when possible, if needed). Overall, this seems straight forward and robust, so I&#39;m going to try this out.</p>
<h3 id="c-implementation">C implementation</h3>
<p>As an example, I&#39;ve created a function that counts the number of occurrences of the (lower case) letter &quot;a&quot; in a string. Note that I have to export an allocator and a deallocator.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(allocate)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(size);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(deallocate)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* allocation)</span> {
    <span class="hljs-built_in">free</span>(allocation);
}

<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(countAs)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>)</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numberOfAs = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">string</span> != <span class="hljs-string">&#x27;\0&#x27;</span>) {
        <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">string</span> == <span class="hljs-string">&#x27;a&#x27;</span>) {
            ++numberOfAs;
        }
        <span class="hljs-built_in">string</span>++;
    }
    <span class="hljs-keyword">return</span> numberOfAs;
}</code></pre>
<h3 id="compiling">Compiling</h3>
<p>The build command is unchanged <a href="../c-standard-library-example/#compiling">from the last post</a>:</p>
<pre><code class="language-sh">wasi-sdk/bin/clang -Os --sysroot wasi-sdk/share/wasi-sysroot -nostartfiles -Wl,--no-entry string-example.c -o string-example.wasm</code></pre>
<h3 id="javascript-caller">JavaScript caller</h3>
<p>The JavaScript wrapper is more involved than I&#39;d like, but it does work:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> testString = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;How many letter a&#x27;s are there in this string? Three!&quot;</span>;

    <span class="hljs-comment">// Encode the string (with null terminator) to get the required size</span>
    <span class="hljs-keyword">const</span> nullTerminatedString = testString + <span class="hljs-string">&quot;\0&quot;</span>;
    <span class="hljs-keyword">const</span> textEncoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();
    <span class="hljs-keyword">const</span> encodedString = textEncoder.<span class="hljs-title function_">encode</span>(nullTerminatedString);

    <span class="hljs-comment">// Allocate space in linear memory for the encoded string</span>
    <span class="hljs-keyword">const</span> address = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">allocate</span>(encodedString.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// Copy the string into the buffer</span>
        <span class="hljs-keyword">const</span> destination = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>, address);
        textEncoder.<span class="hljs-title function_">encodeInto</span>(nullTerminatedString, destination);

        <span class="hljs-comment">// Call the function</span>
        <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">countAs</span>(address);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-comment">// Always free the allocation when done (or on error)</span>
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(address);
    }
})();</code></pre>
<h3 id="result">Result</h3>
<p>Behold the result:</p>
<pre><code class="language-sh">$ node main.js <span class="hljs-string">&quot;a string that has lots of the letter &#x27;a&#x27; in it&quot;</span> 
4</code></pre>
<p>Looks good!</p>
<h3 id="improving-memory-management">Improving memory management</h3>
<p>Having to manually manage memory in JavaScript is error-prone, so I&#39;m going to borrow the idea of a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement"><code>using</code> statement from C#</a>:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> textEncoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();

<span class="hljs-comment">// Pass in a factory for an object with a &quot;dispose&quot; property and this will</span>
<span class="hljs-comment">// ensure &quot;dispose&quot; is called on the object after the provided lambda returns</span>
<span class="hljs-comment">// or throws</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">use</span> = (<span class="hljs-params">create, run</span>) =&gt; {
    <span class="hljs-keyword">const</span> o = <span class="hljs-title function_">create</span>();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">run</span>(o);
    } <span class="hljs-keyword">finally</span> {
        o.<span class="hljs-title function_">dispose</span>();
    }
};

<span class="hljs-comment">// Manage the lifetime of an allocation</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInstanceAllocation</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, create, run</span>) =&gt; {
    <span class="hljs-title function_">use</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Create the disposable object first</span>
        <span class="hljs-keyword">const</span> objectWithDispose = {
            <span class="hljs-attr">address</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">dispose</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span>); },
        };

        <span class="hljs-comment">// Then allocate</span>
        objectWithDispose.<span class="hljs-property">address</span> = <span class="hljs-title function_">create</span>();
        <span class="hljs-keyword">return</span> objectWithDispose;
    }, run);
};

<span class="hljs-comment">// Manage the lifetime of a *new* allocation (with the given size)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useNewInstanceAllocation</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, size, run</span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">useInstanceAllocation</span>(<span class="hljs-variable language_">module</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">allocate</span>(size), run);
};

<span class="hljs-comment">// Encode a *new* string and manage its lifetime</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useNewInstanceString</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, str, run</span>) =&gt; {
    <span class="hljs-comment">// Encode the string (with null terminator) to get the required size</span>
    <span class="hljs-keyword">const</span> nullTerminatedString = str + <span class="hljs-string">&quot;\0&quot;</span>;
    <span class="hljs-keyword">const</span> encodedString = textEncoder.<span class="hljs-title function_">encode</span>(nullTerminatedString);

    <span class="hljs-comment">// Allocate space in linear memory for the encoded string</span>
    <span class="hljs-title function_">useNewInstanceAllocation</span>(<span class="hljs-variable language_">module</span>, encodedString.<span class="hljs-property">length</span>, <span class="hljs-function">(<span class="hljs-params">{ address }</span>) =&gt;</span> {
        <span class="hljs-comment">// Copy the string into the buffer</span>
        <span class="hljs-keyword">const</span> destination = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>, address);
        textEncoder.<span class="hljs-title function_">encodeInto</span>(nullTerminatedString, destination);

        <span class="hljs-title function_">run</span>(address);
    });
};</code></pre>
<p>Note: it would probably be helpful to extend these helpers to support multiple strings/allocations, but I&#39;m not trying to completely reinvent wrapping/binding libraries like Emscripten right now.</p>
<p>Now, the final string passing code is simple:</p>
<pre><code class="language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> testString = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;How many letter a&#x27;s are there in this string? Three!&quot;</span>;
    <span class="hljs-title function_">useNewInstanceString</span>(<span class="hljs-variable language_">module</span>, testString, <span class="hljs-function">(<span class="hljs-params">stringAddress</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">count_as</span>(stringAddress);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    });
})();</code></pre>
<h1 id="returning-a-string-from-c-to-javascript">Returning a string from C to JavaScript</h1>
<p>Here was my initial thinking for returning a dynamic string from C to JavaScript (recorded before I completed the example above):</p>
<ol>
<li>(Assuming a null-terminated UTF-8 string)</li>
<li>Write the string directly into linear memory</li>
<li>Return the address as an (&quot;unsigned&quot;) integer (&quot;unsigned&quot; in quotes because WebAssembly doesn&#39;t have a separate unsigned int type)</li>
<li>JavaScript can decode the string using <code>TextDecoder.decode()</code></li>
<li>(Also make sure to export a function to free generated strings)</li>
</ol>
<p>Given that I&#39;m already exposing allocations to JavaScript, I thought this would work, but there&#39;s one problem: <code>TextDecoder.decode()</code> doesn&#39;t have built-in support for null-terminated strings (nor should it, in my opinion). This means we need to return both the string address <em>and</em> the string&#39;s length (or, worse: export another function to measure the returned string).</p>
<p>Note that I&#39;m assuming returned strings will be dynamically allocated, because constant strings should really just be provided directly using JavaScript. If the string <em>must</em> come from C code, all you&#39;d need to do is skip the allocation management steps (and hope that the JavaScript code doesn&#39;t decide to mutate the string!).</p>
<h2 id="c-implementation-1">C implementation</h2>
<p>If you&#39;re familiar with C and building on many platforms, brace yourself.</p>
<p>Given that WebAssembly is a known, uniform target, I&#39;m going to simply return a variable size struct. I&#39;m not worrying about <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> in the C code because <a href="https://github.com/WebAssembly/design/blob/main/Portability.md#assumptions-for-efficient-execution">WebAssembly is always little endian</a>. Please never do this outside of a WebAssembly context like this.</p>
<p>Here&#39;s the struct and some simple code that creates a string with the letter &quot;b&quot; repeated a caller-supplied number of times:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length;
    <span class="hljs-type">char</span> buffer[];
} wasm_string;

wasm_string* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(write_bs)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count)</span> {
    <span class="hljs-comment">// Allocate space for the string length and content (note: no null terminator)</span>
    wasm_string* str = (wasm_string*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) + count);
    str-&gt;length = count;

    <span class="hljs-comment">// Fill in the string</span>
    <span class="hljs-type">char</span>* c = &amp;str-&gt;buffer[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
        *c = <span class="hljs-string">&#x27;b&#x27;</span>;
        ++c;
    }
    <span class="hljs-keyword">return</span> str;
}</code></pre>
<p>Just what C needs! Another string type.</p>
<h2 id="javascript-implementation">JavaScript implementation</h2>
<p>Here&#39;s the corresponding JavaScript on the other side:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;

(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;3&quot;</span>);
    <span class="hljs-keyword">const</span> textDecoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();

    <span class="hljs-comment">// Call the &quot;create&quot; function and get back the address of a struct: [size (32-bit unsigned int), byte1, byte2, ...]</span>
    <span class="hljs-keyword">const</span> address = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">write_bs</span>(count);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>;
        <span class="hljs-keyword">const</span> encodedStringLength = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer, address, <span class="hljs-number">4</span>)).<span class="hljs-title function_">getUint32</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// WebAssembly is little endian</span>
        <span class="hljs-keyword">const</span> encodedStringBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address + <span class="hljs-number">4</span>, encodedStringLength); <span class="hljs-comment">// Skip the 4 byte size</span>
        <span class="hljs-keyword">const</span> str = textDecoder.<span class="hljs-title function_">decode</span>(encodedStringBuffer);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(address);
    }
})();</code></pre>
<p>Output:</p>
<pre><code class="language-sh">$ node return-string.js 5
bbbbb</code></pre>
<p>Looks good!</p>
<h2 id="memory-management-helpers">Memory management helpers</h2>
<p>Similar to above, I&#39;m going to build on the memory management helpers written previously:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Decode a string and manage its lifetime</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useInstanceString</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, create, run</span>) =&gt; {
    <span class="hljs-comment">// Call the &quot;create&quot; function and get the struct&#x27;s address: [size (32-bit unsigned int), byte1, byte2, ...]</span>
    <span class="hljs-title function_">useInstanceAllocation</span>(<span class="hljs-variable language_">module</span>, create, <span class="hljs-function">(<span class="hljs-params">{ address }</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>;
        <span class="hljs-keyword">const</span> encodedStringLength = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(buffer, address, <span class="hljs-number">4</span>)).<span class="hljs-title function_">getUint32</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// WebAssembly is little endian</span>
        <span class="hljs-keyword">const</span> encodedStringBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address + <span class="hljs-number">4</span>, encodedStringLength); <span class="hljs-comment">// Skip the 4 byte size</span>
        <span class="hljs-keyword">const</span> str = textDecoder.<span class="hljs-title function_">decode</span>(encodedStringBuffer);
        <span class="hljs-title function_">run</span>(str);
    })
};</code></pre>
<p>This simplifies the calling code significantly:</p>
<pre><code class="language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;3&quot;</span>);
    <span class="hljs-title function_">useInstanceString</span>(<span class="hljs-variable language_">module</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">write_bs</span>(count), <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
    })
})();</code></pre>
<h1 id="strings-✔">Strings: ✔</h1>
<p>Perhaps that wasn&#39;t the most enjoyable experiment, but it does give one a new appreciation for binding generators that do all this work for you.</p>
<p>Armed with a way to pass strings between JavaScript and C, I&#39;m now ready to leverage old C code (that I don&#39;t want to rewrite) by recompiling for WebAssembly and adding appropriate JavaScript glue. Theoretically the final WebAssembly module artifact will be useful for a long time (&quot;compile once, run forever&quot;?). I have one project in mind, but I&#39;m not going to discuss it or commit to anything just yet.</p>
<p>Have fun manually managing memory with JavaScript!</p>
<h1 id="links">Links:</h1>
<ul>
<li><a href="https://github.com/jaredkrinke/webassembly-c-string-example">Repository with all the example code</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-c-string-example/">Live demo</a></li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/passing-strings-to-c</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/passing-strings-to-c</guid><pubDate>Tue, 05 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Syntax highlighting for a static site built with Metalsmith]]></title><description><![CDATA[<p>As <a href="../metalsmith/">described previously</a>, I&#39;m using <a href="https://metalsmith.io/">Metalsmith</a> to build my static site because I like its modular, easy to extend design (even though it required more effort to setup initially).</p>
<p>Here&#39;s how I integrated <a href="https://highlightjs.org/">highlight.js</a> syntax highlighting into my static builds.</p>
<h1 id="marked">Marked</h1>
<p>Metalsmith&#39;s official Markdown plug, <a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a> uses <a href="https://marked.js.org/">Marked</a> for converting Markdown into HTML. Note that the plugin uses a fairly old version of Marked: 0.7.0. Fortunately, Marked has <a href="https://marked.js.org/using_advanced#highlight">convenient support for integrating syntax highlighting</a>.</p>
<h1 id="highlightjs">highlight.js</h1>
<p>Since I&#39;m working within the Node/NPM ecosystem, I decided to try <a href="https://highlightjs.org/">highlight.js</a>, because it&#39;s conveniently implemented in JavaScript (no manual compilation required). I suspect a native highlighting library would be faster, but I&#39;d rather optimize later, if needed, than waste time upfront.</p>
<h1 id="build-script-integration">Build script integration</h1>
<p>First step (after installing highlight.js via NPM: <code>npm install --save highlight.js</code>) is to use the documentation above to integrate highlight.js into my build script. This turned out to be fairly easy:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> highlight <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;highlight.js&quot;</span>;
...
<span class="hljs-comment">// Configure syntax highlighting aliases</span>
highlight.<span class="hljs-title function_">registerAliases</span>(<span class="hljs-string">&quot;wasm&quot;</span>, { <span class="hljs-attr">languageName</span>: <span class="hljs-string">&quot;lisp&quot;</span> });
...
<span class="hljs-title class_">Metalsmith</span>(__dirname)
...
    .<span class="hljs-title function_">use</span>(<span class="hljs-title function_">markdown</span>({
        <span class="hljs-attr">highlight</span>: <span class="hljs-function">(<span class="hljs-params">code, language</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (language) {
                <span class="hljs-keyword">return</span> highlight.<span class="hljs-title function_">highlight</span>(code, { language }).<span class="hljs-property">value</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> highlight.<span class="hljs-title function_">highlightAuto</span>(code).<span class="hljs-property">value</span>;
            }
        },
    }))
...</code></pre>
<p>Notes:</p>
<ul>
<li>I&#39;m using <code>import</code> instead of <code>require</code> to experiment with ES modules (<a href="../../javascript/using-commonjs-modules-from-es-modules/">Node supports loading CommonJS modules with <code>import</code></a>)</li>
<li>highlight.js <a href="https://highlightjs.org/static/demo/">supports a lot of languages</a>, but not WebAssembly, so I set up an alias that let&#39;s me mark code blocks as &quot;wasm&quot; and they&#39;ll be highlighted using Lisp s-expression syntax</li>
<li>highlight.js can auto-detect languages, so I use <code>highlightAuto</code> in cases where no programming language is explicitly specified</li>
</ul>
<p>So far, so good.</p>
<h1 id="theming">Theming</h1>
<p>Now, on to the annoying part: theming!</p>
<p>I kind of expected this, but <a href="https://highlightjs.readthedocs.io/en/latest/theme-guide.html#">creating a theme</a> (mostly from scratch) for highlight.js is fairly tedious. The <a href="https://highlightjs.readthedocs.io/en/latest/css-classes-reference.html">list of &quot;scopes&quot;</a> (i.e. classes of tokens) is long, and some are even nested. For example, the name of a function gets the following CSS classes applied: &quot;hljs-title function_&quot;.</p>
<p>To tweak a theme, the best approach I can recommend here is:</p>
<ol>
<li>Run highlight.js on some code</li>
<li>Inspect the output HTML (specifically the CSS classes)</li>
<li>Add/update your CSS rules</li>
<li>Repeat</li>
</ol>
<p>I had hoped that I could just take an existing theme and modify it slightly, but I couldn&#39;t find a theme that didn&#39;t group scopes in unappealing ways (e.g. grouping macros/templates with literals).</p>
<h1 id="my-final-css">My &quot;final&quot; CSS</h1>
<p>After a lot of trial and error, below is the CSS I came up with, using colors that are mostly already present on my site. I grouped the rules by color.</p>
<p>I&#39;m sure this theme doesn&#39;t cover all languages well, so I&#39;ll likely need to tweak it a few times in the future, but it seems adequate for all the code I&#39;ve thrown at it thus far.</p>
<pre><code class="language-css"><span class="hljs-comment">/* Syntax highlighting */</span>
<span class="hljs-selector-class">.hljs-comment</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#5a8c3f</span>; }

<span class="hljs-selector-class">.hljs-tag</span>,
<span class="hljs-selector-class">.hljs-punctuation</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>; }

<span class="hljs-selector-class">.hljs-literal</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#66c9fe</span>; }

<span class="hljs-selector-class">.hljs-title</span><span class="hljs-selector-class">.class_</span>,
<span class="hljs-selector-class">.hljs-tag</span> <span class="hljs-selector-class">.hljs-name</span>,
<span class="hljs-selector-class">.hljs-tag</span> <span class="hljs-selector-class">.hljs-attr</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#7bbf56</span>; }

<span class="hljs-selector-class">.hljs-attr</span>,
<span class="hljs-selector-class">.hljs-symbol</span>,
<span class="hljs-selector-class">.hljs-variable</span>,
<span class="hljs-selector-class">.hljs-template-variable</span>,
<span class="hljs-selector-class">.hljs-link</span>,
<span class="hljs-selector-class">.hljs-selector-attr</span>,
<span class="hljs-selector-class">.hljs-selector-pseudo</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#59c5ff</span>; }

<span class="hljs-selector-class">.hljs-keyword</span>,
<span class="hljs-selector-class">.hljs-attribute</span>,
<span class="hljs-selector-class">.hljs-selector-tag</span>,
<span class="hljs-selector-class">.hljs-meta</span> <span class="hljs-selector-class">.hljs-keyword</span>,
<span class="hljs-selector-class">.hljs-doctag</span>,
<span class="hljs-selector-class">.hljs-name</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#51a1cc</span>; }

<span class="hljs-selector-class">.hljs-type</span>,
<span class="hljs-selector-class">.hljs-string</span>,
<span class="hljs-selector-class">.hljs-number</span>,
<span class="hljs-selector-class">.hljs-quote</span>,
<span class="hljs-selector-class">.hljs-template-tag</span>,
<span class="hljs-selector-class">.hljs-deletion</span>,
<span class="hljs-selector-class">.hljs-title</span>,
<span class="hljs-selector-class">.hljs-section</span>,
<span class="hljs-selector-class">.hljs-meta</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#d97c57</span>; }

<span class="hljs-selector-class">.hljs-regexp</span>,
<span class="hljs-selector-class">.hljs-meta</span> <span class="hljs-selector-class">.hljs-string</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#b25947</span>; }

<span class="hljs-selector-class">.hljs-title</span><span class="hljs-selector-class">.function_</span>,
<span class="hljs-selector-class">.hljs-built_in</span>,
<span class="hljs-selector-class">.hljs-bullet</span>,
<span class="hljs-selector-class">.hljs-code</span>,
<span class="hljs-selector-class">.hljs-addition</span>,
<span class="hljs-selector-class">.hljs-selector-id</span>,
<span class="hljs-selector-class">.hljs-selector-class</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#e6b95c</span>; }</code></pre>
<h1 id="performance">Performance</h1>
<p>On my code-heavy, but tiny, site, I measured the following build times with and without syntax highlighting:</p>
<table>
<thead>
<tr>
<th align="left">Scenario</th>
<th align="right">Build time (s)</th>
<th align="right">Avg. time per page (ms)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Without highlighting</td>
<td align="right">1.4</td>
<td align="right">67</td>
</tr>
<tr>
<td align="left">With highlighting</td>
<td align="right">2.2</td>
<td align="right">105</td>
</tr>
</tbody></table>
<p>For me, on this machine, the overhead of syntax highlighting is roughly 40ms/page. This is certainly tolerable for my small site. I&#39;ll revisit the decision to use a JavaScript-based highlighter in the future, if needed. But for now, this is sufficient.</p>
<h1 id="the-end">The end</h1>
<p>Despite griping about theming, I&#39;m impressed with how smoothly everything integrated. Adding working syntax highlighting to a static site in a single sitting shows how productive modern software stacks can be.</p>
<p>I&#39;ll end the post with some examples of syntax highlighting in a few languages I&#39;ve already used on this site.</p>
<h2 id="syntax-highlighting-examples">Syntax highlighting examples</h2>
<h3 id="javascript">JavaScript</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));
})();</code></pre>
<h3 id="c">C</h3>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(add)</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<h3 id="webassembly">WebAssembly</h3>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">))</span></code></pre>
<h3 id="html">HTML</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of 2 + 2 is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith-syntax-highlighting</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith-syntax-highlighting</guid><pubDate>Fri, 01 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Can you use CommonJS modules from within an ES module?]]></title><description><![CDATA[<h1 id="question">Question</h1>
<p>Is it possible to import a CommonJS module from within an ES module (using <code>import</code> syntax)?</p>
<p>I thought a quick web search would answer this question, but instead most of the resources I found were about trying to <code>require()</code> ES modules (which you definitely can&#39;t do--use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports">dynamic import</a> instead).</p>
<h1 id="background">Background</h1>
<p>JavaScript didn&#39;t originally have a module system, so various groups have created their own systems, e.g. <a href="http://www.commonjs.org/">CommonJS</a>, <a href="https://github.com/amdjs/amdjs-api">Asynchronous Module Definition (AMD)</a>, and the ironically named <a href="https://github.com/umdjs/umd">Universal Module Definition (UMD)</a>.</p>
<p>Predictably, there&#39;s now an official <a href="https://tc39.es/ecma262/#sec-modules">ECMAScript Modules</a> format that <del>everyone uses</del> <del>everyone should use</del> some people have started using (<del>because it&#39;s incompatible and they have no choice</del> because it&#39;s part of the official JavaScript/ECMAScript specification). And I won&#39;t even dig into the ES module file extension dumpster fire.</p>
<p>Anyway, back to the question: can I import a CommonJS module into my ES module?</p>
<h1 id="lets-just-try-it">Let&#39;s just try it...</h1>
<p>Here&#39;s a CommonJS module:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">test</span> = <span class="hljs-string">&quot;works!&quot;</span>;</code></pre>
<h2 id="proof-that-it-works-from-commonjs-in-node-✔">Proof that it works from CommonJS (in Node) ✔</h2>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { test } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./test.js&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test);</code></pre>
<p>Output: <code>works!</code></p>
<h2 id="how-about-from-an-es-module-in-node-✔">How about from an ES module in Node? ✔</h2>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test);</code></pre>
<p>Output: <code>works!</code></p>
<h2 id="how-about-from-an-es-module-in-a-web-page-✖">How about from an ES module in a web page? ✖</h2>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Output: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
            <span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;

            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = test;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Doesn&#39;t work (error: &quot;The requested module &#39;./test.js&#39; does not provide an export named &#39;test&#39;&quot;).</p>
<h1 id="final-answer">Final answer</h1>
<p>You can use <code>import</code> to include a CommonJS module <em>when running in Node</em>, but <em>not</em> when running in a web page.</p>
]]></description><link>https://log.schemescape.com/posts/javascript/using-commonjs-modules-from-es-modules</link><guid isPermaLink="true">https://log.schemescape.com/posts/javascript/using-commonjs-modules-from-es-modules</guid><pubDate>Wed, 29 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly and the C standard library]]></title><description><![CDATA[<p>In the <a href="../trivial-example/">last post</a>, I compiled a trivial C function to WebAssembly. This was a good learning exercise, but I didn&#39;t use the C standard library, so compiling the code was trivial. Let&#39;s look into how to use the C standard library when compiling C to WebAssembly with Clang/LLVM. All the code is in this repository: <a href="https://github.com/jaredkrinke/webassembly-libc-example">webassembly-libc-example</a>.</p>
<h1 id="is-this-even-a-good-idea">Is this even a good idea?</h1>
<p>WebAssembly is simple, which is nice for getting started. It&#39;s also extremely limited (at least, in the browser). In order to compile typical C code to WebAssembly, you need a C standard library.</p>
<p>Obviously, the browser doesn&#39;t supply a C run time to WebAssembly modules (any language could be compiled to WebAssembly), so that means that the module itself has to include all the functionality it uses from the C library within itself (or get it from another module). In other words, it&#39;s statically linked.</p>
<p>How much overhead is including the C library in every module going to add? That&#39;s a good question, that I&#39;m hoping to answer eventually.</p>
<h1 id="which-c-library-to-use">Which C library to use?</h1>
<p>Here are a few promising leads on a WebAssembly-friendly C library (either already compiled to WebAssembly or simple enough that there&#39;s hope I could compile to WebAssembly myself):</p>
<ul>
<li><a href="https://github.com/emscripten-core/emscripten">Emscripten</a>: Modified version of <a href="https://musl.libc.org/">musl libc</a> that can run in a browser</li>
<li><a href="https://github.com/WebAssembly/wasi-libc">WASI libc</a>: Also built on musl (I think), but designed to run on top of <a href="https://wasi.dev/">WASI</a>--I didn&#39;t think this would run in the browser, but <a href="https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/">this blog post indicates otherwise</a></li>
<li><a href="https://github.com/embeddedartistry/libc">Embedded Artistry libc</a>: Designed for embedded applications; I&#39;m hoping this would be easy to bring up on a new platform like WebAssembly</li>
<li><strong>Build your own!</strong> If you only need a handful of functions, maybe you can implement them yourself (here&#39;s <a href="https://dassur.ma/things/c-to-webassembly/">one great example with a trivial allocator</a>)</li>
</ul>
<p>I&#39;m going to continue avoiding Emscripten because a) it wants me to install Python first and b) I&#39;d like to keep things as simple as possible. I didn&#39;t think WASI&#39;s C library would work for me in the browser, but I&#39;m going to try it anyway.</p>
<h1 id="setup-for-wasi-libc">Setup for WASI libc</h1>
<p>In order to compile against a C library, you need header files and compiled objects (in an archive) or a shared library (a concept that I don&#39;t think exists for WebAssembly since they use modules for that purpose). Note that we&#39;re basically cross-compiling for a different architecture.</p>
<p>Fortunately, <a href="https://github.com/WebAssembly/wasi-sdk">WASI provides an SDK for exactly this purpose</a>. I downloaded the latest release (~140 MB) and took a peek at the contents:</p>
<ul>
<li><code>bin/</code>: Oh, look, Clang and LLVM -- I guess I should have just started here!</li>
<li><code>lib/clang/11.0.0/lib/wasi/libclang_rt.builtins-wasm32.a</code>: This archive contains WebAssembly implementations of so-called &quot;builtins&quot; that <a href="https://releases.llvm.org/11.0.0/tools/clang/docs/Toolchain.html">Clang implicitly requires</a></li>
<li><code>share/wasi-sysroot</code>: System root for the cross compiler, containing all the headers and libraries (all raw objects or archives)</li>
</ul>
<p>Note that the version of LLVM that I installed in my last post didn&#39;t come from the WASI SDK and it didn&#39;t contain the &quot;builtins&quot; archive noted above. In order to use that installation of Clang/LLVM, I needed to copy <code>libclang_rt.builtins-wasm32.a</code> into my installation (fortunately the eventual error message you see provides the exact destination path).</p>
<h1 id="a-slightly-less-trivial-example">A slightly less trivial example</h1>
<h2 id="source-code">Source code</h2>
<p>Here&#39;s the C source for my test module that uses the WASI C library (<code>sine.c</code>):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">double</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(sine)</span><span class="hljs-params">(<span class="hljs-type">double</span> theta)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sin</span>(theta);
}</code></pre>
<p>All I&#39;m doing is exposing <code>sin</code> from <code>math.h</code> as an export named <code>sine</code>.</p>
<h2 id="compiling">Compiling</h2>
<p>The build command is a bit more complicated than <a href="../trivial-example/#compiling-the-code">last time</a>:</p>
<ul>
<li><code>-nostdlib</code> is gone since we&#39;re using the C standard library this time</li>
<li><code>-nostartfiles</code> is present because we don&#39;t need to link in any bootstrapping entry point to call <code>main()</code> (we don&#39;t have a <code>main()</code>)</li>
<li><code>-target wasm32-wasi</code> could be updated to specify the &quot;operating system&quot; (used loosely here) as WASI</li>
<li><code>--sysroot wasi-sdk-12.0/share/wasi-sysroot</code> to point to the cross-compiler system root that came from the WASI SDK</li>
</ul>
<p>Note that in this example, I extracted the WASI SDK into a subfolder of my project (the <a href="https://github.com/WebAssembly/wasi-sdk">SDK&#39;s README has an example as well</a>).</p>
<p>Here&#39;s the build command (note: I omitted the <code>-target</code> option because I&#39;m using the WASI SDK&#39;s Clang, which defaults to targeting <code>wasm32-wasi</code>):</p>
<pre><code class="language-sh">wasi-sdk-12.0\bin\clang.exe -Os --sysroot wasi-sdk-12.0/share/wasi-sysroot -nostartfiles -Wl,--no-entry sine.c -o sine.wasm</code></pre>
<h2 id="calling-from-node">Calling from Node</h2>
<p>Almost identical to last time:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./sine.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> sine = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sine</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sine</span>(<span class="hljs-number">1.57</span>));
})();</code></pre>
<p>Output: 0.9999996829318346 (looks reasonable, since 1.57 is approximately pi/2 and so sine of that angle should be roughly 1).</p>
<h2 id="calling-from-a-browser">Calling from a browser</h2>
<p>Again, almost identical:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of sin(1.57) is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./sine.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> sine = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sine</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">sine</span>(<span class="hljs-number">1.57</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Result:</p>
<pre><code><span class="hljs-attribute">The</span> value of sin(<span class="hljs-number">1</span>.<span class="hljs-number">57</span>) is <span class="hljs-number">0</span>.<span class="hljs-number">9999996829318346</span></code></pre><p>Looks like the WASI libc works in the browser, at least in a case like this where no system calls are needed.</p>
<h1 id="overhead">Overhead</h1>
<p>Earlier, I was wondering how much overhead there is in linking against a C standard library for WebAssembly. My understanding is that linking for C is done per-function, so you&#39;re only pulling in what you need. Here are some measurements I took (and yes, I linked in <code>malloc</code> but not <code>free</code>):</p>
<table>
<thead>
<tr>
<th align="left">Dependencies</th>
<th align="right">Module size (in bytes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(none)</td>
<td align="right">207</td>
</tr>
<tr>
<td align="left"><code>sin</code></td>
<td align="right">7851</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>cos</code></td>
<td align="right">8116</td>
</tr>
<tr>
<td align="left"><code>malloc</code></td>
<td align="right">7350</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>malloc</code></td>
<td align="right">14995</td>
</tr>
</tbody></table>
<p>Not great, but also not terrible. My hope is that WebAssembly written in C <em>and using the C standard library</em> is uncommon, and generally only used for hosting programs with large C code bases that would be prohibitively time-consuming to rewrite.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, that could have gone a lot worse.</p>
<p>I&#39;m still not thrilled with the overhead of statically linking <em>everything</em>, and the thought of each module essentially having its own allocator is a bit alarming, but I need to remind myself that the alternatives are often worse. For example, if rewriting a C program in JavaScript isn&#39;t in the cards, the previous best options were either transpiling the C code to something like asm.js or, even worse, emulating an x86 CPU in the browser (using JavaScript) and running existing binaries.</p>
<p>I will state, however, that I&#39;m not quite as thrilled with the idea of compiling C programs to WebAssembly to support &quot;run anywhere&quot; scenarios as I was before I started this exercise.</p>
<h1 id="links">Links</h1>
<ul>
<li>Code: <a href="https://github.com/jaredkrinke/webassembly-libc-example">webassembly-libc-example</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-libc-example/">Live demo</a></li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/c-standard-library-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/c-standard-library-example</guid><pubDate>Tue, 28 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[A trivial WebAssembly example]]></title><description><![CDATA[<p>In the last post, I provided an <a href="../overview/">overview of WebAssembly</a>. In this post, I&#39;m going to build and run a complete (but trivial) WebAssembly module in C using <a href="https://llvm.org/">LLVM</a> and <a href="https://clang.llvm.org/">Clang</a>.</p>
<p>All of the code is here: <a href="https://github.com/jaredkrinke/webassembly-trivial-example">webassembly-trivial-example</a>.</p>
<h1 id="aside">Aside</h1>
<p>It looks like someone else was frustrated with Emscripten in the past, so they wrote a post about <a href="http://schellcode.github.io/webassembly-without-emscripten">WebAssembly without Emscripten</a>. Their guide was helpful, but I&#39;m not sure if it&#39;s up to date. I also found their Makefiles to be excessively complex.</p>
<h1 id="setup">Setup</h1>
<p>First, download and install LLVM (I used <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">LLVM 12.0.1</a>) from the LLVM GitHub releases page (note: 180 MB download that expands to <em>1.8 GB</em> installed). The programs I&#39;m actually planning to use are <code>clang</code> and <code>wasm-ld</code>.</p>
<p>I also wanted to inspect the output WebAssembly, so I needed the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>, which was a much more reasonable ~2 MB download (note: the Windows version is a gzipped tarball instead of a zip file). I&#39;m going to use <code>wasm2wat</code> for disassembly.</p>
<h2 id="some-notes-on-c">Some notes on C</h2>
<p>C compilation is usually done as follows:</p>
<ol>
<li>Run the preprocessor (<code>cpp</code>) to expand macros and includes (often on many source files)</li>
<li>Compile the preprocessed code into object files</li>
<li>Link everything into a final binary</li>
</ol>
<p>A decent overview of the most common command line arguments for a <em>different</em> compiler is <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/">here</a>. Many of the options are identical for most C compilers.</p>
<h1 id="implementing-a-trivial-function">Implementing a trivial function</h1>
<p>I&#39;m going to start with a very simple example (just to reduce the number of things that could go wrong).</p>
<h2 id="source-code">Source code</h2>
<p>File name: &quot;add.c&quot;:</p>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<h2 id="compiling-the-code">Compiling the code</h2>
<p>First, I&#39;m just going to compile (but not link) the code, to see what happens.</p>
<pre><code class="language-sh">clang -target wasm32 -Os -c add.c</code></pre>
<ul>
<li><code>-target wasm32</code> tells Clang to tell LLVM to produce 32-bit WebAssembly output (note: as of today, <a href="https://github.com/WebAssembly/proposals">64-bit memory support is in progress</a>)</li>
<li><code>-Os</code> tells Clang to optimize for size (I did this in hopes of getting simpler, more readable code)</li>
<li><code>-c</code> tells Clang to compile, but not link</li>
<li><code>add.c</code> is the source file</li>
</ul>
<p>Since I&#39;m compiling and not linking, this command generates an object file named &quot;add.o&quot;.</p>
<h2 id="disassembling-the-object-file">Disassembling the object file</h2>
<p>Run the disassembler:</p>
<pre><code class="language-sh">wasm2wat add.o</code></pre>
<p>And it produces the following surprisingly readable output:</p>
<pre><code><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">))</span></code></pre><p>MDN has a great <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">explanation of the Web Assembly text format</a> (&quot;.wat&quot; files). The syntax is based on <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> (similar to <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>). Note that inline comments are delimited by semicolons (e.g. <code>; comment goes here ;</code>), as noted in <a href="https://github.com/WebAssembly/spec/blob/master/interpreter/README.md#s-expression-syntax">this more detailed look at Web Assembly text format syntax.</a>.</p>
<p>Breaking down the first two lines:</p>
<ul>
<li><code>module</code> is the root and encloses the entire module</li>
<li><code>type</code> denotes a type that can be later referenced<ul>
<li><code>(;0;)</code> is an empty list (<code>;0;</code> is just a comment) for the name of the type</li>
<li><code>func</code> denotes a function type<ul>
<li><code>param</code> denotes a list of function arguments</li>
<li><code>i32</code> is a <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> 32-bit integer<ul>
<li>Note: there is no corresponding &quot;unsigned&quot; type--instructions themselves indicate the expected sign of operands, as needed (e.g. for division)</li>
</ul>
</li>
<li><code>result</code> is a list of result values (<a href="https://github.com/WebAssembly/multi-value">support for multiple result values</a> was added in April of 2020)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So far, we have a module and an unnamed type (which can be referenced by index 0) for a function taking two 32-bit integers and returning one 32-bit integer. Moving on:</p>
<ul>
<li><code>import</code> is used to indicate data that is passed into the module from the host<ul>
<li><code>&quot;env&quot; &quot;__linear_memory&quot;</code> indicates the import is from the &quot;env&quot; module and the item being imported is &quot;__linear_memory&quot; (these are arbitrary strings that must match the instantiation code in the host)</li>
<li><code>(memory (;0;) 0)</code> specifies an unnamed memory, which must have an initial size of at least zero 64 KB pages<ul>
<li>I believe this could have been omitted from the output in this trivial example</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The host code would need to pass in a (zero-sized) memory buffer named <code>env.__linear_memory</code>. On to the actual code:</p>
<ul>
<li><code>func</code> defines a function<ul>
<li><code>$add</code> is the name of the function (names are prefixed with <code>$</code>)</li>
<li><code>(type 0)</code> refers to the type zero, defined previously: (i32, i32) =&gt; (i32)</li>
<li>The function type/signature/prototype is then specified -- I&#39;m not sure why the type needs to be duplicated here</li>
<li>The function body follows as a series of instructions (here&#39;s the <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">full list of WebAssembly instructions</a>)</li>
</ul>
</li>
</ul>
<p>Looking at the function body, note that local values are referenced by a zero-based index that starts with the function arguments and then continues on to any local variables:</p>
<ul>
<li><code>local.get 1</code> gets the second argument and pushes it onto the stack</li>
<li><code>local.get 0</code> gets the first argument and pushes it onto the stack</li>
<li><code>i32.add</code> pops the two arguments off and pushes their sum onto the stack<ul>
<li>The return value is just the last argument left on the stack, so no additional instructions are required</li>
</ul>
</li>
</ul>
<p>It looks like the C code compiled correctly and the output WAT seems reasonable. So far, so good.</p>
<h2 id="linking">Linking</h2>
<p>Note that my original Clang command specified <code>-c</code>, so it only compiled the code and never ran the linker. Let&#39;s go all the way this time:</p>
<pre><code class="language-sh">clang -target wasm32 -Os -nostdlib -Wl,--no-entry add.c -o add.wasm</code></pre>
<p>I removed <code>-c</code> and added some new arguments:</p>
<ul>
<li><code>-nostdlib</code> indicates that the C standard library should not be used (it&#39;s not needed in this case, and I don&#39;t have it available anyway)</li>
<li><code>-Wl,--no-entry</code> tells the linker that there is no entry point (i.e. no <code>main()</code> or <code>_start()</code> function)</li>
<li><code>-o add.wasm</code> tells the linker to write the output to &quot;add.wasm&quot; (instead of the default &quot;a.out&quot; file)</li>
</ul>
<p>Disassembling &quot;add.wasm&quot; yields the following:</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$__stack_pointer</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">66560</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span></code></pre>
<p>My code disappeared! Of course, this isn&#39;t surprising because my code has no entry point and doesn&#39;t export anything.</p>
<h3 id="memory-and-a-stack">Memory and a stack</h3>
<p>Interestingly, this most recent disassembly shows some other changes:</p>
<ul>
<li>A block of linear memory that starts at 2 pages long is declared</li>
<li>There is a stack pointer that is initialized to 1 KB into the second page of memory</li>
<li>This memory is exported from the module</li>
<li>The seemingly unnecessary memory <em>import</em> (<code>env.__linear_memory</code>) is no longer present</li>
</ul>
<p>I have some questions about this arrangement:</p>
<ul>
<li>Why is the memory exported? Can the host code read or even modify the stack? (Spoiler: yes)</li>
<li>Does this stack solely exist to support C semantics (e.g. taking the address of a variable on the stack)? (Probably)<ul>
<li>Note that <a href="https://github.com/WebAssembly/design/blob/main/Nondeterminism.md">this WebAssembly note</a> indicates the VM&#39;s stack can&#39;t be accessed by a program (&quot;Note that this stack isn&#39;t located in the program-accessible linear memory&quot;)</li>
</ul>
</li>
</ul>
<h3 id="aside-a-webassembly-critique">Aside: a WebAssembly critique</h3>
<p>As an aside: while trying to find answers to some of my questions, I ran across an <a href="http://troubles.md/wasm-is-not-a-stack-machine/">incredibly insightful series of posts</a> that retrospectively critiques some of WebAssembly&#39;s design decisions.</p>
<h3 id="exports">Exports</h3>
<p>Back to my trivial experiment.</p>
<p>How do I tell Clang/LLVM that I want to export a function? Consulting the <a href="https://lld.llvm.org/WebAssembly.html">linker documentation</a>, it looks like I can export everything (not my preferred approach) or specify exports either on the command line or with attributes in the code. In code, the two options appear to be:</p>
<ul>
<li>Mark exports with <code>__attribute__((export_name(&quot;nameOfExport&quot;)))</code></li>
<li>Specify <code>-Wl,--export-dynamic</code> on the Clang command line and mark exports with <code>__attribute__ ((visibility (&quot;default&quot;)))</code></li>
</ul>
<p>I kind of wish there was an &quot;always export this symbol by name&quot; option that didn&#39;t require duplicating the name. C preprocessor to the rescue!</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(add)</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<p>Output:</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$__stack_pointer</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">66560</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;add&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span><span class="hljs-punctuation">)))</span></code></pre>
<p>This looks like what I want. I&#39;ve got my function and it&#39;s being exported (along with a memory region that I&#39;m not actually using in my code).</p>
<h2 id="using-the-module">Using the module</h2>
<p>Now that I&#39;ve got my finished module (<code>add.wasm</code>), I need to host it somewhere.</p>
<h3 id="using-the-module-in-node">Using the module in Node</h3>
<p>Here&#39;s an example of loading the module and calling <code>add</code> in Node:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));
})();</code></pre>
<ul>
<li><code>await fs.promises.readFile(&quot;./add.wasm&quot;)</code> initiates a file read and resumes upon completion</li>
<li><code>const module = await WebAssembly.instantiate(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>add(2, 2)</code> returns 4, as expected</li>
</ul>
<h3 id="using-the-module-in-a-web-page">Using the module in a web page</h3>
<p>Here&#39;s a web page for my trivial example:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of 2 + 2 is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Note that using <code>fetch</code> isn&#39;t supported from the file system, so I used <a href="https://github.com/http-party/http-server">a trivial HTTP server</a> for local testing.</p>
<ul>
<li><code>fetch(&quot;./add.wasm&quot;)</code> initiates a request to load the module by relative path</li>
<li><code>const module = await WebAssembly.instantiateStreaming(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>document.getElementById(&quot;result&quot;).innerText = add(2, 2);</code> updates the &quot;result&quot; span with the result of the call to <code>add</code></li>
</ul>
<p>To my surprise, everything worked on the first try.</p>
<p>I was also able to confirm that the module&#39;s memory was exported (<code>module.instance.exports.memory</code>) and could be read from within my browser&#39;s dev tools window. I&#39;m still not clear on why LLVM decided to export the memory by default.</p>
<h1 id="thats-it">That&#39;s it!</h1>
<p>The end result of all this was actually pretty simple. Here are some links for reference:</p>
<ul>
<li><a href="https://github.com/jaredkrinke/webassembly-trivial-example">GitHub repository with all the code and build commands</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-trivial-example/">Live demo of the module hosted in a web page</a> (using <code>WebAssembly.instantiate()</code> instead of <code>instantiateStreaming()</code> for compatibility with older browsers)</li>
</ul>
<p>Remembering how to use a C compiler on the command line, and deciphering LLVM&#39;s export semantics took a bit more time than I would have liked, but I learned a lot about WebAssembly in the process.</p>
<p>Next up, I&#39;ll see if I can get the C standard library working.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/trivial-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/trivial-example</guid><pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>