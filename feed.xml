<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2024-03-02T04:16:38.440Z</updated>

<entry>
<title>SIC-1 is going open source</title>
<id>https://log.schemescape.com/posts/game-development/sic-1-open-source.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1-open-source.html"/>
<updated>2023-12-19T00:00:00.000Z</updated>
<summary type="text">Which open source licenses make the most sense for my game?</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html&quot;&gt;my original retrospective on releasing SIC-1&lt;/a&gt; (a single-instruction zachlike programming game), there were two open questions about the future:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Should I port the game to Linux (on Steam)?&lt;/li&gt;
&lt;li&gt;Should I release the game under an open source license?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first question has been answered: &lt;a href=&quot;https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux-2.html&quot;&gt;SIC-1 has been ported to Linux (on Steam)&lt;/a&gt;, but the second had not (until now).&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve finally decided to release the game under an open source license. &lt;strong&gt;Which license? Good question!&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Why release SIC-1 as open source? Up until now, the game has been my baby and there have been no substantial contributions by anyone else.&lt;/p&gt;
&lt;p&gt;If I was naive, I&amp;#39;d hope that releasing the game as open source would lead to a revival, driven by contributions from excited new authors. But I&amp;#39;m &lt;em&gt;not&lt;/em&gt; naive, and I fully expect that no one else will take the time to read, understand, and modify the code in any significant way.&lt;/p&gt;
&lt;p&gt;But games are more than just code! There are also assets. Specifically, SIC-1 contains a bunch of English text, both in the form of documentation and narrative. While I don&amp;#39;t expect the characters I&amp;#39;ve developed to get their own spin-off TV series, there is at least &lt;em&gt;one&lt;/em&gt; area where I am hopelessly under-qualified &lt;em&gt;and&lt;/em&gt; multiple people have expressed an actual interest in contributing:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Translating SIC-1 into additional languages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I feel it would be unfair to ask for translations from &lt;em&gt;volunteers&lt;/em&gt; in the case that I retained ownership over the entire game (even though the game is available for free already). Instead, I think it makes sense to open up ownership of the game to &lt;em&gt;everyone&lt;/em&gt;, i.e. release the game as open source.&lt;/p&gt;
&lt;h1 id=&quot;hypothetical-concerns&quot;&gt;Hypothetical concerns&lt;/h1&gt;
&lt;p&gt;Given that SIC-1 is free, with source already available, why wasn&amp;#39;t the game already open source? Here was my &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html#should-i-open-source-sic-1&quot;&gt;original rationale&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t want someone else to turn around and sell my game (that I released for free)&lt;/li&gt;
&lt;li&gt;I&amp;#39;m proud of the music and characters/narrative, and I don&amp;#39;t want other people to be able to profit off of them&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now that the game has been out on Steam for over a year and I think it&amp;#39;s already past its popularity peak, I feel less concerned about someone else profiting off of the game. The zachlike genre is just not that popular. Even excellent zachlikes &lt;em&gt;from Zachtronics&lt;/em&gt; don&amp;#39;t sell that many copies. And SIC-1 isn&amp;#39;t nearly as good! &lt;strong&gt;No one&amp;#39;s going to get rich off this game.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As far as the characters and narrative, I can&amp;#39;t imagine anyone repurposing them. And I can just use a copyleft/share-alike license anyway.&lt;/p&gt;
&lt;p&gt;Having said all of that, I don&amp;#39;t think I&amp;#39;m quite ready to let &lt;em&gt;just anyone&lt;/em&gt; use the music from the &lt;a href=&quot;https://soundcloud.com/schemescape/sets/sic-1-original-soundtrack&quot;&gt;SIC-1 Original Soundtrack&lt;/a&gt;. Unlike code and documentation, background music could fit right into completely unrelated projects--or even &lt;em&gt;events&lt;/em&gt;. &lt;strong&gt;What if 80s-inspired puzzlewave suddenly breaks into the mainstream and then I&amp;#39;m hearing the SIC-1 soundtrack at political rallies?&lt;/strong&gt; Maybe that&amp;#39;s taking this hypothetical situation a bit too far, but, regardless, I&amp;#39;ll probably continue to retain sole ownership over the soundtrack.&lt;/p&gt;
&lt;h1 id=&quot;copyleft-or-permissive-license&quot;&gt;Copyleft or permissive license?&lt;/h1&gt;
&lt;p&gt;The main decision I need to make around licensing is between choosing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Copyleft&quot;&gt;copyleft&lt;/a&gt; vs. permissive license (e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_General_Public_License&quot;&gt;GPL&lt;/a&gt; vs. &lt;a href=&quot;https://en.wikipedia.org/wiki/MIT_license&quot;&gt;MIT&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I like the idea of using a copyleft license because it (roughly) requires anyone distributing derivative works release their modifications back to the community. There is one sticking point with the GPL, however: it doesn&amp;#39;t allow linking with closed source code--in my case, this means I couldn&amp;#39;t link with the Steamworks SDK (which provides achievements and friend leaderboards on Steam) without jumping through some hoops (e.g. &lt;a href=&quot;https://github.com/icculus/steamshim&quot;&gt;moving Steam interactions out of process&lt;/a&gt; or requiring contributors sign a &amp;quot;contributor license agreement&amp;quot; allowing distribution on Steam). The &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License&quot;&gt;LGPL license &lt;/a&gt; would avoid this problem.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s another issue with copyleft: what if I want to later use my code in a new game? Of course I can use &lt;em&gt;my&lt;/em&gt; code, but I wouldn&amp;#39;t be able to use any improvements that have been contributed by others. Honestly, however, this seems unfair to those contributors--I&amp;#39;d be (potentially) profiting off of their work.&lt;/p&gt;
&lt;p&gt;After writing these thoughts down, I think the answer is clear: &lt;strong&gt;I&amp;#39;d prefer to use a copyleft license to protect both my contributions &lt;em&gt;and the contributions of others&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;the-plan&quot;&gt;The plan&lt;/h1&gt;
&lt;p&gt;Given all of the above, here&amp;#39;s my plan for licensing the various categories of SIC-1 content:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source code&lt;/strong&gt;: &lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;GNU Lesser General Public License&lt;/a&gt; (at least until I have time to incorporate a GPL shim for the Steamworks SDK)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Documentation/narrative&lt;/strong&gt;: &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution, Share-Alike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Music&lt;/strong&gt;: &amp;quot;all rights reserved&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>A Common Lisp static site generator, because why not?</title>
<id>https://log.schemescape.com/posts/static-site-generators/lisp-ssg.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/lisp-ssg.html"/>
<updated>2023-11-29T00:00:00.000Z</updated>
<summary type="text">The static site generator that almost wasn&apos;t, but then was.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-4.html&quot;&gt;a recent post about speeding up md2blog&lt;/a&gt; (the &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;Deno/TypeScript-based static site generator I created for this site&lt;/a&gt;), I gloated about suppressing the urge to build &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/pre-markdown.html&quot;&gt;yet another&lt;/a&gt; static site generator:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I have successfully staved off the urge ... to create yet another static site generator by instead making md2blog ... &lt;em&gt;just fast enough&lt;/em&gt; ... that it seems pointless to bother improving upon its performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;This is the inevitable follow-up post where I describe the new static site generator I ended up building&lt;/strong&gt;, this time using Common Lisp.&lt;/p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ll discuss differentiators next, but my personal motivation for creating this static site generator is some combination of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/learning-lisp-in-2023.html&quot;&gt;I&amp;#39;ve been learning Common Lisp&lt;/a&gt; (to sample REPL-driven development, macros, etc.) and I wanted to build a small-but-nontrivial project to help me learn (aside: I&amp;#39;m also curious about performance with &lt;a href=&quot;https://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;I wanted to try building an extensible static site generator (like &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt;) that natively supports incremental rebuilds&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words: &lt;strong&gt;for fun&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;differentiators&quot;&gt;Differentiators&lt;/h1&gt;
&lt;p&gt;Fun is fun, but am I just reinventing the wheel? Hopefully not. I fully expect no one else will use this static site generator (assuming I even &lt;em&gt;complete&lt;/em&gt; it), but I think it does have a unique combination of features, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Being based around a &lt;strong&gt;completely generic and extensible pipeline&lt;/strong&gt; (sort of a &amp;quot;static site generator toolkit&amp;quot;, similar to Metalsmith)--theoretically, it&amp;#39;s not even limited to web pages (or even the file system)&lt;/li&gt;
&lt;li&gt;Having &lt;strong&gt;fast incremental rebuilds&lt;/strong&gt; natively supported, without having to prescriptively list the inputs and outputs of each step&lt;/li&gt;
&lt;li&gt;Using a &lt;strong&gt;template system that is based entirely on list processing&lt;/strong&gt; (the &amp;quot;Lisp&amp;quot; part of &amp;quot;Common Lisp&amp;quot;)&lt;/li&gt;
&lt;li&gt;Providing a &lt;strong&gt;built-in debugger&lt;/strong&gt; (this one is kind of cheating since it comes for free with Common Lisp)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;architecture&quot;&gt;Architecture&lt;/h1&gt;
&lt;h2 id=&quot;pipeline&quot;&gt;Pipeline&lt;/h2&gt;
&lt;p&gt;For maximum flexibility, this static site generator is based on a generic processing pipeline, represented as a &lt;strong&gt;directed acyclic graph of processing nodes&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s a description of a blog pipeline, with one bullet per node:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerate files from the input directory&lt;/li&gt;
&lt;li&gt;Extract front matter (metadata) from Markdown files&lt;/li&gt;
&lt;li&gt;Convert Markdown into a tree-based document format&lt;/li&gt;
&lt;li&gt;Create an index of all posts&lt;/li&gt;
&lt;li&gt;Create index and archive pages&lt;/li&gt;
&lt;li&gt;Render tree format into HTML&lt;/li&gt;
&lt;li&gt;Write HTML files out to the output directory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In image form (note: the pipeline definition in code is shown later):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/pipeline-blog.svg&quot; alt=&quot;Blog pipeline diagram&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;node-types&quot;&gt;Node types&lt;/h2&gt;
&lt;p&gt;So far, this sounds like Metalsmith&amp;#39;s declarative JSON-based &amp;quot;plugin chain&amp;quot;. Here&amp;#39;s the twist:&lt;/p&gt;
&lt;p&gt;There are two main node types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Aggregate nodes&lt;/strong&gt;: Similar to Metalsmith plugins, these nodes operate over the entire set of files/items and produce multiple outputs (and can remove items, too), i.e. they are M:N (M inputs and N outputs)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transform nodes&lt;/strong&gt;: These are 1:N nodes which only consume a single input file/item (but can still produce N outputs)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, here are two hypothetical nodes: an aggregate node that combines metadata from two Markdown posts (&amp;quot;post1.md&amp;quot; and &amp;quot;post2.md&amp;quot;) into a single index (&amp;quot;index.json&amp;quot;), and a transform node that converts Markdown to HTML -- note that the transform node processes each item in isolation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/node-aggregate.svg&quot; alt=&quot;Aggregate node diagram&quot;/&gt; &lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/node-transform.svg&quot; alt=&quot;Transform node diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Explicitly expressing 1:N transform nodes is the primary innovation (although I&amp;#39;m sure--at least I hope--this has been done before, somewhere). Here are the benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single-item transformations can be run in parallel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Only &lt;em&gt;new or modified&lt;/em&gt; input items need to be transformed&lt;/strong&gt; when rebuilding (updating)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;experimented with a similar approach using GNU Make in the past&lt;/a&gt;, but besides being slow (because it spun up a new process for processing each input), it was also cumbersome, requiring hand-crafting patterns and adding kludges to detect zombie files that should be deleted.&lt;/p&gt;
&lt;h3 id=&quot;under-the-hood&quot;&gt;Under the hood&lt;/h3&gt;
&lt;p&gt;Internally, the processing pipeline actually operates over &amp;quot;changes&amp;quot;. For example, if a file gets added or modified in the source directory, an &lt;code&gt;:update&lt;/code&gt; event is propagated down the pipeline; if a file is deleted, a &lt;code&gt;:delete&lt;/code&gt; event is sent. There are two additional node types that operate directly upon changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source nodes&lt;/strong&gt;: Create changes (e.g. based on seeing if the contents of a directory have changed)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sink nodes&lt;/strong&gt;: Consume changes (e.g. write &lt;code&gt;:update&lt;/code&gt;&amp;#39;d files to disk or remove &lt;code&gt;:delete&lt;/code&gt;&amp;#39;d files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each node maintains a snapshot of inputs and outputs and they will only run when their input actually changes (item contents and/or metadata). Transform nodes also maintain a map of inputs &lt;em&gt;to&lt;/em&gt; outputs (to handle deletions, implicit or explicit).&lt;/p&gt;
&lt;h3 id=&quot;node-types-example&quot;&gt;Node types example&lt;/h3&gt;
&lt;p&gt;Here&amp;#39;s the blog pipeline from before with each node type in parentheses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerate files (&lt;strong&gt;source node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Extract front matter (metadata) (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Convert Markdown into a tree (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Create an index (&lt;strong&gt;aggregate node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Create index/archive pages (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Render HTML (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Write HTML files (&lt;strong&gt;sink node&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that when a single Markdown post is updated, the transform nodes only need to process the updated item(s) (if any).&lt;/p&gt;
&lt;h2 id=&quot;item-representation&quot;&gt;Item representation&lt;/h2&gt;
&lt;p&gt;Items are represented by three pieces of information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Path&lt;/strong&gt;: UNIX-style pathname, relative to the source directory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content&lt;/strong&gt;: file content, in any format--even just a pathname for e.g. pass-through static assets&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metadata&lt;/strong&gt;: an bag of arbitrary properties (currently using an association list)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;templateshtml-representation&quot;&gt;Templates/HTML representation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;I hate most static site generators because I hate the template languages they use&lt;/strong&gt;. Especially the one Hugo uses. Sometimes, it&amp;#39;s just the verbose syntax for inserting a value that I dislike. Other times, it&amp;#39;s the bespoke conditional/loop syntax that I grudgingly have to learn.&lt;/p&gt;
&lt;p&gt;A corollary to &lt;a href=&quot;https://en.wikipedia.org/wiki/Greenspun&amp;#39;s_tenth_rule&quot;&gt;Greenspun&amp;#39;s tenth rule&lt;/a&gt; seems appropriate:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any sufficiently complicated &lt;del&gt;C or Fortran program&lt;/del&gt; &lt;em&gt;HTML template language&lt;/em&gt; contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The obvious solution is to simply embrace Common Lisp&amp;#39;s list processing. Here&amp;#39;s an example of the list format I&amp;#39;m using:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;:p&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Here is a &amp;quot;&lt;/span&gt;
    (&lt;span class=&quot;hljs-symbol&quot;&gt;:a&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:href&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;https://log.schemescape.com/&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;link!&amp;quot;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rendered to HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Here is a &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;https://log.schemescape.com/&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;link!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So that&amp;#39;s the &amp;quot;list&amp;quot; part.&lt;/p&gt;
&lt;p&gt;The &amp;quot;processing&amp;quot; part is &lt;strong&gt;literally just Common Lisp code&lt;/strong&gt;. No weird syntax, just a standardized language that&amp;#39;s been kicking around for decades. Although I haven&amp;#39;t implemented it yet, this should also make validating relative links at build-time trivial since I only need to walk lists (something Lisp does with ease).&lt;/p&gt;
&lt;p&gt;For the record, I did not use &lt;a href=&quot;https://edicl.github.io/cl-who/&quot;&gt;CL-WHO&lt;/a&gt; because it doesn&amp;#39;t escape strings by default and I didn&amp;#39;t use &lt;a href=&quot;https://github.com/ruricolist/spinneret&quot;&gt;Spinneret&lt;/a&gt; because it has ~20 dependencies.&lt;/p&gt;
&lt;h1 id=&quot;current-status&quot;&gt;Current status&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s what I&amp;#39;ve implemented so far:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pipeline, node, and item representation&lt;/li&gt;
&lt;li&gt;Directory enumeration&lt;/li&gt;
&lt;li&gt;Prototype YAML and Markdown parsing (although both will need to be replaced)&lt;/li&gt;
&lt;li&gt;HTML templates&lt;/li&gt;
&lt;li&gt;Prototype blog pipeline (minus an Atom feed and site map)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There&amp;#39;s quite a bit of work remaining:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel transformations (should be trivial with &lt;a href=&quot;https://github.com/lmj/lparallel&quot;&gt;lparallel&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Find and integrate a more robust Markdown parser&lt;/li&gt;
&lt;li&gt;Add a live-reloading web server&lt;/li&gt;
&lt;li&gt;Add Atom feed (and possibly site map) support to the blog pipeline&lt;/li&gt;
&lt;li&gt;Consider adding build-time syntax highlighting&lt;/li&gt;
&lt;li&gt;Persist intermediate objects to disk&lt;/li&gt;
&lt;li&gt;Document everything&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;
&lt;p&gt;Given that the implementation is incomplete, I don&amp;#39;t want to read too much into its performance. For my site, I expect it to be fast because updating a single blog post will only require rebuilding the edited post, possibly the index/archive/post index pages, and possibly the Atom feed (&lt;strong&gt;roughly a 30x reduction in the number of files being written&lt;/strong&gt; for my smallish site).&lt;/p&gt;
&lt;p&gt;On my netbook where I finally got md2blog live rebuilds down to 200ms, the prototype blog could complete an incremental rebuild for a single post update in 80ms--and that&amp;#39;s with a slow (and brittle) Markdown processor that needs to be replaced.&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Currently, the code is a complete mess&lt;/strong&gt;. It&amp;#39;s all one big file with a million TODOs and at least one gratuitous macro. It&amp;#39;s a work-in-progress, and code cleanup isn&amp;#39;t even in my top ten concerns right now.&lt;/p&gt;
&lt;p&gt;Honestly, I don&amp;#39;t even want to share the code because it&amp;#39;s so ugly, but since you can easily find it, I&amp;#39;ll just save you the trouble:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jaredkrinke/cl-stuff/blob/main/ssg/ssg.lisp&quot;&gt;https://github.com/jaredkrinke/cl-stuff/blob/main/ssg/ssg.lisp&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pipeline-example&quot;&gt;Pipeline example&lt;/h3&gt;
&lt;p&gt;Here is an example of the previous blog pipeline expressed in code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;defparameter&lt;/span&gt; *pipeline*
  &amp;#x27;((source :children (front-matter))
    (front-matter :children (markdown
                             index-posts))
    (markdown :children (template-posts))
    (template-posts :children (lhtml))
    (index-posts :children (template-indexes))
    (template-indexes :children (lhtml))
    (lhtml :children (destination))
    (destination)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first symbol in each list is the name of a node class. Arcs/arrows can be added via either &lt;code&gt;:children&lt;/code&gt; or &lt;code&gt;:parents&lt;/code&gt;. I prefer to use &lt;code&gt;:children&lt;/code&gt; because it seems more intuitive to think of the way items flow through the pipeline (source -&amp;gt; front-matter -&amp;gt; markdown -&amp;gt; template-posts -&amp;gt; lhtml -&amp;gt; destination).&lt;/p&gt;
&lt;h2 id=&quot;name&quot;&gt;Name&lt;/h2&gt;
&lt;p&gt;So what is this new static site generator called? Well, that&amp;#39;s &lt;em&gt;also&lt;/em&gt; not in my top ten concerns right now. The Common Lisp package is just named &lt;code&gt;SSG&lt;/code&gt; as a placeholder. &lt;strong&gt;Hopefully I&amp;#39;ll think of a catchy name eventually&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;the-end&quot;&gt;The end&lt;/h1&gt;
&lt;p&gt;And apologies for creating yet another static site generator. At least I didn&amp;#39;t create a new front-end framework for JavaScript!&lt;/p&gt;
</content>
</entry>
<entry>
<title>My hobby is... bikeshedding?</title>
<id>https://log.schemescape.com/posts/misc/my-hobby-is-bikeshedding.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/misc/my-hobby-is-bikeshedding.html"/>
<updated>2023-11-17T00:00:00.000Z</updated>
<summary type="text">Am I spending development time on things that matter?</summary>
<content type="html">&lt;p&gt;Although I&amp;#39;d seen the term thrown around, I hadn&amp;#39;t looked up the definition of &amp;quot;bikeshedding&amp;quot; until recently. DuckDuckGo tells me that &amp;quot;bikeshedding&amp;quot; is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Futile investment of time and energy in marginal technical issues&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Wait a minute. That accurately describes much (if not most) of this blog.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bikeshedding is my primary hobby&lt;/strong&gt;, apparently.&lt;/p&gt;
&lt;h1 id=&quot;a-quick-review&quot;&gt;A quick review&lt;/h1&gt;
&lt;p&gt;Looking back at my previous posts, I see:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../static-site-generators/comparison.html&quot;&gt;Trying to find a static site generator&lt;/a&gt; that supports my desired workflow, and &lt;a href=&quot;https://log.schemescape.com/posts/misc/../static-site-generators/md2blog-deno.html&quot;&gt;eventually building my own&lt;/a&gt; (instead of just using Hugo)&lt;/li&gt;
&lt;li&gt;Attempting to speed up my home-grown static site generator because, &lt;a href=&quot;https://log.schemescape.com/posts/misc/../static-site-generators/speeding-up-rebuilds-4.html&quot;&gt;apparently, 50 millisecond rebuilds doesn&amp;#39;t seem optimal&lt;/a&gt; (ignoring the fact that 50 milliseconds is probably actual lightning speed)&lt;/li&gt;
&lt;li&gt;Avoiding Emscripten&amp;#39;s bloated (and Python-based) tooling to &lt;a href=&quot;https://log.schemescape.com/posts/misc/../webassembly/compiling-graphviz-to-webassembly.html&quot;&gt;generate diagrams&lt;/a&gt; and &lt;a href=&quot;https://log.schemescape.com/posts/misc/../webassembly/passing-strings-to-c.html&quot;&gt;pass strings around&lt;/a&gt; (instead of just using the most popular native-to-browser framework)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../web-development/souring-on-npm.html&quot;&gt;Fretting over the software supply chain of NPM&lt;/a&gt;, and switching to Deno (abandoning one of the largest library ecosystems ever created--N.B. this was before Deno added NPM support)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/rust-first-experience.html&quot;&gt;Whining about the size of the Rust toolchain on Windows&lt;/a&gt; (even though I have a terabyte drive)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/future-proof-languages.html&quot;&gt;&lt;em&gt;Way&lt;/em&gt;&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/future-proof-languages-2.html&quot;&gt;too&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/future-proof-languages-3.html&quot;&gt;much&lt;/a&gt; musing about &amp;quot;future-proof&amp;quot; programming languages (instead of just picking the right tool for the job)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../game-development/browser-based-game-on-steam-2.html&quot;&gt;Porting a browser-based game to Steam without using Electron&lt;/a&gt; because I thought Electron was too bloated (spoiler: I ended up using Electron to add Linux support anyway)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/minimal-dev-env-3.html&quot;&gt;Developing software &lt;em&gt;on&lt;/em&gt; a Raspberry Pi 1B&lt;/a&gt; because &lt;em&gt;it should be possible, right?&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../web-development/interactive-browser-app-without-js-2.html&quot;&gt;Creating a (nearly unplayable) real-time browser-based game that doesn&amp;#39;t use any JavaScript&lt;/a&gt; because modern browsers eat up all my netbook&amp;#39;s memory (even though I mostly use my desktop computer, because it&amp;#39;s convenient)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/misc/../web-development/cheap-hosting.html&quot;&gt;Rewriting software to avoid spending a few dollars per month&lt;/a&gt; (despite that money likely being a rounding error in my monthly finances)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;but-why&quot;&gt;But why?&lt;/h1&gt;
&lt;p&gt;At the time, I justified most of these plans in terms of economy: &lt;strong&gt;I was optimizing resources in reaction to everything else seeming so bloated&lt;/strong&gt;. I was &lt;em&gt;respecting the user&lt;/em&gt; by minimizing dependencies/system requirements.&lt;/p&gt;
&lt;p&gt;But in retrospect, I wonder if &lt;strong&gt;I was just focused on optimization because it was often the most straight-forward and unambiguous task&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s not to say that I was necessarily &lt;em&gt;wasting my time&lt;/em&gt;. I learned a ton from these projects. And minimizing resource usage is extremely important for respecting your users... but that only matters when you have users. Otherwise, it&amp;#39;s just premature optimization (assuming a reasonable baseline).&lt;/p&gt;
&lt;h1 id=&quot;goals&quot;&gt;Goals&lt;/h1&gt;
&lt;p&gt;I suspect software development can be lucrative because costs scale slowly. Solving a problem for 1 person may take a lot of work, but solving it for 100 (or 1000) additional users often costs very little. Of course, sometimes, I&amp;#39;m just looking to solve my own problem, and I don&amp;#39;t plan on having any &amp;quot;users&amp;quot;.&lt;/p&gt;
&lt;p&gt;Ultimately, &lt;strong&gt;before I start a project, I should have a target audience and/or goal in mind&lt;/strong&gt;. This seems obvious, but I&amp;#39;m fairly certain that most of my projects began organically, with only a vague notion of what I wanted to achieve.&lt;/p&gt;
&lt;p&gt;Additionally, &lt;strong&gt;I need to critically evaluate any goals and whether or not they&amp;#39;re worth the effort&lt;/strong&gt;. Creating a Common Lisp-based static site generator in order to learn Lisp because it sounds fun? Probably a good idea! Creating a Common Lisp-based static site generator in order to provide faster incremental and custom templates, for a tool that &lt;a href=&quot;https://blubsblog.bearblog.dev/i-am-the-only-user/&quot;&gt;will likely only ever have one user&lt;/a&gt;? Probably not worth the effort!&lt;/p&gt;
&lt;h1 id=&quot;looking-forward&quot;&gt;Looking forward&lt;/h1&gt;
&lt;p&gt;Fittingly, my current hobby of learning Common Lisp started &lt;a href=&quot;https://log.schemescape.com/posts/misc/../programming-languages/learning-lisp-in-2023.html&quot;&gt;because I read about REPL-driven development and wanted to test it out for myself&lt;/a&gt;. In the process, I&amp;#39;ve found many additional reasons to persist with Lisp:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Macros&lt;/strong&gt;, for ergonomically generating code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conditions&lt;/strong&gt;, for observing and handling errors at a distance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lists&lt;/strong&gt; (of course), a handy, multi-purpose data structure, built into the core of the language&lt;/li&gt;
&lt;li&gt;With Emacs and SLIME, &lt;strong&gt;a fully-featured editing and debugging experience&lt;/strong&gt; that easily runs on an old netbook&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A broad ecosystem&lt;/strong&gt;, with numerous implementations and a wide range of libraries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lisp is just &lt;em&gt;too&lt;/em&gt; enticing to a dedicated software developer. It&amp;#39;s the most expressive and extensible programming language I&amp;#39;ve encountered, and it&amp;#39;s &lt;em&gt;just popular enough&lt;/em&gt; that learning it doesn&amp;#39;t feel like a waste of time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But what is my &lt;em&gt;goal&lt;/em&gt; with learning Common Lisp?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Originally, I just was curious and wanted to try REPL-driven development, and now I&amp;#39;m used to it--it&amp;#39;s nice, but not indispensable&lt;/li&gt;
&lt;li&gt;Macros can be handy (in small doses), but I&amp;#39;m pretty sure other languages now support syntax tree-level macros&lt;/li&gt;
&lt;li&gt;Common Lisp &amp;quot;conditions&amp;quot; (and &amp;quot;restarts&amp;quot;) still seem unique and useful&lt;/li&gt;
&lt;li&gt;Lists are handy, but they seem inefficient on modern hardware&lt;/li&gt;
&lt;li&gt;Having the equivalent of a language server that runs comfortably in the terminal on a netbook warms my heart, but fast computers are cheap&lt;/li&gt;
&lt;li&gt;Having many interoperable Common Lisp implementations sounds future-proof, but am I realistically going to use anything other than SBCL?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Overall, I like Common Lisp, but now I can&amp;#39;t shake the feeling that using an extensible programming language that fits on netbook is just more bikeshedding.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Most programming language distinctions could probably be classified as &amp;quot;marginal technical issues&amp;quot; for all but the most demanding workloads.&lt;/p&gt;
&lt;p&gt;The whole world seems to be using Python or JavaScript and they&amp;#39;re &amp;quot;good enough&amp;quot; for most purposes. Should I just hop on the bandwagon and stop fussing over those languages&amp;#39; deficiencies? Well, that depends on the goal...&lt;/p&gt;
</content>
</entry>
<entry>
<title>Investigating slow file enumeration in SBCL on Windows</title>
<id>https://log.schemescape.com/posts/lisp/sbcl-file-perf-windows.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/lisp/sbcl-file-perf-windows.html"/>
<updated>2023-11-14T00:00:00.000Z</updated>
<summary type="text">Is file enumeration when using SBCL on Windows so slow that it can&apos;t support a fast static site generator? Yes and no.</summary>
<content type="html">&lt;p&gt;While experimenting to see if I could improve upon &lt;a href=&quot;https://log.schemescape.com/posts/lisp/../static-site-generators/speeding-up-rebuilds-4.html&quot;&gt;the performance of md2blog&lt;/a&gt; using Common Lisp (and a fancier design), I noticed that &lt;strong&gt;file enumeration in &lt;a href=&quot;https://www.sbcl.org/&quot;&gt;Steel Bank Common Lisp&lt;/a&gt; (on Windows) was slow&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Spoiler: it can be a &lt;em&gt;lot&lt;/em&gt; faster (for my scenario, at least).&lt;/p&gt;
&lt;h1 id=&quot;the-problem&quot;&gt;The problem&lt;/h1&gt;
&lt;p&gt;Obviously, I shouldn&amp;#39;t be wasting my time building a new static site generator, with precise incremental builds. Also, obviously, I am.&lt;/p&gt;
&lt;p&gt;Since I&amp;#39;ve gotten &lt;a href=&quot;https://log.schemescape.com/posts/lisp/../static-site-generators/speeding-up-rebuilds-4.html#results&quot;&gt;live rebuilds of md2blog down to 50 milliseconds on my desktop&lt;/a&gt;, there&amp;#39;s not a lot of room for inefficiency when trying to improve performance. Unfortunately, my initial experiments using SBCL showed that &lt;strong&gt;just &lt;em&gt;enumerating&lt;/em&gt; files (no processing whatsoever) took up my entire 50 millisecond budget&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I tried simplifying my code so that it only used built-in directory/pathname functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;defparameter&lt;/span&gt; *wildcard-pathname* (&lt;span class=&quot;hljs-name&quot;&gt;make-pathname&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:wild&lt;/span&gt;
                                                 &lt;span class=&quot;hljs-symbol&quot;&gt;:type&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:wild&lt;/span&gt;))

(&lt;span class=&quot;hljs-name&quot;&gt;defun&lt;/span&gt; enumerate-files (&lt;span class=&quot;hljs-name&quot;&gt;directory&lt;/span&gt;)
  (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;items&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;list&lt;/span&gt; directory))
        (&lt;span class=&quot;hljs-name&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;))
    (&lt;span class=&quot;hljs-name&quot;&gt;loop&lt;/span&gt; while items do
      (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;pop&lt;/span&gt; items)))
        (&lt;span class=&quot;hljs-name&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;pathname-name&lt;/span&gt; item)
            (&lt;span class=&quot;hljs-name&quot;&gt;push&lt;/span&gt; item files)
            (&lt;span class=&quot;hljs-name&quot;&gt;loop&lt;/span&gt; for child in (&lt;span class=&quot;hljs-name&quot;&gt;directory&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;merge-pathnames&lt;/span&gt; *wildcard-pathname* item)) do
              (&lt;span class=&quot;hljs-name&quot;&gt;push&lt;/span&gt; child items)))))
    files))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;investigation&quot;&gt;Investigation&lt;/h1&gt;
&lt;h2 id=&quot;is-it-just-windows&quot;&gt;Is it just Windows?&lt;/h2&gt;
&lt;p&gt;As a sanity check, I ran the same scenario under SBCL on Linux on a &lt;em&gt;much&lt;/em&gt; slower computer (Intel Atom, rotational drive)... but the performance was the same: 50 milliseconds. Could Windows really be so slow that my fancy desktop is as slow as an old netbook?&lt;/p&gt;
&lt;p&gt;No, that can&amp;#39;t be. I can enumerate all these files using &lt;a href=&quot;https://deno.com/&quot;&gt;Deno&lt;/a&gt; in 5 milliseconds (that&amp;#39;s what md2blog does, after all).&lt;/p&gt;
&lt;h2 id=&quot;is-it-just-overhead&quot;&gt;Is it just overhead?&lt;/h2&gt;
&lt;p&gt;So if the problem is &lt;em&gt;not&lt;/em&gt; Windows, maybe the problem is SBCL (or Common Lisp itself). Fortunately, Common Lisp has a built-in &lt;code&gt;time&lt;/code&gt; function to measure time spent in a function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;time&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;enumerate-files&lt;/span&gt; #p&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;../../log/content/&amp;quot;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reports:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;Evaluation took:
  0.054 seconds of real time
  0.046875 seconds of total run time (0.000000 user, 0.046875 system)
  87.04% CPU
  186,748,133 processor cycles
  425,088 bytes consed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmmm... no &amp;quot;user&amp;quot; time and all &amp;quot;system&amp;quot; time? Blaming the system seems a little suspicious, given that this code runs 10x slower than Deno&amp;#39;s baseline.&lt;/p&gt;
&lt;p&gt;I thought this might be a great time to test out &lt;a href=&quot;http://www.sbcl.org/manual/#Statistical-Profiler&quot;&gt;SBCL&amp;#39;s statistical profiler&lt;/a&gt;, but it turns out it&amp;#39;s &lt;a href=&quot;https://github.com/sbcl/sbcl/blob/a9abb1c41c457e9299b53f75b4196d3014432c9b/contrib/sb-sprof/interface.lisp#L224&quot;&gt;not implemented on Windows&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;is-sbcl-using-the-wrong-api&quot;&gt;Is SBCL using the wrong API?&lt;/h2&gt;
&lt;p&gt;Maybe SBCL is correctly reporting that virtually the entire time is spent in system calls because it&amp;#39;s using an inefficient API?&lt;/p&gt;
&lt;p&gt;After locating a searchable version of its source, I found that SBCL &lt;a href=&quot;https://github.com/sbcl/sbcl/blob/a9abb1c41c457e9299b53f75b4196d3014432c9b/src/code/win32.lisp#L534&quot;&gt;is using FindFirstile&lt;/a&gt;. There &lt;em&gt;is&lt;/em&gt; a &lt;code&gt;FindFirstFileEx&lt;/code&gt; which offers at least one minor optimization, but I don&amp;#39;t see Rust/Deno using it, so that&amp;#39;s probably not the issue.&lt;/p&gt;
&lt;h1 id=&quot;reassessing&quot;&gt;Reassessing&lt;/h1&gt;
&lt;p&gt;SBCL indicates that the operating system is the bottleneck, but it&amp;#39;s calling &lt;code&gt;FindFirstFile&lt;/code&gt;--same as Deno. Maybe there are some &lt;em&gt;other&lt;/em&gt; system calls I didn&amp;#39;t notice?&lt;/p&gt;
&lt;p&gt;Time to just inspect the system and see what&amp;#39;s happening!&lt;/p&gt;
&lt;h2 id=&quot;debugging&quot;&gt;Debugging&lt;/h2&gt;
&lt;p&gt;I don&amp;#39;t recommend this approach, but since I already had WinDbg installed, I attached WinDbg to sbcl.exe and set a breakpoint on everything in kernel32.dll (&lt;code&gt;bm kernel32!*&lt;/code&gt;), let the program run, and kept track of which functions were hit (disabling each breakpoint afterwards).&lt;/p&gt;
&lt;p&gt;These functions sounded relevant:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FindFirstFileW&lt;/li&gt;
&lt;li&gt;GetFileAttributesExW&lt;/li&gt;
&lt;li&gt;GetLongPathNameW&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I wasn&amp;#39;t familiar with that last one (&lt;code&gt;GetLongPathName&lt;/code&gt;), but apparently it&amp;#39;s for &lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getlongpathnamea&quot;&gt;converting from &amp;quot;short&amp;quot; (DOS-style 8.3) file names (e.g. &amp;quot;progra~1&amp;quot;) to &amp;quot;long&amp;quot; file names&lt;/a&gt;. Honestly, this is the first time I&amp;#39;ve had to think about short file names in at least a decade.&lt;/p&gt;
&lt;p&gt;New question: &lt;strong&gt;which (if any) of these functions is slow?&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-performance-recorderanalyzer&quot;&gt;Windows Performance Recorder/Analyzer&lt;/h2&gt;
&lt;p&gt;In the past, I&amp;#39;ve used &lt;a href=&quot;https://learn.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-analyzer&quot;&gt;Windows Performance Analyzer&lt;/a&gt; for this sort of problem. Conveniently, &lt;strong&gt;Microsoft now bundles Windows Performance Analyzer (a 15 MB tool) along with a million other things I doubt I&amp;#39;ll ever use in a tidy little 4 GB download&lt;/strong&gt;. I&amp;#39;d think it would be in their best interest to separate these tools in order to reduce the bandwidth needed to deliver basic performance analysis tools, but what do I know?&lt;/p&gt;
&lt;p&gt;Using Windows Performance Recorder&amp;#39;s generic profile, I captured a several second trace of file enumeration via SBCL. Opening the trace and looking at the &amp;quot;CPU Usage (Sampled)&amp;quot; chart (and filtering to &amp;quot;sbcl.exe&amp;quot;--with symbol loading enabled), I see the following sample counts by stack:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;Line #, Process, Stack, Count
1, sbcl.exe (34020), , 1581
2, , [Root], 1579
3, ,   |- ?!?, 1576
4, ,   |    |- kernel32.dll!GetLongPathNameW, 1299
5, ,   |    |- KernelBase.dll!GetFileAttributesExW, 155
6, ,   |    |- ?!?&amp;lt;itself&amp;gt;, 75
7, ,   |    |- KernelBase.dll!FindNextFileW, 16
8, ,   |    |- KernelBase.dll!FindFirstFileW, 14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks like the vast majority of samples are in &lt;code&gt;GetLongPathName&lt;/code&gt;, with a significant chunk in &lt;code&gt;GetFileAttributesEx&lt;/code&gt;. I&amp;#39;m still not entirely clear why these are necessary. Maybe the Common Lisp spec specifies that &lt;code&gt;DIRECTORY&lt;/code&gt; must return absolute paths? I don&amp;#39;t see anything like that in the &lt;a href=&quot;http://clhs.lisp.se/Body/f_dir.htm&quot;&gt;Common Lisp HyperSpec entry for DIRECTORY&lt;/a&gt;, but I definitely don&amp;#39;t know what I&amp;#39;m talking about, so I&amp;#39;ll just stop speculating.&lt;/p&gt;
&lt;h2 id=&quot;debugging-sbcl-with-itself&quot;&gt;Debugging SBCL with itself&lt;/h2&gt;
&lt;p&gt;While exploring &lt;a href=&quot;https://github.com/sbcl/sbcl/blob/a9abb1c41c457e9299b53f75b4196d3014432c9b/src/code/win32.lisp&quot;&gt;SBCL&amp;#39;s Win32 code&lt;/a&gt;, I decided to try debugging SBCL using itself:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Download a copy of SBCL 2.3.2&amp;#39;s source code&lt;/li&gt;
&lt;li&gt;Open it in Emacs (with SLIME)&lt;/li&gt;
&lt;li&gt;Add a call to &lt;code&gt;BREAK&lt;/code&gt; within a function of interest&lt;/li&gt;
&lt;li&gt;Ctrl+C, Ctrl+C to recompile the function&lt;/li&gt;
&lt;li&gt;Run file enumeration code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The breakpoint was hit! Of course, after that I tried to remove the breakpoint and recompile, but the recompilation process started hitting breakpoints related to the function of SLIME/SBCL itself. So maybe messing with SBCL&amp;#39;s internals isn&amp;#39;t always a great approach. It&amp;#39;s still neat that you can tinker with SBCL&amp;#39;s internals without any external tools (Emacs+SLIME make it easier, but are not &lt;em&gt;required&lt;/em&gt;).&lt;/p&gt;
&lt;h1 id=&quot;solution&quot;&gt;Solution?&lt;/h1&gt;
&lt;h2 id=&quot;initial-attempt&quot;&gt;Initial attempt&lt;/h2&gt;
&lt;p&gt;As an initial attempt to speed up file enumeration, I decided to just directly call SBCL&amp;#39;s internal Win32 function that uses &lt;code&gt;FindFirstFile&lt;/code&gt;/&lt;code&gt;FindNextFile&lt;/code&gt;. The function is named &lt;code&gt;native-call-with-directory-iterator&lt;/code&gt;, and here&amp;#39;s the (surprisingly readable, other than the convoluted callback convention) definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;defun&lt;/span&gt; native-call-with-directory-iterator (&lt;span class=&quot;hljs-name&quot;&gt;function&lt;/span&gt; namestring errorp)
  (&lt;span class=&quot;hljs-name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;type&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;or&lt;/span&gt; null string) namestring)
           (&lt;span class=&quot;hljs-name&quot;&gt;function&lt;/span&gt; function))
  (&lt;span class=&quot;hljs-name&quot;&gt;when&lt;/span&gt; namestring
    (&lt;span class=&quot;hljs-name&quot;&gt;with-alien&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;find-data&lt;/span&gt; find-data))
      (&lt;span class=&quot;hljs-name&quot;&gt;with-handle&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;handle&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;syscall&lt;/span&gt; ((&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;FindFirstFile&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;t&lt;/span&gt;) handle
                                     system-string find-data)
                                    (&lt;span class=&quot;hljs-name&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;eql&lt;/span&gt; result invalid-handle)
                                        (&lt;span class=&quot;hljs-name&quot;&gt;if&lt;/span&gt; errorp
                                            (&lt;span class=&quot;hljs-name&quot;&gt;win32-error&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;FindFirstFile&amp;quot;&lt;/span&gt;)
                                            (&lt;span class=&quot;hljs-name&quot;&gt;return&lt;/span&gt;))
                                        result)
                                    (&lt;span class=&quot;hljs-name&quot;&gt;concatenate&lt;/span&gt; &amp;#x27;string
                                                 namestring &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;*.*&amp;quot;&lt;/span&gt;)
                                    find-data)
                    &lt;span class=&quot;hljs-symbol&quot;&gt;:close-operator&lt;/span&gt; find-close)
        (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;t&lt;/span&gt;))
          (&lt;span class=&quot;hljs-name&quot;&gt;dx-flet&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;one-iter&lt;/span&gt; ()
                      (&lt;span class=&quot;hljs-name&quot;&gt;tagbody&lt;/span&gt;
                       &lt;span class=&quot;hljs-symbol&quot;&gt;:next&lt;/span&gt;
                         (&lt;span class=&quot;hljs-name&quot;&gt;when&lt;/span&gt; more
                           (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;decode-system-string&lt;/span&gt;
                                        (&lt;span class=&quot;hljs-name&quot;&gt;slot&lt;/span&gt; find-data &amp;#x27;long-name)))
                                 (&lt;span class=&quot;hljs-name&quot;&gt;attributes&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;slot&lt;/span&gt; find-data &amp;#x27;attributes)))
                             (&lt;span class=&quot;hljs-name&quot;&gt;setf&lt;/span&gt; more
                                   (&lt;span class=&quot;hljs-name&quot;&gt;syscall&lt;/span&gt; ((&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;FindNextFile&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;t&lt;/span&gt;) lispbool
                                             handle find-data) result
                                             handle find-data))
                             (&lt;span class=&quot;hljs-name&quot;&gt;cond&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;equal&lt;/span&gt; name &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;) (&lt;span class=&quot;hljs-name&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:next&lt;/span&gt;))
                                   ((&lt;span class=&quot;hljs-name&quot;&gt;equal&lt;/span&gt; name &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;..&amp;quot;&lt;/span&gt;) (&lt;span class=&quot;hljs-name&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:next&lt;/span&gt;))
                                   (&lt;span class=&quot;hljs-name&quot;&gt;t&lt;/span&gt;
                                    (&lt;span class=&quot;hljs-name&quot;&gt;return-from&lt;/span&gt; one-iter
                                      (&lt;span class=&quot;hljs-name&quot;&gt;values&lt;/span&gt; name
                                              (&lt;span class=&quot;hljs-name&quot;&gt;attribute-file-kind&lt;/span&gt;
                                               attributes))))))))))
            (&lt;span class=&quot;hljs-name&quot;&gt;funcall&lt;/span&gt; function #&amp;#x27;one-iter)))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Interestingly, the callback receives both the file system item&amp;#39;s name, as well as its &amp;quot;kind&amp;quot; (&lt;code&gt;:file&lt;/code&gt; or &lt;code&gt;:directory&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s my sloppy code (note to self: make it more obvious which variables are &amp;quot;namestrings&amp;quot; versus &amp;quot;pathnames&amp;quot;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;defun&lt;/span&gt; for-each-item-in-directory (&lt;span class=&quot;hljs-name&quot;&gt;function&lt;/span&gt; directory)
  &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Calls FUNCTION with (string, (or :file :directory)) for each item in DIRECTORY&amp;quot;&lt;/span&gt;
  (&lt;span class=&quot;hljs-name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;type&lt;/span&gt; function function))
  (&lt;span class=&quot;hljs-name&quot;&gt;sb-win32&lt;/span&gt;:&lt;span class=&quot;hljs-symbol&quot;&gt;:native-call-with-directory-iterator&lt;/span&gt;
   (&lt;span class=&quot;hljs-name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;next&lt;/span&gt;)
     (&lt;span class=&quot;hljs-name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;type&lt;/span&gt; function next))
     (&lt;span class=&quot;hljs-name&quot;&gt;loop&lt;/span&gt; for (&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt; kind) = (&lt;span class=&quot;hljs-name&quot;&gt;multiple-value-list&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;funcall&lt;/span&gt; next))
           while name
           do (&lt;span class=&quot;hljs-name&quot;&gt;funcall&lt;/span&gt; function name kind)))
   (&lt;span class=&quot;hljs-name&quot;&gt;namestring&lt;/span&gt; directory)
   &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;))

(&lt;span class=&quot;hljs-name&quot;&gt;defun&lt;/span&gt; enumerate-files (&lt;span class=&quot;hljs-name&quot;&gt;directory&lt;/span&gt;)
  (&lt;span class=&quot;hljs-name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;type&lt;/span&gt; pathname directory))
  (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;items&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;list&lt;/span&gt; directory))
        (&lt;span class=&quot;hljs-name&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;))
    (&lt;span class=&quot;hljs-name&quot;&gt;loop&lt;/span&gt; while items do
      (&lt;span class=&quot;hljs-name&quot;&gt;let&lt;/span&gt; ((&lt;span class=&quot;hljs-name&quot;&gt;item&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;pop&lt;/span&gt; items)))
        (&lt;span class=&quot;hljs-name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;type&lt;/span&gt; pathname item))
        (&lt;span class=&quot;hljs-name&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;pathname-name&lt;/span&gt; item)
            (&lt;span class=&quot;hljs-name&quot;&gt;push&lt;/span&gt; item files)
            (&lt;span class=&quot;hljs-name&quot;&gt;for-each-item-in-directory&lt;/span&gt;
             (&lt;span class=&quot;hljs-name&quot;&gt;lambda&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt; kind)
               (&lt;span class=&quot;hljs-name&quot;&gt;push&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;merge-pathnames&lt;/span&gt;
                      (&lt;span class=&quot;hljs-name&quot;&gt;ecase&lt;/span&gt; kind
                        (&lt;span class=&quot;hljs-symbol&quot;&gt;:file&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;parse-namestring&lt;/span&gt; name))
                        (&lt;span class=&quot;hljs-symbol&quot;&gt;:directory&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;make-pathname&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:directory&lt;/span&gt; (&lt;span class=&quot;hljs-name&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:relative&lt;/span&gt; name))))
                      item)
                     items))
             item))))
    files))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, the moment of truth when I run this modified function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;Evaluation took:
  0.002 seconds of real time
  0.015625 seconds of total run time (0.000000 user, 0.015625 system)
  800.00% CPU
  7,000,104 processor cycles
  65,200 bytes consed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;That&amp;#39;s a 27x speedup!&lt;/strong&gt; And, other than returning relative paths instead of absolute paths (a detail which doesn&amp;#39;t currently matter to me), the output looks the same. Even better, there might be more opportunities for improvement in my scenario:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&amp;#39;ll likely need the &amp;quot;last modified&amp;quot; time of each time, but it looks like &lt;code&gt;FindFirstFile&lt;/code&gt; already provides that value&lt;/li&gt;
&lt;li&gt;There is a &lt;code&gt;FindFirstFileEx&lt;/code&gt;, with some (Windows 7+) optimization flags&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, to do all this &lt;em&gt;correctly&lt;/em&gt; (i.e. portably), I should use CFFI instead of SBCL-internal functions. But I don&amp;#39;t know how to do that yet.&lt;/p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Reducing file enumeration down to 2 milliseconds gives me some breathing room in my 50-ish millisecond budget. This is fortunate in the sense that I might end up with something useful, but unfortunate in the sense that I can no longer be satisfied with immediately discarding this project as obviously infeasible.&lt;/p&gt;
&lt;p&gt;Looks like I&amp;#39;ve got some more work to do...&lt;/p&gt;
</content>
</entry>
<entry>
<title>Building the fastest static site generator... or not</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-4.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-4.html"/>
<updated>2023-11-08T00:00:00.000Z</updated>
<summary type="text">This is a personal anecdote about the struggle to avoid over-engineering a static site generator.</summary>
<content type="html">&lt;p&gt;Well, I did it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I have successfully staved off the urge (at least temporarily) to create &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/pre-markdown.html&quot;&gt;yet&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-design.html&quot;&gt;another&lt;/a&gt; static site generator&lt;/strong&gt; by instead making &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt; (my zero-config dev blog generator) &lt;em&gt;just fast enough&lt;/em&gt; for my workflow that it seems pointless to bother improving upon its performance.&lt;/p&gt;
&lt;p&gt;Spoiler: adding trivial caching and bypassing the file system shrunk live rebuild times by ~80%--down to &lt;strong&gt;50 milliseconds&lt;/strong&gt; on my (decade old) desktop computer. Updates now appear in roughly the amount of time it takes me to shift the focus of my eyes from my text editor to the adjacent browser.&lt;/p&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;Possibly as a reaction to &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../game-development/web-game-on-steam-for-linux-2.html&quot;&gt;releasing a piece of software based on Electron&lt;/a&gt;, I&amp;#39;ve been playing with a &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-4.html&quot;&gt;minimal development environment, running on an old netbook&lt;/a&gt;. Unfortunately, my static site generator was taking roughly 6 seconds (on the netbook) to perform live rebuilds of my site (~90 pages), and I&amp;#39;m generally not patient with poorly optimized software.&lt;/p&gt;
&lt;p&gt;Fortunately, after &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html&quot;&gt;a few tweaks&lt;/a&gt;, I was able to reduce that time down to around 900 milliseconds. Sub-second updates are acceptable (impressive, even--on a netbook), but I couldn&amp;#39;t shake the feeling that it could be &lt;em&gt;a lot&lt;/em&gt; faster.&lt;/p&gt;
&lt;h1 id=&quot;plans-for-a-new-static-site-generator&quot;&gt;Plans for a new static site generator&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;The most obvious way to speed up rebuilds of a static site is to avoid doing unnecessary work&lt;/strong&gt;. Given that &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html&quot;&gt;a previous experiment of mine&lt;/a&gt; showed it was only necessary to rebuild roughly 5 pages when updating (or adding) a single blog post, I started making plans for an extensible static site generator (similar to &lt;a href=&quot;https://github.com/jaredkrinke/goldsmith&quot;&gt;Goldsmith&lt;/a&gt;/&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt;) &lt;em&gt;with an accurate dependency graph&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Since I&amp;#39;m &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Lisp&lt;/a&gt;, I started planning to rebuild md2blog in Common Lisp. With an accurate dependency graph, compilation to native code, and the ability to process Markdown/syntax highlighting in parallel, I was fairly certain I could significantly improve live rebuild times.&lt;/p&gt;
&lt;p&gt;Additionally, Common Lisp would trivially allow for beautiful s-expression-based templates, interactive debugging and introspection, and even automatic detection of pipeline/code updates.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I could build the most extensible--and fastest--static site generator ever!&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;or-i-could-do-something-else&quot;&gt;Or I could do something else&lt;/h1&gt;
&lt;p&gt;But I already have a perfectly functional (and tolerably fast) static site generator. &lt;strong&gt;And I&amp;#39;m (nearly) the only user&lt;/strong&gt;. Is it really a good use of my time to build the same thing, just faster and in Lisp? It would certainly be educational, and a great way to learn Common Lisp, but finding Common Lisp libraries for Markdown processing, syntax highlighting, JSON validation, cache storage, and file system monitoring sounds... daunting.&lt;/p&gt;
&lt;p&gt;I still maintain that static site generators are a perfect first project for learning a programming language (and its ecosystem). It forces you to interact with the file system, understand data flows, find relevant libraries, and maybe even build a web server. In the end, you can produce a fast and efficient web site.&lt;/p&gt;
&lt;p&gt;But I&amp;#39;ve already done this at least four times and I&amp;#39;m probably past the point of diminishing returns. Is this a project that&amp;#39;s really worth spending a few weeks of my spare time on?&lt;/p&gt;
&lt;p&gt;Analogous to speeding up a static site generator, &lt;strong&gt;the most obvious way to speed up a &lt;em&gt;software project&lt;/em&gt; is to avoid doing unnecessary work&lt;/strong&gt; (i.e. avoid starting over from scratch). So I refocused my efforts on wringing maximal performance from md2blog, while staying within its existing design constraints.&lt;/p&gt;
&lt;h2 id=&quot;an-epiphany-around-caching&quot;&gt;An epiphany around caching&lt;/h2&gt;
&lt;p&gt;What if, instead of making a really smart cache, I made a really dumb one?&lt;/p&gt;
&lt;p&gt;While planning a scheme for reliably caching the results of arbitrary steps in the processing pipeline (specifically, deciding between simply using files&amp;#39; &amp;quot;last modified time&amp;quot; vs. using their actual content--or a hash--to detect changes), I realized that &lt;strong&gt;most of the challenges evaporated if I scoped the cache a single run of the tool&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As noted in a previous post, my primary performance-sensitive workflow is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run md2blog as a live-reloading server&lt;/li&gt;
&lt;li&gt;Edit a blog post&lt;/li&gt;
&lt;li&gt;Hit Ctrl+S in my text editor&lt;/li&gt;
&lt;li&gt;Wait for updated content to render in my browser&lt;/li&gt;
&lt;li&gt;Go to 2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I.e. &lt;strong&gt;it&amp;#39;s all one run of md2blog&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As an experiment, I added a trivial in-memory Markdown cache and found that this One Weird Trick removed plugin processing as the primary bottleneck. The largest remaining bottleneck was the file system itself (writing out all the file contents to disk).&lt;/p&gt;
&lt;h2 id=&quot;an-epiphany-around-the-file-system&quot;&gt;An epiphany around the file system&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Why am I even waiting on the file system?&lt;/strong&gt; md2blog reads in files and then all subsequent processing is done in memory. Since I&amp;#39;m already running my own web server, &lt;strong&gt;I can just serve HTTP requests straight out of memory&lt;/strong&gt; while files are written to disk in the background!&lt;/p&gt;
&lt;p&gt;That removed the final obvious bottleneck.&lt;/p&gt;
&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s a table of approximate &amp;quot;live rebuild&amp;quot; times from:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;md2blog 1.1.1: no optimizations whatsoever&lt;/li&gt;
&lt;li&gt;md2blog 1.2.0: syntax highlighting cached and link-checking moved to the background&lt;/li&gt;
&lt;li&gt;md2blog 1.2.2 (new): Markdown cached and file system output moved to the background&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;md2blog version&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Netbook (ms)&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Desktop (ms)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v1.1.1&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;6000&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1.2.0&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;900&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;190&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1.2.2&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;200&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;As noted in the spoiler, on my desktop computer (with an 11 year-old processor), updates appear almost instantaneously (fortunately, my site has simple HTML and no JavaScript, so rendering is also fast).&lt;/p&gt;
&lt;p&gt;I&amp;#39;m fairly certain this is still &lt;em&gt;not&lt;/em&gt; the fastest static site generator in existence. Maybe the fastest full-featured, JavaScript-based one? Regardless, it is clearly &lt;em&gt;fast enough&lt;/em&gt;--at least for now.&lt;/p&gt;
</content>
</entry>
</feed>
