<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Mon, 04 Oct 2021 18:51:32 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Syntax highlighting for a static site built with Metalsmith]]></title><description><![CDATA[<p>As <a href="../metalsmith/">described previously</a>, I&#39;m using <a href="https://metalsmith.io/">Metalsmith</a> to build my static site because I like its modular, easy to extend design (even though it required more effort to setup initially).</p>
<p>Here&#39;s how I integrated <a href="https://highlightjs.org/">highlight.js</a> syntax highlighting into my static builds.</p>
<h1 id="marked">Marked</h1>
<p>Metalsmith&#39;s official Markdown plug, <a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a> uses <a href="https://marked.js.org/">Marked</a> for converting Markdown into HTML. Note that the plugin uses a fairly old version of Marked: 0.7.0. Fortunately, Marked has <a href="https://marked.js.org/using_advanced#highlight">convenient support for integrating syntax highlighting</a>.</p>
<h1 id="highlightjs">highlight.js</h1>
<p>Since I&#39;m working within the Node/NPM ecosystem, I decided to try <a href="https://highlightjs.org/">highlight.js</a>, because it&#39;s conveniently implemented in JavaScript (no manual compilation required). I suspect a native highlighting library would be faster, but I&#39;d rather optimize later, if needed, than waste time upfront.</p>
<h1 id="build-script-integration">Build script integration</h1>
<p>First step (after installing highlight.js via NPM: <code>npm install --save highlight.js</code>) is to use the documentation above to integrate highlight.js into my build script. This turned out to be fairly easy:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> highlight <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;highlight.js&quot;</span>;
...
<span class="hljs-comment">// Configure syntax highlighting aliases</span>
highlight.<span class="hljs-title function_">registerAliases</span>(<span class="hljs-string">&quot;wasm&quot;</span>, { <span class="hljs-attr">languageName</span>: <span class="hljs-string">&quot;lisp&quot;</span> });
...
<span class="hljs-title class_">Metalsmith</span>(__dirname)
...
    .<span class="hljs-title function_">use</span>(<span class="hljs-title function_">markdown</span>({
        <span class="hljs-attr">highlight</span>: <span class="hljs-function">(<span class="hljs-params">code, language</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (language) {
                <span class="hljs-keyword">return</span> highlight.<span class="hljs-title function_">highlight</span>(code, { language }).<span class="hljs-property">value</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> highlight.<span class="hljs-title function_">highlightAuto</span>(code).<span class="hljs-property">value</span>;
            }
        },
    }))
...</code></pre>
<p>Notes:</p>
<ul>
<li>I&#39;m using <code>import</code> instead of <code>require</code> to experiment with ES modules (<a href="../../javascript/using-commonjs-modules-from-es-modules/">Node supports loading CommonJS modules with <code>import</code></a>)</li>
<li>highlight.js <a href="https://highlightjs.org/static/demo/">supports a lot of languages</a>, but not WebAssembly, so I set up an alias that let&#39;s me mark code blocks as &quot;wasm&quot; and they&#39;ll be highlighted using Lisp s-expression syntax</li>
<li>highlight.js can auto-detect languages, so I use <code>highlightAuto</code> in cases where no programming language is explicitly specified</li>
</ul>
<p>So far, so good.</p>
<h1 id="theming">Theming</h1>
<p>Now, on to the annoying part: theming!</p>
<p>I kind of expected this, but <a href="https://highlightjs.readthedocs.io/en/latest/theme-guide.html#">creating a theme</a> (mostly from scratch) for highlight.js is fairly tedious. The <a href="https://highlightjs.readthedocs.io/en/latest/css-classes-reference.html">list of &quot;scopes&quot;</a> (i.e. classes of tokens) is long, and some are even nested. For example, the name of a function gets the following CSS classes applied: &quot;hljs-title function_&quot;.</p>
<p>To tweak a theme, the best approach I can recommend here is:</p>
<ol>
<li>Run highlight.js on some code</li>
<li>Inspect the output HTML (specifically the CSS classes)</li>
<li>Add/update your CSS rules</li>
<li>Repeat</li>
</ol>
<p>I had hoped that I could just take an existing theme and modify it slightly, but I couldn&#39;t find a theme that didn&#39;t group scopes in unappealing ways (e.g. grouping macros/templates with literals).</p>
<h1 id="my-final-css">My &quot;final&quot; CSS</h1>
<p>After a lot of trial and error, below is the CSS I came up with, using colors that are mostly already present on my site. I grouped the rules by color.</p>
<p>I&#39;m sure this theme doesn&#39;t cover all languages well, so I&#39;ll likely need to tweak it a few times in the future, but it seems adequate for all the code I&#39;ve thrown at it thus far.</p>
<pre><code class="language-css"><span class="hljs-comment">/* Syntax highlighting */</span>
<span class="hljs-selector-class">.hljs-comment</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#5a8c3f</span>; }

<span class="hljs-selector-class">.hljs-tag</span>,
<span class="hljs-selector-class">.hljs-punctuation</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>; }

<span class="hljs-selector-class">.hljs-literal</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#66c9fe</span>; }

<span class="hljs-selector-class">.hljs-title</span><span class="hljs-selector-class">.class_</span>,
<span class="hljs-selector-class">.hljs-tag</span> <span class="hljs-selector-class">.hljs-name</span>,
<span class="hljs-selector-class">.hljs-tag</span> <span class="hljs-selector-class">.hljs-attr</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#7bbf56</span>; }

<span class="hljs-selector-class">.hljs-attr</span>,
<span class="hljs-selector-class">.hljs-symbol</span>,
<span class="hljs-selector-class">.hljs-variable</span>,
<span class="hljs-selector-class">.hljs-template-variable</span>,
<span class="hljs-selector-class">.hljs-link</span>,
<span class="hljs-selector-class">.hljs-selector-attr</span>,
<span class="hljs-selector-class">.hljs-selector-pseudo</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#59c5ff</span>; }

<span class="hljs-selector-class">.hljs-keyword</span>,
<span class="hljs-selector-class">.hljs-attribute</span>,
<span class="hljs-selector-class">.hljs-selector-tag</span>,
<span class="hljs-selector-class">.hljs-meta</span> <span class="hljs-selector-class">.hljs-keyword</span>,
<span class="hljs-selector-class">.hljs-doctag</span>,
<span class="hljs-selector-class">.hljs-name</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#51a1cc</span>; }

<span class="hljs-selector-class">.hljs-type</span>,
<span class="hljs-selector-class">.hljs-string</span>,
<span class="hljs-selector-class">.hljs-number</span>,
<span class="hljs-selector-class">.hljs-quote</span>,
<span class="hljs-selector-class">.hljs-template-tag</span>,
<span class="hljs-selector-class">.hljs-deletion</span>,
<span class="hljs-selector-class">.hljs-title</span>,
<span class="hljs-selector-class">.hljs-section</span>,
<span class="hljs-selector-class">.hljs-meta</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#d97c57</span>; }

<span class="hljs-selector-class">.hljs-regexp</span>,
<span class="hljs-selector-class">.hljs-meta</span> <span class="hljs-selector-class">.hljs-string</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#b25947</span>; }

<span class="hljs-selector-class">.hljs-title</span><span class="hljs-selector-class">.function_</span>,
<span class="hljs-selector-class">.hljs-built_in</span>,
<span class="hljs-selector-class">.hljs-bullet</span>,
<span class="hljs-selector-class">.hljs-code</span>,
<span class="hljs-selector-class">.hljs-addition</span>,
<span class="hljs-selector-class">.hljs-selector-id</span>,
<span class="hljs-selector-class">.hljs-selector-class</span> { <span class="hljs-attribute">color</span>: <span class="hljs-number">#e6b95c</span>; }</code></pre>
<h1 id="performance">Performance</h1>
<p>On my code-heavy, but tiny, site, I measured the following build times with and without syntax highlighting:</p>
<table>
<thead>
<tr>
<th align="left">Scenario</th>
<th align="right">Build time (s)</th>
<th align="right">Avg. time per page (ms)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Without highlighting</td>
<td align="right">1.4</td>
<td align="right">67</td>
</tr>
<tr>
<td align="left">With highlighting</td>
<td align="right">2.2</td>
<td align="right">105</td>
</tr>
</tbody></table>
<p>For me, on this machine, the overhead of syntax highlighting is roughly 40ms/page. This is certainly tolerable for my small site. I&#39;ll revisit the decision to use a JavaScript-based highlighter in the future, if needed. But for now, this is sufficient.</p>
<h1 id="the-end">The end</h1>
<p>Despite griping about theming, I&#39;m impressed with how smoothly everything integrated. Adding working syntax highlighting to a static site in a single sitting shows how productive modern software stacks can be.</p>
<p>I&#39;ll end the post with some examples of syntax highlighting in a few languages I&#39;ve already used on this site.</p>
<h2 id="syntax-highlighting-examples">Syntax highlighting examples</h2>
<h3 id="javascript">JavaScript</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));
})();</code></pre>
<h3 id="c">C</h3>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(add)</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<h3 id="webassembly">WebAssembly</h3>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">))</span></code></pre>
<h3 id="html">HTML</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of 2 + 2 is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith-syntax-highlighting</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith-syntax-highlighting</guid><pubDate>Fri, 01 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Can you use CommonJS modules from within an ES module?]]></title><description><![CDATA[<h1 id="question">Question</h1>
<p>Is it possible to import a CommonJS module from within an ES module (using <code>import</code> syntax)?</p>
<p>I thought a quick web search would answer this question, but instead most of the resources I found were about trying to <code>require()</code> ES modules (which you definitely can&#39;t do--use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports">dynamic import</a> instead).</p>
<h1 id="background">Background</h1>
<p>JavaScript didn&#39;t originally have a module system, so various groups have created their own systems, e.g. <a href="http://www.commonjs.org/">CommonJS</a>, <a href="https://github.com/amdjs/amdjs-api">Asynchronous Module Definition (AMD)</a>, and the ironically named <a href="https://github.com/umdjs/umd">Universal Module Definition (UMD)</a>.</p>
<p>Predictably, there&#39;s now an official <a href="https://tc39.es/ecma262/#sec-modules">ECMAScript Modules</a> format that <del>everyone uses</del> <del>everyone should use</del> some people have started using (<del>because it&#39;s incompatible and they have no choice</del> because it&#39;s part of the official JavaScript/ECMAScript specification). And I won&#39;t even dig into the ES module file extension dumpster fire.</p>
<p>Anyway, back to the question: can I import a CommonJS module into my ES module?</p>
<h1 id="lets-just-try-it">Let&#39;s just try it...</h1>
<p>Here&#39;s a CommonJS module:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">test</span> = <span class="hljs-string">&quot;works!&quot;</span>;</code></pre>
<h2 id="proof-that-it-works-from-commonjs-in-node-✔">Proof that it works from CommonJS (in Node) ✔</h2>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { test } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./test.js&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test);</code></pre>
<p>Output: <code>works!</code></p>
<h2 id="how-about-from-an-es-module-in-node-✔">How about from an ES module in Node? ✔</h2>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test);</code></pre>
<p>Output: <code>works!</code></p>
<h2 id="how-about-from-an-es-module-in-a-web-page-✖">How about from an ES module in a web page? ✖</h2>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Output: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
            <span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./test.js&quot;</span>;

            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = test;
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Doesn&#39;t work (error: &quot;The requested module &#39;./test.js&#39; does not provide an export named &#39;test&#39;&quot;).</p>
<h1 id="final-answer">Final answer</h1>
<p>You can use <code>import</code> to include a CommonJS module <em>when running in Node</em>, but <em>not</em> when running in a web page.</p>
]]></description><link>https://log.schemescape.com/posts/javascript/using-commonjs-modules-from-es-modules</link><guid isPermaLink="true">https://log.schemescape.com/posts/javascript/using-commonjs-modules-from-es-modules</guid><pubDate>Wed, 29 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly and the C standard library]]></title><description><![CDATA[<p>In the <a href="../trivial-example/">last post</a>, I compiled a trivial C function to WebAssembly. This was a good learning exercise, but I didn&#39;t use the C standard library, so compiling the code was trivial. Let&#39;s look into how to use the C standard library when compiling C to WebAssembly with Clang/LLVM. All the code is in this repository: <a href="https://github.com/jaredkrinke/webassembly-libc-example">webassembly-libc-example</a>.</p>
<h1 id="is-this-even-a-good-idea">Is this even a good idea?</h1>
<p>WebAssembly is simple, which is nice for getting started. It&#39;s also extremely limited (at least, in the browser). In order to compile typical C code to WebAssembly, you need a C standard library.</p>
<p>Obviously, the browser doesn&#39;t supply a C run time to WebAssembly modules (any language could be compiled to WebAssembly), so that means that the module itself has to include all the functionality it uses from the C library within itself (or get it from another module). In other words, it&#39;s statically linked.</p>
<p>How much overhead is including the C library in every module going to add? That&#39;s a good question, that I&#39;m hoping to answer eventually.</p>
<h1 id="which-c-library-to-use">Which C library to use?</h1>
<p>Here are a few promising leads on a WebAssembly-friendly C library (either already compiled to WebAssembly or simple enough that there&#39;s hope I could compile to WebAssembly myself):</p>
<ul>
<li><a href="https://github.com/emscripten-core/emscripten">Emscripten</a>: Modified version of <a href="https://musl.libc.org/">musl libc</a> that can run in a browser</li>
<li><a href="https://github.com/WebAssembly/wasi-libc">WASI libc</a>: Also built on musl (I think), but designed to run on top of <a href="https://wasi.dev/">WASI</a>--I didn&#39;t think this would run in the browser, but <a href="https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/">this blog post indicates otherwise</a></li>
<li><a href="https://github.com/embeddedartistry/libc">Embedded Artistry libc</a>: Designed for embedded applications; I&#39;m hoping this would be easy to bring up on a new platform like WebAssembly</li>
<li><strong>Build your own!</strong> If you only need a handful of functions, maybe you can implement them yourself (here&#39;s <a href="https://dassur.ma/things/c-to-webassembly/">one great example with a trivial allocator</a>)</li>
</ul>
<p>I&#39;m going to continue avoiding Emscripten because a) it wants me to install Python first and b) I&#39;d like to keep things as simple as possible. I didn&#39;t think WASI&#39;s C library would work for me in the browser, but I&#39;m going to try it anyway.</p>
<h1 id="setup-for-wasi-libc">Setup for WASI libc</h1>
<p>In order to compile against a C library, you need header files and compiled objects (in an archive) or a shared library (a concept that I don&#39;t think exists for WebAssembly since they use modules for that purpose). Note that we&#39;re basically cross-compiling for a different architecture.</p>
<p>Fortunately, <a href="https://github.com/WebAssembly/wasi-sdk">WASI provides an SDK for exactly this purpose</a>. I downloaded the latest release (~140 MB) and took a peek at the contents:</p>
<ul>
<li><code>bin/</code>: Oh, look, Clang and LLVM -- I guess I should have just started here!</li>
<li><code>lib/clang/11.0.0/lib/wasi/libclang_rt.builtins-wasm32.a</code>: This archive contains WebAssembly implementations of so-called &quot;builtins&quot; that <a href="https://releases.llvm.org/11.0.0/tools/clang/docs/Toolchain.html">Clang implicitly requires</a></li>
<li><code>share/wasi-sysroot</code>: System root for the cross compiler, containing all the headers and libraries (all raw objects or archives)</li>
</ul>
<p>Note that the version of LLVM that I installed in my last post didn&#39;t come from the WASI SDK and it didn&#39;t contain the &quot;builtins&quot; archive noted above. In order to use that installation of Clang/LLVM, I needed to copy <code>libclang_rt.builtins-wasm32.a</code> into my installation (fortunately the eventual error message you see provides the exact destination path).</p>
<h1 id="a-slightly-less-trivial-example">A slightly less trivial example</h1>
<h2 id="source-code">Source code</h2>
<p>Here&#39;s the C source for my test module that uses the WASI C library (<code>sine.c</code>):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">double</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(sine)</span><span class="hljs-params">(<span class="hljs-type">double</span> theta)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sin</span>(theta);
}</code></pre>
<p>All I&#39;m doing is exposing <code>sin</code> from <code>math.h</code> as an export named <code>sine</code>.</p>
<h2 id="compiling">Compiling</h2>
<p>The build command is a bit more complicated than <a href="../trivial-example/#compiling-the-code">last time</a>:</p>
<ul>
<li><code>-nostdlib</code> is gone since we&#39;re using the C standard library this time</li>
<li><code>-nostartfiles</code> is present because we don&#39;t need to link in any bootstrapping entry point to call <code>main()</code> (we don&#39;t have a <code>main()</code>)</li>
<li><code>-target wasm32-wasi</code> could be updated to specify the &quot;operating system&quot; (used loosely here) as WASI</li>
<li><code>--sysroot wasi-sdk-12.0/share/wasi-sysroot</code> to point to the cross-compiler system root that came from the WASI SDK</li>
</ul>
<p>Note that in this example, I extracted the WASI SDK into a subfolder of my project (the <a href="https://github.com/WebAssembly/wasi-sdk">SDK&#39;s README has an example as well</a>).</p>
<p>Here&#39;s the build command (note: I omitted the <code>-target</code> option because I&#39;m using the WASI SDK&#39;s Clang, which defaults to targeting <code>wasm32-wasi</code>):</p>
<pre><code class="language-sh">wasi-sdk-12.0\bin\clang.exe -Os --sysroot wasi-sdk-12.0/share/wasi-sysroot -nostartfiles -Wl,--no-entry sine.c -o sine.wasm</code></pre>
<h2 id="calling-from-node">Calling from Node</h2>
<p>Almost identical to last time:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./sine.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> sine = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sine</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sine</span>(<span class="hljs-number">1.57</span>));
})();</code></pre>
<p>Output: 0.9999996829318346 (looks reasonable, since 1.57 is approximately pi/2 and so sine of that angle should be roughly 1).</p>
<h2 id="calling-from-a-browser">Calling from a browser</h2>
<p>Again, almost identical:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of sin(1.57) is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./sine.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> sine = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">sine</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">sine</span>(<span class="hljs-number">1.57</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Result:</p>
<pre><code><span class="hljs-attribute">The</span> value of sin(<span class="hljs-number">1</span>.<span class="hljs-number">57</span>) is <span class="hljs-number">0</span>.<span class="hljs-number">9999996829318346</span></code></pre><p>Looks like the WASI libc works in the browser, at least in a case like this where no system calls are needed.</p>
<h1 id="overhead">Overhead</h1>
<p>Earlier, I was wondering how much overhead there is in linking against a C standard library for WebAssembly. My understanding is that linking for C is done per-function, so you&#39;re only pulling in what you need. Here are some measurements I took (and yes, I linked in <code>malloc</code> but not <code>free</code>):</p>
<table>
<thead>
<tr>
<th align="left">Dependencies</th>
<th align="right">Module size (in bytes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(none)</td>
<td align="right">207</td>
</tr>
<tr>
<td align="left"><code>sin</code></td>
<td align="right">7851</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>cos</code></td>
<td align="right">8116</td>
</tr>
<tr>
<td align="left"><code>malloc</code></td>
<td align="right">7350</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>malloc</code></td>
<td align="right">14995</td>
</tr>
</tbody></table>
<p>Not great, but also not terrible. My hope is that WebAssembly written in C <em>and using the C standard library</em> is uncommon, and generally only used for hosting programs with large C code bases that would be prohibitively time-consuming to rewrite.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, that could have gone a lot worse.</p>
<p>I&#39;m still not thrilled with the overhead of statically linking <em>everything</em>, and the thought of each module essentially having its own allocator is a bit alarming, but I need to remind myself that the alternatives are often worse. For example, if rewriting a C program in JavaScript isn&#39;t in the cards, the previous best options were either transpiling the C code to something like asm.js or, even worse, emulating an x86 CPU in the browser (using JavaScript) and running existing binaries.</p>
<p>I will state, however, that I&#39;m not quite as thrilled with the idea of compiling C programs to WebAssembly to support &quot;run anywhere&quot; scenarios as I was before I started this exercise.</p>
<h1 id="links">Links</h1>
<ul>
<li>Code: <a href="https://github.com/jaredkrinke/webassembly-libc-example">webassembly-libc-example</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-libc-example/">Live demo</a></li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/c-standard-library-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/c-standard-library-example</guid><pubDate>Tue, 28 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[A trivial WebAssembly example]]></title><description><![CDATA[<p>In the last post, I provided an <a href="../overview/">overview of WebAssembly</a>. In this post, I&#39;m going to build and run a complete (but trivial) WebAssembly module in C using <a href="https://llvm.org/">LLVM</a> and <a href="https://clang.llvm.org/">Clang</a>.</p>
<p>All of the code is here: <a href="https://github.com/jaredkrinke/webassembly-trivial-example">webassembly-trivial-example</a>.</p>
<h1 id="aside">Aside</h1>
<p>It looks like someone else was frustrated with Emscripten in the past, so they wrote a post about <a href="http://schellcode.github.io/webassembly-without-emscripten">WebAssembly without Emscripten</a>. Their guide was helpful, but I&#39;m not sure if it&#39;s up to date. I also found their Makefiles to be excessively complex.</p>
<h1 id="setup">Setup</h1>
<p>First, download and install LLVM (I used <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">LLVM 12.0.1</a>) from the LLVM GitHub releases page (note: 180 MB download that expands to <em>1.8 GB</em> installed). The programs I&#39;m actually planning to use are <code>clang</code> and <code>wasm-ld</code>.</p>
<p>I also wanted to inspect the output WebAssembly, so I needed the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>, which was a much more reasonable ~2 MB download (note: the Windows version is a gzipped tarball instead of a zip file). I&#39;m going to use <code>wasm2wat</code> for disassembly.</p>
<h2 id="some-notes-on-c">Some notes on C</h2>
<p>C compilation is usually done as follows:</p>
<ol>
<li>Run the preprocessor (<code>cpp</code>) to expand macros and includes (often on many source files)</li>
<li>Compile the preprocessed code into object files</li>
<li>Link everything into a final binary</li>
</ol>
<p>A decent overview of the most common command line arguments for a <em>different</em> compiler is <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/">here</a>. Many of the options are identical for most C compilers.</p>
<h1 id="implementing-a-trivial-function">Implementing a trivial function</h1>
<p>I&#39;m going to start with a very simple example (just to reduce the number of things that could go wrong).</p>
<h2 id="source-code">Source code</h2>
<p>File name: &quot;add.c&quot;:</p>
<pre><code class="language-c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<h2 id="compiling-the-code">Compiling the code</h2>
<p>First, I&#39;m just going to compile (but not link) the code, to see what happens.</p>
<pre><code class="language-sh">clang -target wasm32 -Os -c add.c</code></pre>
<ul>
<li><code>-target wasm32</code> tells Clang to tell LLVM to produce 32-bit WebAssembly output (note: as of today, <a href="https://github.com/WebAssembly/proposals">64-bit memory support is in progress</a>)</li>
<li><code>-Os</code> tells Clang to optimize for size (I did this in hopes of getting simpler, more readable code)</li>
<li><code>-c</code> tells Clang to compile, but not link</li>
<li><code>add.c</code> is the source file</li>
</ul>
<p>Since I&#39;m compiling and not linking, this command generates an object file named &quot;add.o&quot;.</p>
<h2 id="disassembling-the-object-file">Disassembling the object file</h2>
<p>Run the disassembler:</p>
<pre><code class="language-sh">wasm2wat add.o</code></pre>
<p>And it produces the following surprisingly readable output:</p>
<pre><code><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">))</span></code></pre><p>MDN has a great <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">explanation of the Web Assembly text format</a> (&quot;.wat&quot; files). The syntax is based on <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> (similar to <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>). Note that inline comments are delimited by semicolons (e.g. <code>; comment goes here ;</code>), as noted in <a href="https://github.com/WebAssembly/spec/blob/master/interpreter/README.md#s-expression-syntax">this more detailed look at Web Assembly text format syntax.</a>.</p>
<p>Breaking down the first two lines:</p>
<ul>
<li><code>module</code> is the root and encloses the entire module</li>
<li><code>type</code> denotes a type that can be later referenced<ul>
<li><code>(;0;)</code> is an empty list (<code>;0;</code> is just a comment) for the name of the type</li>
<li><code>func</code> denotes a function type<ul>
<li><code>param</code> denotes a list of function arguments</li>
<li><code>i32</code> is a <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> 32-bit integer<ul>
<li>Note: there is no corresponding &quot;unsigned&quot; type--instructions themselves indicate the expected sign of operands, as needed (e.g. for division)</li>
</ul>
</li>
<li><code>result</code> is a list of result values (<a href="https://github.com/WebAssembly/multi-value">support for multiple result values</a> was added in April of 2020)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So far, we have a module and an unnamed type (which can be referenced by index 0) for a function taking two 32-bit integers and returning one 32-bit integer. Moving on:</p>
<ul>
<li><code>import</code> is used to indicate data that is passed into the module from the host<ul>
<li><code>&quot;env&quot; &quot;__linear_memory&quot;</code> indicates the import is from the &quot;env&quot; module and the item being imported is &quot;__linear_memory&quot; (these are arbitrary strings that must match the instantiation code in the host)</li>
<li><code>(memory (;0;) 0)</code> specifies an unnamed memory, which must have an initial size of at least zero 64 KB pages<ul>
<li>I believe this could have been omitted from the output in this trivial example</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The host code would need to pass in a (zero-sized) memory buffer named <code>env.__linear_memory</code>. On to the actual code:</p>
<ul>
<li><code>func</code> defines a function<ul>
<li><code>$add</code> is the name of the function (names are prefixed with <code>$</code>)</li>
<li><code>(type 0)</code> refers to the type zero, defined previously: (i32, i32) =&gt; (i32)</li>
<li>The function type/signature/prototype is then specified -- I&#39;m not sure why the type needs to be duplicated here</li>
<li>The function body follows as a series of instructions (here&#39;s the <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">full list of WebAssembly instructions</a>)</li>
</ul>
</li>
</ul>
<p>Looking at the function body, note that local values are referenced by a zero-based index that starts with the function arguments and then continues on to any local variables:</p>
<ul>
<li><code>local.get 1</code> gets the second argument and pushes it onto the stack</li>
<li><code>local.get 0</code> gets the first argument and pushes it onto the stack</li>
<li><code>i32.add</code> pops the two arguments off and pushes their sum onto the stack<ul>
<li>The return value is just the last argument left on the stack, so no additional instructions are required</li>
</ul>
</li>
</ul>
<p>It looks like the C code compiled correctly and the output WAT seems reasonable. So far, so good.</p>
<h2 id="linking">Linking</h2>
<p>Note that my original Clang command specified <code>-c</code>, so it only compiled the code and never ran the linker. Let&#39;s go all the way this time:</p>
<pre><code class="language-sh">clang -target wasm32 -Os -nostdlib -Wl,--no-entry add.c -o add.wasm</code></pre>
<p>I removed <code>-c</code> and added some new arguments:</p>
<ul>
<li><code>-nostdlib</code> indicates that the C standard library should not be used (it&#39;s not needed in this case, and I don&#39;t have it available anyway)</li>
<li><code>-Wl,--no-entry</code> tells the linker that there is no entry point (i.e. no <code>main()</code> or <code>_start()</code> function)</li>
<li><code>-o add.wasm</code> tells the linker to write the output to &quot;add.wasm&quot; (instead of the default &quot;a.out&quot; file)</li>
</ul>
<p>Disassembling &quot;add.wasm&quot; yields the following:</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$__stack_pointer</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">66560</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span></code></pre>
<p>My code disappeared! Of course, this isn&#39;t surprising because my code has no entry point and doesn&#39;t export anything.</p>
<h3 id="memory-and-a-stack">Memory and a stack</h3>
<p>Interestingly, this most recent disassembly shows some other changes:</p>
<ul>
<li>A block of linear memory that starts at 2 pages long is declared</li>
<li>There is a stack pointer that is initialized to 1 KB into the second page of memory</li>
<li>This memory is exported from the module</li>
<li>The seemingly unnecessary memory <em>import</em> (<code>env.__linear_memory</code>) is no longer present</li>
</ul>
<p>I have some questions about this arrangement:</p>
<ul>
<li>Why is the memory exported? Can the host code read or even modify the stack? (Spoiler: yes)</li>
<li>Does this stack solely exist to support C semantics (e.g. taking the address of a variable on the stack)? (Probably)<ul>
<li>Note that <a href="https://github.com/WebAssembly/design/blob/main/Nondeterminism.md">this WebAssembly note</a> indicates the VM&#39;s stack can&#39;t be accessed by a program (&quot;Note that this stack isn&#39;t located in the program-accessible linear memory&quot;)</li>
</ul>
</li>
</ul>
<h3 id="aside-a-webassembly-critique">Aside: a WebAssembly critique</h3>
<p>As an aside: while trying to find answers to some of my questions, I ran across an <a href="http://troubles.md/wasm-is-not-a-stack-machine/">incredibly insightful series of posts</a> that retrospectively critiques some of WebAssembly&#39;s design decisions.</p>
<h3 id="exports">Exports</h3>
<p>Back to my trivial experiment.</p>
<p>How do I tell Clang/LLVM that I want to export a function? Consulting the <a href="https://lld.llvm.org/WebAssembly.html">linker documentation</a>, it looks like I can export everything (not my preferred approach) or specify exports either on the command line or with attributes in the code. In code, the two options appear to be:</p>
<ul>
<li>Mark exports with <code>__attribute__((export_name(&quot;nameOfExport&quot;)))</code></li>
<li>Specify <code>-Wl,--export-dynamic</code> on the Clang command line and mark exports with <code>__attribute__ ((visibility (&quot;default&quot;)))</code></li>
</ul>
<p>I kind of wish there was an &quot;always export this symbol by name&quot; option that didn&#39;t require duplicating the name. C preprocessor to the rescue!</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(add)</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
    <span class="hljs-keyword">return</span> a + b;
}</code></pre>
<p>Output:</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">local.get</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">i32.add</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">2</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">global</span> <span class="hljs-variable">$__stack_pointer</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">i32.const</span> <span class="hljs-number">66560</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;add&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$add</span><span class="hljs-punctuation">)))</span></code></pre>
<p>This looks like what I want. I&#39;ve got my function and it&#39;s being exported (along with a memory region that I&#39;m not actually using in my code).</p>
<h2 id="using-the-module">Using the module</h2>
<p>Now that I&#39;ve got my finished module (<code>add.wasm</code>), I need to host it somewhere.</p>
<h3 id="using-the-module-in-node">Using the module in Node</h3>
<p>Here&#39;s an example of loading the module and calling <code>add</code> in Node:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
    <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));
})();</code></pre>
<ul>
<li><code>await fs.promises.readFile(&quot;./add.wasm&quot;)</code> initiates a file read and resumes upon completion</li>
<li><code>const module = await WebAssembly.instantiate(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>add(2, 2)</code> returns 4, as expected</li>
</ul>
<h3 id="using-the-module-in-a-web-page">Using the module in a web page</h3>
<p>Here&#39;s a web page for my trivial example:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The value of 2 + 2 is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
            (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiateStreaming</span>(<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;./add.wasm&quot;</span>));
                <span class="hljs-keyword">const</span> add = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add</span>;
                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerText</span> = <span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
            })();
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Note that using <code>fetch</code> isn&#39;t supported from the file system, so I used <a href="https://github.com/http-party/http-server">a trivial HTTP server</a> for local testing.</p>
<ul>
<li><code>fetch(&quot;./add.wasm&quot;)</code> initiates a request to load the module by relative path</li>
<li><code>const module = await WebAssembly.instantiateStreaming(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>document.getElementById(&quot;result&quot;).innerText = add(2, 2);</code> updates the &quot;result&quot; span with the result of the call to <code>add</code></li>
</ul>
<p>To my surprise, everything worked on the first try.</p>
<p>I was also able to confirm that the module&#39;s memory was exported (<code>module.instance.exports.memory</code>) and could be read from within my browser&#39;s dev tools window. I&#39;m still not clear on why LLVM decided to export the memory by default.</p>
<h1 id="thats-it">That&#39;s it!</h1>
<p>The end result of all this was actually pretty simple. Here are some links for reference:</p>
<ul>
<li><a href="https://github.com/jaredkrinke/webassembly-trivial-example">GitHub repository with all the code and build commands</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-trivial-example/">Live demo of the module hosted in a web page</a> (using <code>WebAssembly.instantiate()</code> instead of <code>instantiateStreaming()</code> for compatibility with older browsers)</li>
</ul>
<p>Remembering how to use a C compiler on the command line, and deciphering LLVM&#39;s export semantics took a bit more time than I would have liked, but I learned a lot about WebAssembly in the process.</p>
<p>Next up, I&#39;ll see if I can get the C standard library working.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/trivial-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/trivial-example</guid><pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly overview]]></title><description><![CDATA[<h1 id="background">Background</h1>
<h1 id="emscripten">Emscripten</h1>
<p>I first heard of <a href="https://emscripten.org/">Emscripten</a> in the mid-2010s. At the time, you could compile C code to an optimizability-focused subset of JavaScript known as <a href="http://asmjs.org/">asm.js</a>. This meant that, given the source code to a native app and appropriate implementations of system APIs, you could run <em>formerly</em> native-only programs in the browser--convenient, if you don&#39;t want to install anything.</p>
<h2 id="enter-webassembly">Enter WebAssembly</h2>
<p>In the intervening years, <a href="https://webassembly.org/">WebAssembly</a> appeared. WebAssembly is a binary format for programs that run on a portable virtual machine. This VM can be hosted in your browser, but non-browser runtimes have also sprung up (e.g. <a href="https://wasmtime.dev/">wasmtime</a>).</p>
<p>WebAssembly, to me, seems like the <a href="https://en.wikipedia.org/wiki/Holy_Grail">Holy Grail</a> of compilation targets. I wouldn&#39;t be surprised if, thanks to browser support, WebAssembly is <em>the</em> most broadly supported binary program format. What other binary format works on my desktop, phone, <a href="https://www.raspberrypi.org/">Raspberry Pi</a>?</p>
<p>Note that WebAssembly runtimes seem to be standardizing on an in-development system interface named <a href="https://wasi.dev/">WASI</a>. You probably can&#39;t write a GUI app solely with WebAssembly and WASI today, but I&#39;m sure that day is coming (in the distant future).</p>
<h2 id="one-note-on-emscripten">One note on Emscripten</h2>
<p>If you just want to port native programs to the browser, Emscripten is an environment for doing that. It even converts <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> to <a href="https://www.khronos.org/webgl/">WebGL</a> and handles the <a href="https://www.libsdl.org/">SDL</a> API. Unfortunately, just <em>installing</em> Emscripten requires Python. For now, I refuse to setup bloated software just to <em>install</em> the software I actually want, so I&#39;m skipping Emscripten.</p>
<h1 id="webassembly-concepts">WebAssembly concepts</h1>
<p>Mozilla&#39;s documentation has a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts">great overview of WebAssembly concepts</a>. There&#39;s also an <a href="https://hacks.mozilla.org/2017/07/creating-a-webassembly-module-instance-with-javascript/">approachable series of WebAssembly articles</a> on Mozilla Hacks. I&#39;ll try to summarize:</p>
<ul>
<li><strong>Module</strong>: a compiled WebAssembly binary (declaring imports and exports)</li>
<li><strong>Instance</strong>: a module along with its state (memory, table, imports)</li>
<li><strong>Memory</strong>: a read/write, resizable buffer provided to the instance</li>
<li><strong>Table</strong>: array of references that aren&#39;t directly stored in WebAssembly-accessible memory (for security reasons)<ul>
<li>The example I&#39;ve seen for this is to be able to pass function pointers into C/C++ code</li>
</ul>
</li>
</ul>
<h1 id="webassembly-formats">WebAssembly formats</h1>
<p>WebAssembly defines two formats:</p>
<ul>
<li><strong>.wasm</strong>: Binary format</li>
<li><strong>.wat</strong>: Text format (assembly)</li>
</ul>
<p>The <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> contains tools for converting between these formats. Specifically, <code>wat2wasm</code> is analogous to a very simple assembler, and <code>wasm2wat</code> to a disassembler.</p>
<h1 id="webassembly-browser-interface">WebAssembly browser interface</h1>
<p>Within the browser, WebAssembly <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running">currently needs to be loaded using JavaScript</a> (it sounds like there are plans to support loading using script tags and import statements in the future). Sadly, as of today, the recommended way to load WebAssembly (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming()</a>) is <a href="https://caniuse.com/?search=instantiateStreaming">only supported by 75% of browsers</a>. The more broadly supported <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">WebAssembly.instantiate()</a> seems cumbersome. I&#39;m hopeful that WebAssembly&#39;s ergonomics will improve, but I suppose this is just the price you pay when using new technology.</p>
<h1 id="next-steps">Next steps</h1>
<p>Armed with the above information, I think I&#39;m ready to dive in and test out WebAssembly with a trivial example. I&#39;ll report my findings in a subsequent update.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/overview</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/overview</guid><pubDate>Sat, 25 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 2)]]></title><description><![CDATA[<p>In the <a href="../diagrams/">last post</a>, I looked at options for generating diagrams from text descriptions at build time for my static site. Here&#39;s my (failed) attempt at integrating <a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a> into my site.</p>
<h1 id="mermaid-is-browser-based">Mermaid is browser-based</h1>
<p>Mermaid is built on top of <a href="https://d3js.org/">D3.js</a>, which is designed to be used in the browser. It exposes a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API reminiscent of <a href="https://jquery.com/">jQuery</a>. It directly manipulates a DOM, which means you need a browser.</p>
<p>This is a problem for my scenario where I&#39;m building my site outside of any browser in Node.</p>
<p>Mermaid provides a command line interface where you can pass in the text describing a diagram and get SVG back out, but rather than doing something sensible, it uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> to spin up a headless Chromium browser DOM (enjoy that 200+ MB download!) that D3.js manipulates, and then gets everything back out. I guess this is fine for generating, say, a PNG image file, but for SVG it seems excessively wasteful. You shouldn&#39;t need a DOM or browser just to generate XML!</p>
<h1 id="sanity-check">Sanity check</h1>
<p>Just to make sure I&#39;m not missing something obvious, let&#39;s try building a Mermaid diagram in Node without doing anything special.</p>
<h2 id="module-woes">Module woes...</h2>
<p>The first problem I hit is that Mermaid 8.13.0 with D3.js 7.0.3 won&#39;t load in either a CommonJS or ES Module environment in Node 14.17.0. If, in CommonJS mode, I try to use <code>require(&quot;mermaid&quot;)</code>, Node rightly points out that D3.js is an ES Module. If, in an ES Module, I try to use <code>import &quot;mermaid&quot;;</code>, then Mermaid tries to use <code>require()</code> on D3.js, which obviously doesn&#39;t work. This seems like a bug in Webpack&#39;s &quot;universal module&quot; pattern.</p>
<h2 id="jsdom-to-the-rescue">jsdom to the rescue?</h2>
<p><a href="https://github.com/jsdom/jsdom">jsdom</a> provides a fake DOM implementation for use in Node. Sounds promising!</p>
<p>Unfortunately, Mermaid&#39;s dependencies require some SVG functionality that jsdom doesn&#39;t implement, e.g. <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox">SVGGraphicsElement.getBBox()</a>. Alright, now it&#39;s making more sense why Mermaid has this dependency on a browser--it&#39;s using the browser&#39;s SVG API to measure text, compute transformations, and so on. I&#39;m still not thrilled with this design, but I can see how one might need to measure text when generating diagrams (althoug embedding a full Chromium engine seems like overkill).</p>
<p>I did a bit of searching to see if anyone has implemented the SVG API for use in Node, but I couldn&#39;t find anything that looked promising. There was a library for the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">Canvas</a> API that can be used in Node, which probably solved many similar problems (related to CSS and measuring fonts), but implementing SVG just so I can generate diagrams without downloading Chrome is beyond the amount of effort I&#39;m willing to put into this endeavor.</p>
<h1 id="taking-a-step-back">Taking a step back</h1>
<p>It&#39;s looking like using Mermaid on the back end is probably going to require either a significant amount of effort or a willingness to settle for using Chromium behind the scenes.</p>
<p>Rather than start investigating the performance characteristics of mermaid-cli, I think I&#39;m going to take a step back and evaluate which of Mermaid, Graphviz, and <a href="https://github.com/microsoft/automatic-graph-layout">MSAGL</a> (which I just found) has syntax I find most comfortable (while still supporting the features I&#39;m interested in). Honestly, this should have been the first step, but I was hoping that one option would be clearly easier to integrate, at which point I&#39;d probably just make do with whatever syntax and features were available.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</guid><pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>