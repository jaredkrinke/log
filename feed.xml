<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2024-03-17T04:05:36.027Z</updated>

<entry>
<title>100 programming languages, day 1</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-1.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-1.html"/>
<updated>2024-03-16T00:00:00.000Z</updated>
<summary type="text">Up first: SIC-1 Assembly Language.</summary>
<content type="html">&lt;p&gt;I&amp;#39;m &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;trying to write code in 100 different programming languages&lt;/a&gt;. Note: I&amp;#39;m not necessarily planning on blogging about each programming language, but I &lt;em&gt;will&lt;/em&gt; try to collect (and share) notes about my experiences, likely in batches.&lt;/p&gt;
&lt;h1 id=&quot;sic-1-assembly-language&quot;&gt;SIC-1 Assembly Language&lt;/h1&gt;
&lt;p&gt;In order to ensure progress doesn&amp;#39;t fizzle out immediately, I&amp;#39;m starting with a programming language I know well: &lt;strong&gt;&lt;a href=&quot;https://esolangs.org/wiki/SIC-1_Assembly_Language&quot;&gt;SIC-1 Assembly Language&lt;/a&gt;&lt;/strong&gt;. I&amp;#39;m familiar with this language because I designed both it and the (fictional) 8-bit SIC-1 computer it runs on myself (for a game titled, fittingly, &lt;a href=&quot;https://store.steampowered.com/app/2124440/SIC1/&quot;&gt;SIC-1&lt;/a&gt;). &lt;strong&gt;SIC-1 Assembly Language is basically my take on a usable (though somewhat un-ergonomic) &lt;a href=&quot;https://esolangs.org/wiki/Subleq&quot;&gt;subleq&lt;/a&gt; assembly language&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m mildly familiar with assembly languages, and have written assembly code for MIPS and ATmega (non-professionally), but &lt;strong&gt;most code I write is not performance-sensitive, so I prefer to use more expressive languages&lt;/strong&gt;, despite any potential overhead.&lt;/p&gt;
&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Subleq is inconvenient, but straight-forward, however &lt;strong&gt;the SIC-1 is an 8-bit computer with only a single 256 byte address space&lt;/strong&gt;, yielding space for less than 85 instructions, even before adding in any variables&lt;/li&gt;
&lt;li&gt;Fitting &amp;quot;big int&amp;quot; arithmetic, formatting, and the actual logic into roughly 70 &amp;quot;subtract and maybe branch&amp;quot; instructions&amp;quot; required some creativity&lt;/li&gt;
&lt;li&gt;The tedium of subleq and my lack of focus led to several bugs, so I had to add a lot of comments to ensure I could remember what all those subleqs were for&lt;/li&gt;
&lt;li&gt;I had to invent a subroutine calling convention in order to make my solution &amp;quot;fit&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, &lt;strong&gt;subleq is interesting theoretically&lt;/strong&gt; (but not &lt;em&gt;practically&lt;/em&gt;), and, while &lt;strong&gt;the tight constraints of the SIC-1 give me an appreciation for assembly language hacks of yore&lt;/strong&gt;, I&amp;#39;d never want to use subleq for anything substantial (though I&amp;#39;ve heard &lt;a href=&quot;http://users.atw.hu/gerigeri/DawnOS/index.html&quot;&gt;it&amp;#39;s been done&lt;/a&gt;!).&lt;/p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;Main GitHub repository where I&amp;#39;m tracking progress&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaredkrinke/100-languages/blob/main/p1.sic1&quot;&gt;Solution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>100 programming languages in 100 days</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages.html"/>
<updated>2024-03-14T00:00:00.000Z</updated>
<summary type="text">I&apos;m going to write code in 100 different programming languages. For fun.</summary>
<content type="html">&lt;p&gt;As usual, this is probably a terrible idea, but I&amp;#39;ve set a poorly conceived personal goal:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solve the first 100 problems from &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt; &lt;em&gt;using a different programming language for each one&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I&amp;#39;ve created a &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;repository on GitHub to track my progress&lt;/a&gt; and a &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../100-languages/index.html&quot;&gt;tag index page&lt;/a&gt; for related blog posts. And I &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-1.html&quot;&gt;just finished day 1&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;reasons-this-is-a-dumb-idea&quot;&gt;Reasons this is a dumb idea&lt;/h1&gt;
&lt;p&gt;If you&amp;#39;re thinking this is a pointless, trivial exercise, you might be right. Here are some reasons that this is likely &lt;em&gt;not&lt;/em&gt; a good use of my time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Many Project Euler problems are more about math than programming&lt;/strong&gt;, so I might just end up implementing known mathematical formulas rather than creating and refining algorithms&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solving one small, isolated problem is definitely not sufficient&lt;/strong&gt; for &lt;em&gt;really&lt;/em&gt; learning a programming language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I might end up spending more time setting up development environments&lt;/strong&gt; than actually programming&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;m sure I could enumerate many more reasons to &lt;em&gt;not&lt;/em&gt; do this.&lt;/p&gt;
&lt;h1 id=&quot;reasons-this-is-not-a-dumb-idea&quot;&gt;Reasons this is &lt;em&gt;not&lt;/em&gt; a dumb idea&lt;/h1&gt;
&lt;p&gt;Despite this being an obvious waste of time, I&amp;#39;m still &amp;quot;full steam ahead&amp;quot; because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;There are lots of programming languages I&amp;#39;d like to sample&lt;/strong&gt;, and this is a great excuse to finally try them&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Each problem is bite-sized&lt;/strong&gt;, so I might actually be able to start and finish something in one of my frequent small pockets of free time&lt;/li&gt;
&lt;li&gt;It&amp;#39;s such an awful idea, that &lt;strong&gt;I&amp;#39;ll feel zero regret if I abandon the project&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;caveats&quot;&gt;Caveats&lt;/h1&gt;
&lt;p&gt;I left this section for last, hoping that people wouldn&amp;#39;t make it this far, because the headline is deliberately misleading. &lt;strong&gt;When I mentioned &amp;quot;100 days&amp;quot;, I didn&amp;#39;t mean 100 &lt;em&gt;consecutive&lt;/em&gt; days&lt;/strong&gt;. And I didn&amp;#39;t even necessarily mean that each programming language would take 1 day. The &amp;quot;100 days&amp;quot; is really more about limiting the amount of collateral damage to my personal life that this project might cause.&lt;/p&gt;
&lt;p&gt;On that note, wish me luck! And feel free to &lt;a href=&quot;mailto:log@schemescape.com&quot;&gt;email me&lt;/a&gt; suggestions for programming languages (especially if you know of Project Euler problems to pair with them).&lt;/p&gt;
&lt;h1 id=&quot;links&quot;&gt;Links&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../100-languages/index.html&quot;&gt;Index of related posts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-1.html&quot;&gt;Day 1 update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;GitHub repository tracking my progress&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Minimal dev environment, part 5</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-5.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-5.html"/>
<updated>2024-03-05T00:00:00.000Z</updated>
<summary type="text">I almost found the perfect minimal development environment.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-4.html&quot;&gt;part 4 of my quest to find a minimal (but comfortable) development environment&lt;/a&gt;, I upgraded from a Raspberry Pi B to an old netbook. But now I&amp;#39;m back to tinkering with the Pi.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Why am I back to using an ancient single-board computer&lt;/strong&gt; (with a 700 MHz, 32-bit ARM CPU and 512 MB of RAM)? Because I think I can do better this time.&lt;/p&gt;
&lt;p&gt;On my previous attempt, I was writing code in C and TypeScript because, frankly, those were the languages I was most familiar (and content) with. Sadly, parsing and analyzing those languages is nontrivial, and I noticed that syntax highlighting and (especially) static analysis were so computationally expensive, that Vim would start to crawl. I could literally watch lines of text appearing like typewriter.&lt;/p&gt;
&lt;p&gt;So, have I found a magical new language server that runs snappily on an original Pi? No. But kind of.&lt;/p&gt;
&lt;h1 id=&quot;a-faster-integrated-development-environment&quot;&gt;A faster integrated development environment&lt;/h1&gt;
&lt;p&gt;Of course, to get faster syntax highlighting and whatnot, I had to change a few things--namely &lt;em&gt;everything&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Out goes Vim, in comes Emacs.&lt;/strong&gt; I know that sounds like a bad trade-off for performance, but bear with me.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Out go C and TypeScript, and in comes Common Lisp.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Emacs is not known for speed, but, when working with Lisp, it gets to cheat a bit. Lisp&amp;#39;s syntax is trivial, so parsing is very fast. Additionally, auto-complete is essentially baked into the &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../programming-languages/learning-lisp-in-2023.html&quot;&gt;&amp;quot;read, evaluate, and print&amp;quot; loop of Lisp development&lt;/a&gt;, and Emacs+SLIME adds formatting too.&lt;/p&gt;
&lt;p&gt;It does take a while to startup, but once it&amp;#39;s running, Emacs with SLIME and SBCL is surprisingly usable on my cute little hardware relic. I played around with some Lisp code and started making plans to write the finale to this series. I&amp;#39;d done it! I&amp;#39;d found a minimal, yet productive, development environment that could run on an endangered architecture!&lt;/p&gt;
&lt;h1 id=&quot;or-not&quot;&gt;Or not&lt;/h1&gt;
&lt;p&gt;Unfortunately, when I went to try compiling &lt;a href=&quot;https://lem-project.github.io/&quot;&gt;Lem&lt;/a&gt; (a Common Lisp-based editor), I encountered a strange error message from &lt;a href=&quot;https://sionescu.github.io/bordeaux-threads/&quot;&gt;Bordeaux Threads&lt;/a&gt; (the de facto threading library for Common Lisp). The error breadcrumbs eventually led me to an inconvenient truth: &lt;a href=&quot;http://www.sbcl.org/manual/index.html#Threading&quot;&gt;SBCL doesn&amp;#39;t support multithreading on 32-bit ARM&lt;/a&gt;. Cue sad face emoji.&lt;/p&gt;
&lt;p&gt;I tried installing CLISP, but the Debian build of CLISP also didn&amp;#39;t appear to support threads. Same for ECL. I could maybe recompile one or both of those, but I haven&amp;#39;t gone down that road because I suspect they will eventually be too slow (CLISP during execution and ECL during compilation).&lt;/p&gt;
&lt;h1 id=&quot;or-not-1&quot;&gt;Or not?&lt;/h1&gt;
&lt;p&gt;Of course, I don&amp;#39;t really &lt;em&gt;need&lt;/em&gt; multithreading for some of my projects, so I didn&amp;#39;t give up at this point. I happily solved a few &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt; problems using Common Lisp, in Emacs. I&amp;#39;ll admit that the editor was a bit slow when running in X.org (with the &lt;a href=&quot;https://www.nongnu.org/ratpoison/&quot;&gt;Ratpoison&lt;/a&gt; window manager). Without X.org, editor performance was great, although that breaks some key combinations, has limited mouse support, and the font is frankly a bit too small on my monitor.&lt;/p&gt;
&lt;p&gt;But I eventually ran into an insurmountable annoyance...&lt;/p&gt;
&lt;h1 id=&quot;so-we-meet-again-modern-web&quot;&gt;So we meet again, modern web&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;The modern web is just the worst&lt;/strong&gt;, and the most recent brick wall I slammed into is: captchas (specifically Project Euler&amp;#39;s captcha, which requires JavaScript).&lt;/p&gt;
&lt;p&gt;On my Pi, I generally try to stick to a terminal-mode browser like &lt;a href=&quot;https://w3m.sourceforge.net/&quot;&gt;w3m&lt;/a&gt; because it&amp;#39;s fast and uses very little memory. If I need graphics, I move to &lt;a href=&quot;https://dillo.org/&quot;&gt;Dillo&lt;/a&gt; or &lt;a href=&quot;https://www.netsurf-browser.org/&quot;&gt;NetSurf&lt;/a&gt;. If I need JavaScript, I use &lt;a href=&quot;https://astian.org/midori-browser/&quot;&gt;Midori&lt;/a&gt;, but it is &lt;em&gt;painfully&lt;/em&gt; slow on my Pi. And don&amp;#39;t even ask about Firefox--it couldn&amp;#39;t even load its own landing page on my Pi!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Having to use a JavaScript-enabled browser on a woefully underpowered device just absolutely killed my enthusiasm for minimalist development&lt;/strong&gt;. Too many sites require JavaScript, and being effectively locked out of a large chunk of the web is too annoying for me at the moment.&lt;/p&gt;
&lt;p&gt;Oh well, at least I tried.&lt;/p&gt;
</content>
</entry>
<entry>
<title>SIC-1 is going open source</title>
<id>https://log.schemescape.com/posts/game-development/sic-1-open-source.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1-open-source.html"/>
<updated>2023-12-19T00:00:00.000Z</updated>
<summary type="text">Which open source licenses make the most sense for my game?</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html&quot;&gt;my original retrospective on releasing SIC-1&lt;/a&gt; (a single-instruction zachlike programming game), there were two open questions about the future:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Should I port the game to Linux (on Steam)?&lt;/li&gt;
&lt;li&gt;Should I release the game under an open source license?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first question has been answered: &lt;a href=&quot;https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux-2.html&quot;&gt;SIC-1 has been ported to Linux (on Steam)&lt;/a&gt;, but the second had not (until now).&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve finally decided to release the game under an open source license. &lt;strong&gt;Which license? Good question!&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;
&lt;p&gt;Why release SIC-1 as open source? Up until now, the game has been my baby and there have been no substantial contributions by anyone else.&lt;/p&gt;
&lt;p&gt;If I was naive, I&amp;#39;d hope that releasing the game as open source would lead to a revival, driven by contributions from excited new authors. But I&amp;#39;m &lt;em&gt;not&lt;/em&gt; naive, and I fully expect that no one else will take the time to read, understand, and modify the code in any significant way.&lt;/p&gt;
&lt;p&gt;But games are more than just code! There are also assets. Specifically, SIC-1 contains a bunch of English text, both in the form of documentation and narrative. While I don&amp;#39;t expect the characters I&amp;#39;ve developed to get their own spin-off TV series, there is at least &lt;em&gt;one&lt;/em&gt; area where I am hopelessly under-qualified &lt;em&gt;and&lt;/em&gt; multiple people have expressed an actual interest in contributing:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Translating SIC-1 into additional languages&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I feel it would be unfair to ask for translations from &lt;em&gt;volunteers&lt;/em&gt; in the case that I retained ownership over the entire game (even though the game is available for free already). Instead, I think it makes sense to open up ownership of the game to &lt;em&gt;everyone&lt;/em&gt;, i.e. release the game as open source.&lt;/p&gt;
&lt;h1 id=&quot;hypothetical-concerns&quot;&gt;Hypothetical concerns&lt;/h1&gt;
&lt;p&gt;Given that SIC-1 is free, with source already available, why wasn&amp;#39;t the game already open source? Here was my &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html#should-i-open-source-sic-1&quot;&gt;original rationale&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t want someone else to turn around and sell my game (that I released for free)&lt;/li&gt;
&lt;li&gt;I&amp;#39;m proud of the music and characters/narrative, and I don&amp;#39;t want other people to be able to profit off of them&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now that the game has been out on Steam for over a year and I think it&amp;#39;s already past its popularity peak, I feel less concerned about someone else profiting off of the game. The zachlike genre is just not that popular. Even excellent zachlikes &lt;em&gt;from Zachtronics&lt;/em&gt; don&amp;#39;t sell that many copies. And SIC-1 isn&amp;#39;t nearly as good! &lt;strong&gt;No one&amp;#39;s going to get rich off this game.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As far as the characters and narrative, I can&amp;#39;t imagine anyone repurposing them. And I can just use a copyleft/share-alike license anyway.&lt;/p&gt;
&lt;p&gt;Having said all of that, I don&amp;#39;t think I&amp;#39;m quite ready to let &lt;em&gt;just anyone&lt;/em&gt; use the music from the &lt;a href=&quot;https://soundcloud.com/schemescape/sets/sic-1-original-soundtrack&quot;&gt;SIC-1 Original Soundtrack&lt;/a&gt;. Unlike code and documentation, background music could fit right into completely unrelated projects--or even &lt;em&gt;events&lt;/em&gt;. &lt;strong&gt;What if 80s-inspired puzzlewave suddenly breaks into the mainstream and then I&amp;#39;m hearing the SIC-1 soundtrack at political rallies?&lt;/strong&gt; Maybe that&amp;#39;s taking this hypothetical situation a bit too far, but, regardless, I&amp;#39;ll probably continue to retain sole ownership over the soundtrack.&lt;/p&gt;
&lt;h1 id=&quot;copyleft-or-permissive-license&quot;&gt;Copyleft or permissive license?&lt;/h1&gt;
&lt;p&gt;The main decision I need to make around licensing is between choosing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Copyleft&quot;&gt;copyleft&lt;/a&gt; vs. permissive license (e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_General_Public_License&quot;&gt;GPL&lt;/a&gt; vs. &lt;a href=&quot;https://en.wikipedia.org/wiki/MIT_license&quot;&gt;MIT&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;I like the idea of using a copyleft license because it (roughly) requires anyone distributing derivative works release their modifications back to the community. There is one sticking point with the GPL, however: it doesn&amp;#39;t allow linking with closed source code--in my case, this means I couldn&amp;#39;t link with the Steamworks SDK (which provides achievements and friend leaderboards on Steam) without jumping through some hoops (e.g. &lt;a href=&quot;https://github.com/icculus/steamshim&quot;&gt;moving Steam interactions out of process&lt;/a&gt; or requiring contributors sign a &amp;quot;contributor license agreement&amp;quot; allowing distribution on Steam). The &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License&quot;&gt;LGPL license &lt;/a&gt; would avoid this problem.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s another issue with copyleft: what if I want to later use my code in a new game? Of course I can use &lt;em&gt;my&lt;/em&gt; code, but I wouldn&amp;#39;t be able to use any improvements that have been contributed by others. Honestly, however, this seems unfair to those contributors--I&amp;#39;d be (potentially) profiting off of their work.&lt;/p&gt;
&lt;p&gt;After writing these thoughts down, I think the answer is clear: &lt;strong&gt;I&amp;#39;d prefer to use a copyleft license to protect both my contributions &lt;em&gt;and the contributions of others&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;the-plan&quot;&gt;The plan&lt;/h1&gt;
&lt;p&gt;Given all of the above, here&amp;#39;s my plan for licensing the various categories of SIC-1 content:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source code&lt;/strong&gt;: &lt;a href=&quot;https://www.gnu.org/licenses/lgpl-3.0.en.html&quot;&gt;GNU Lesser General Public License&lt;/a&gt; (at least until I have time to incorporate a GPL shim for the Steamworks SDK)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Documentation/narrative&lt;/strong&gt;: &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution, Share-Alike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Music&lt;/strong&gt;: &amp;quot;all rights reserved&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>A Common Lisp static site generator, because why not?</title>
<id>https://log.schemescape.com/posts/static-site-generators/lisp-ssg.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/lisp-ssg.html"/>
<updated>2023-11-29T00:00:00.000Z</updated>
<summary type="text">The static site generator that almost wasn&apos;t, but then was.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-4.html&quot;&gt;a recent post about speeding up md2blog&lt;/a&gt; (the &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;Deno/TypeScript-based static site generator I created for this site&lt;/a&gt;), I gloated about suppressing the urge to build &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/pre-markdown.html&quot;&gt;yet another&lt;/a&gt; static site generator:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I have successfully staved off the urge ... to create yet another static site generator by instead making md2blog ... &lt;em&gt;just fast enough&lt;/em&gt; ... that it seems pointless to bother improving upon its performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;This is the inevitable follow-up post where I describe the new static site generator I ended up building&lt;/strong&gt;, this time using Common Lisp.&lt;/p&gt;
&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ll discuss differentiators next, but my personal motivation for creating this static site generator is some combination of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/learning-lisp-in-2023.html&quot;&gt;I&amp;#39;ve been learning Common Lisp&lt;/a&gt; (to sample REPL-driven development, macros, etc.) and I wanted to build a small-but-nontrivial project to help me learn (aside: I&amp;#39;m also curious about performance with &lt;a href=&quot;https://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;I wanted to try building an extensible static site generator (like &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt;) that natively supports incremental rebuilds&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words: &lt;strong&gt;for fun&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;differentiators&quot;&gt;Differentiators&lt;/h1&gt;
&lt;p&gt;Fun is fun, but am I just reinventing the wheel? Hopefully not. I fully expect no one else will use this static site generator (assuming I even &lt;em&gt;complete&lt;/em&gt; it), but I think it does have a unique combination of features, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Being based around a &lt;strong&gt;completely generic and extensible pipeline&lt;/strong&gt; (sort of a &amp;quot;static site generator toolkit&amp;quot;, similar to Metalsmith)--theoretically, it&amp;#39;s not even limited to web pages (or even the file system)&lt;/li&gt;
&lt;li&gt;Having &lt;strong&gt;fast incremental rebuilds&lt;/strong&gt; natively supported, without having to prescriptively list the inputs and outputs of each step&lt;/li&gt;
&lt;li&gt;Using a &lt;strong&gt;template system that is based entirely on list processing&lt;/strong&gt; (the &amp;quot;Lisp&amp;quot; part of &amp;quot;Common Lisp&amp;quot;)&lt;/li&gt;
&lt;li&gt;Providing a &lt;strong&gt;built-in debugger&lt;/strong&gt; (this one is kind of cheating since it comes for free with Common Lisp)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;architecture&quot;&gt;Architecture&lt;/h1&gt;
&lt;h2 id=&quot;pipeline&quot;&gt;Pipeline&lt;/h2&gt;
&lt;p&gt;For maximum flexibility, this static site generator is based on a generic processing pipeline, represented as a &lt;strong&gt;directed acyclic graph of processing nodes&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s a description of a blog pipeline, with one bullet per node:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerate files from the input directory&lt;/li&gt;
&lt;li&gt;Extract front matter (metadata) from Markdown files&lt;/li&gt;
&lt;li&gt;Convert Markdown into a tree-based document format&lt;/li&gt;
&lt;li&gt;Create an index of all posts&lt;/li&gt;
&lt;li&gt;Create index and archive pages&lt;/li&gt;
&lt;li&gt;Render tree format into HTML&lt;/li&gt;
&lt;li&gt;Write HTML files out to the output directory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In image form (note: the pipeline definition in code is shown later):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/pipeline-blog.svg&quot; alt=&quot;Blog pipeline diagram&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;node-types&quot;&gt;Node types&lt;/h2&gt;
&lt;p&gt;So far, this sounds like Metalsmith&amp;#39;s declarative JSON-based &amp;quot;plugin chain&amp;quot;. Here&amp;#39;s the twist:&lt;/p&gt;
&lt;p&gt;There are two main node types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Aggregate nodes&lt;/strong&gt;: Similar to Metalsmith plugins, these nodes operate over the entire set of files/items and produce multiple outputs (and can remove items, too), i.e. they are M:N (M inputs and N outputs)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transform nodes&lt;/strong&gt;: These are 1:N nodes which only consume a single input file/item (but can still produce N outputs)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, here are two hypothetical nodes: an aggregate node that combines metadata from two Markdown posts (&amp;quot;post1.md&amp;quot; and &amp;quot;post2.md&amp;quot;) into a single index (&amp;quot;index.json&amp;quot;), and a transform node that converts Markdown to HTML -- note that the transform node processes each item in isolation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/node-aggregate.svg&quot; alt=&quot;Aggregate node diagram&quot;/&gt; &lt;img src=&quot;https://log.schemescape.com/posts/static-site-generators/assets/node-transform.svg&quot; alt=&quot;Transform node diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Explicitly expressing 1:N transform nodes is the primary innovation (although I&amp;#39;m sure--at least I hope--this has been done before, somewhere). Here are the benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single-item transformations can be run in parallel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Only &lt;em&gt;new or modified&lt;/em&gt; input items need to be transformed&lt;/strong&gt; when rebuilding (updating)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;experimented with a similar approach using GNU Make in the past&lt;/a&gt;, but besides being slow (because it spun up a new process for processing each input), it was also cumbersome, requiring hand-crafting patterns and adding kludges to detect zombie files that should be deleted.&lt;/p&gt;
&lt;h3 id=&quot;under-the-hood&quot;&gt;Under the hood&lt;/h3&gt;
&lt;p&gt;Internally, the processing pipeline actually operates over &amp;quot;changes&amp;quot;. For example, if a file gets added or modified in the source directory, an &lt;code&gt;:update&lt;/code&gt; event is propagated down the pipeline; if a file is deleted, a &lt;code&gt;:delete&lt;/code&gt; event is sent. There are two additional node types that operate directly upon changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source nodes&lt;/strong&gt;: Create changes (e.g. based on seeing if the contents of a directory have changed)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sink nodes&lt;/strong&gt;: Consume changes (e.g. write &lt;code&gt;:update&lt;/code&gt;&amp;#39;d files to disk or remove &lt;code&gt;:delete&lt;/code&gt;&amp;#39;d files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each node maintains a snapshot of inputs and outputs and they will only run when their input actually changes (item contents and/or metadata). Transform nodes also maintain a map of inputs &lt;em&gt;to&lt;/em&gt; outputs (to handle deletions, implicit or explicit).&lt;/p&gt;
&lt;h3 id=&quot;node-types-example&quot;&gt;Node types example&lt;/h3&gt;
&lt;p&gt;Here&amp;#39;s the blog pipeline from before with each node type in parentheses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerate files (&lt;strong&gt;source node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Extract front matter (metadata) (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Convert Markdown into a tree (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Create an index (&lt;strong&gt;aggregate node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Create index/archive pages (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Render HTML (&lt;strong&gt;transform node&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Write HTML files (&lt;strong&gt;sink node&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that when a single Markdown post is updated, the transform nodes only need to process the updated item(s) (if any).&lt;/p&gt;
&lt;h2 id=&quot;item-representation&quot;&gt;Item representation&lt;/h2&gt;
&lt;p&gt;Items are represented by three pieces of information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Path&lt;/strong&gt;: UNIX-style pathname, relative to the source directory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content&lt;/strong&gt;: file content, in any format--even just a pathname for e.g. pass-through static assets&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metadata&lt;/strong&gt;: an bag of arbitrary properties (currently using an association list)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;templateshtml-representation&quot;&gt;Templates/HTML representation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;I hate most static site generators because I hate the template languages they use&lt;/strong&gt;. Especially the one Hugo uses. Sometimes, it&amp;#39;s just the verbose syntax for inserting a value that I dislike. Other times, it&amp;#39;s the bespoke conditional/loop syntax that I grudgingly have to learn.&lt;/p&gt;
&lt;p&gt;A corollary to &lt;a href=&quot;https://en.wikipedia.org/wiki/Greenspun&amp;#39;s_tenth_rule&quot;&gt;Greenspun&amp;#39;s tenth rule&lt;/a&gt; seems appropriate:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any sufficiently complicated &lt;del&gt;C or Fortran program&lt;/del&gt; &lt;em&gt;HTML template language&lt;/em&gt; contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The obvious solution is to simply embrace Common Lisp&amp;#39;s list processing. Here&amp;#39;s an example of the list format I&amp;#39;m using:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-symbol&quot;&gt;:p&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;Here is a &amp;quot;&lt;/span&gt;
    (&lt;span class=&quot;hljs-symbol&quot;&gt;:a&lt;/span&gt; &lt;span class=&quot;hljs-symbol&quot;&gt;:href&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;https://log.schemescape.com/&amp;quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;link!&amp;quot;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rendered to HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Here is a &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;https://log.schemescape.com/&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;link!&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So that&amp;#39;s the &amp;quot;list&amp;quot; part.&lt;/p&gt;
&lt;p&gt;The &amp;quot;processing&amp;quot; part is &lt;strong&gt;literally just Common Lisp code&lt;/strong&gt;. No weird syntax, just a standardized language that&amp;#39;s been kicking around for decades. Although I haven&amp;#39;t implemented it yet, this should also make validating relative links at build-time trivial since I only need to walk lists (something Lisp does with ease).&lt;/p&gt;
&lt;p&gt;For the record, I did not use &lt;a href=&quot;https://edicl.github.io/cl-who/&quot;&gt;CL-WHO&lt;/a&gt; because it doesn&amp;#39;t escape strings by default and I didn&amp;#39;t use &lt;a href=&quot;https://github.com/ruricolist/spinneret&quot;&gt;Spinneret&lt;/a&gt; because it has ~20 dependencies.&lt;/p&gt;
&lt;h1 id=&quot;current-status&quot;&gt;Current status&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s what I&amp;#39;ve implemented so far:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pipeline, node, and item representation&lt;/li&gt;
&lt;li&gt;Directory enumeration&lt;/li&gt;
&lt;li&gt;Prototype YAML and Markdown parsing (although both will need to be replaced)&lt;/li&gt;
&lt;li&gt;HTML templates&lt;/li&gt;
&lt;li&gt;Prototype blog pipeline (minus an Atom feed and site map)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There&amp;#39;s quite a bit of work remaining:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parallel transformations (should be trivial with &lt;a href=&quot;https://github.com/lmj/lparallel&quot;&gt;lparallel&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Find and integrate a more robust Markdown parser&lt;/li&gt;
&lt;li&gt;Add a live-reloading web server&lt;/li&gt;
&lt;li&gt;Add Atom feed (and possibly site map) support to the blog pipeline&lt;/li&gt;
&lt;li&gt;Consider adding build-time syntax highlighting&lt;/li&gt;
&lt;li&gt;Persist intermediate objects to disk&lt;/li&gt;
&lt;li&gt;Document everything&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;
&lt;p&gt;Given that the implementation is incomplete, I don&amp;#39;t want to read too much into its performance. For my site, I expect it to be fast because updating a single blog post will only require rebuilding the edited post, possibly the index/archive/post index pages, and possibly the Atom feed (&lt;strong&gt;roughly a 30x reduction in the number of files being written&lt;/strong&gt; for my smallish site).&lt;/p&gt;
&lt;p&gt;On my netbook where I finally got md2blog live rebuilds down to 200ms, the prototype blog could complete an incremental rebuild for a single post update in 80ms--and that&amp;#39;s with a slow (and brittle) Markdown processor that needs to be replaced.&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Currently, the code is a complete mess&lt;/strong&gt;. It&amp;#39;s all one big file with a million TODOs and at least one gratuitous macro. It&amp;#39;s a work-in-progress, and code cleanup isn&amp;#39;t even in my top ten concerns right now.&lt;/p&gt;
&lt;p&gt;Honestly, I don&amp;#39;t even want to share the code because it&amp;#39;s so ugly, but since you can easily find it, I&amp;#39;ll just save you the trouble:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jaredkrinke/cl-stuff/blob/main/ssg/ssg.lisp&quot;&gt;https://github.com/jaredkrinke/cl-stuff/blob/main/ssg/ssg.lisp&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pipeline-example&quot;&gt;Pipeline example&lt;/h3&gt;
&lt;p&gt;Here is an example of the previous blog pipeline expressed in code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;defparameter&lt;/span&gt; *pipeline*
  &amp;#x27;((source :children (front-matter))
    (front-matter :children (markdown
                             index-posts))
    (markdown :children (template-posts))
    (template-posts :children (lhtml))
    (index-posts :children (template-indexes))
    (template-indexes :children (lhtml))
    (lhtml :children (destination))
    (destination)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first symbol in each list is the name of a node class. Arcs/arrows can be added via either &lt;code&gt;:children&lt;/code&gt; or &lt;code&gt;:parents&lt;/code&gt;. I prefer to use &lt;code&gt;:children&lt;/code&gt; because it seems more intuitive to think of the way items flow through the pipeline (source -&amp;gt; front-matter -&amp;gt; markdown -&amp;gt; template-posts -&amp;gt; lhtml -&amp;gt; destination).&lt;/p&gt;
&lt;h2 id=&quot;name&quot;&gt;Name&lt;/h2&gt;
&lt;p&gt;So what is this new static site generator called? Well, that&amp;#39;s &lt;em&gt;also&lt;/em&gt; not in my top ten concerns right now. The Common Lisp package is just named &lt;code&gt;SSG&lt;/code&gt; as a placeholder. &lt;strong&gt;Hopefully I&amp;#39;ll think of a catchy name eventually&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&quot;the-end&quot;&gt;The end&lt;/h1&gt;
&lt;p&gt;And apologies for creating yet another static site generator. At least I didn&amp;#39;t create a new front-end framework for JavaScript!&lt;/p&gt;
</content>
</entry>
</feed>
