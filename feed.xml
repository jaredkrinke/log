<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-03-01T01:33:16.317Z</updated>

<entry>
<title>Minimal dev environment, part 3: introducing &quot;leano&quot;, a tiny Deno-compatible runtime</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html"/>
<updated>2023-02-28T00:00:00.000Z</updated>
<summary type="text">I developed an actual piece of software using my minimal development environment. Here&apos;s how it went.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html&quot;&gt;part 2&lt;/a&gt;, I laid out my initial minimal development environment (Raspberry Pi B, Alpine Linux, console only). Today, I&amp;#39;m sharing my initial experience using this setup.&lt;/p&gt;
&lt;h1 id=&quot;the-task-at-hand&quot;&gt;The task at hand&lt;/h1&gt;
&lt;p&gt;In order to document my experience, I needed to be able to build and update my dev blog using my &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt;-based static site generator (&lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt;), along with Git (and GitHub Pages). Problem: Deno &lt;a href=&quot;https://github.com/denoland/deno/issues/2295&quot;&gt;doesn&amp;#39;t support Raspberry Pi&lt;/a&gt; (32-bit or 64-bit).&lt;/p&gt;
&lt;p&gt;Fortunately, my static site generator only uses a tiny fraction of Deno&amp;#39;s API surface (at least to build the site), so it&amp;#39;s straight-forward to port the tool to a Pi-friendly runtime. One option would be to compile my TypeScript code to JavaScript, bundle it, and then use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node&lt;/a&gt; with a Node-to-Deno compatibility layer (written in JavaScript).&lt;/p&gt;
&lt;p&gt;But a more &lt;em&gt;interesting&lt;/em&gt; option would be to create my own (minimal, of course) Deno-compatible runtime, and use &lt;em&gt;that&lt;/em&gt; to run md2blog.&lt;/p&gt;
&lt;h2 id=&quot;dependencies&quot;&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;For this project, I decided to get back to my roots and use plain, boring old C. I would have like to try out Zig, but they don&amp;#39;t appear to build SDK binaries for the Raspberry Pi. Why C (or Zig)? Mostly because I was planning to leverage &lt;a href=&quot;https://bellard.org/quickjs/&quot;&gt;QuickJS&lt;/a&gt; (an implementation of ES2020 in C), and I knew that integrating the library would be simple if I stuck to C. If I&amp;#39;d used a new (to me) programming language, I&amp;#39;d immediately be thrown into the treacherous waters of foreign function interfaces/bindings (and past experience told me that&amp;#39;s usually the least fun part of learning a new programming language).&lt;/p&gt;
&lt;p&gt;Between QuickJS and the C standard library, I was hopeful I could get md2blog up and running on my Raspberry Pi.&lt;/p&gt;
&lt;h1 id=&quot;code-editing&quot;&gt;Code editing&lt;/h1&gt;
&lt;p&gt;In the past, I used Vim extensively, but lately I&amp;#39;ve mostly used VS Code (and Visual Studio, if necessary). This project was a good opportunity to reacquaint myself with Vim. Specifically, I wanted to see if I could carry some of my favorite features from VS Code back to Vim:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Smart) Auto-complete&lt;/li&gt;
&lt;li&gt;Go to definition&lt;/li&gt;
&lt;li&gt;Spellcheck&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;auto-complete-for-c-code-in-vim&quot;&gt;Auto-complete for C code in Vim&lt;/h2&gt;
&lt;p&gt;I used to think auto-complete was often used as a crutch for not being familiar with code. Nowadays, I&amp;#39;ll take any crutch I can get, because there&amp;#39;s so much code, and it&amp;#39;s honestly not worth my time to understand it all in depth--most of the time, at least.&lt;/p&gt;
&lt;p&gt;Although I was aware of it, I&amp;#39;d never taken the time to setup &lt;a href=&quot;https://en.wikipedia.org/wiki/Ctags&quot;&gt;Ctags&lt;/a&gt; in Vim. Ctags isn&amp;#39;t as nice as a real language server (it doesn&amp;#39;t automatically regenerate and can&amp;#39;t find all references, for example), but I&amp;#39;m not sure my Raspberry Pi could run a real language server anyway. Fortunately, setting up Ctags was as easy as running &lt;code&gt;ctags -R *&lt;/code&gt; in my project. Then it just all magically worked in insert mode with &lt;strong&gt;Ctrl+N&lt;/strong&gt;. Nice!&lt;/p&gt;
&lt;h2 id=&quot;go-to-definition&quot;&gt;Go to definition&lt;/h2&gt;
&lt;p&gt;With Ctags set up, I was just a &lt;code&gt;:help tags&lt;/code&gt; away from learning how to go to the definition of a symbol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+]&lt;/strong&gt; jumps to the definition of the currently highlighted symbol&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+W Ctrl+]&lt;/strong&gt; opens the definition in a new pane&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+T&lt;/strong&gt; jumps back to where you were&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&amp;#39;s pretty handy, although I started to remember how annoying it is to have to memorize a million key bindings to be productive in Vim.&lt;/p&gt;
&lt;h2 id=&quot;spellcheck&quot;&gt;Spellcheck&lt;/h2&gt;
&lt;p&gt;For blog entries, it&amp;#39;s nice to have a spellchecker running, to catch typos. I did a bit of research and couldn&amp;#39;t figure out why &lt;strong&gt;Ctrl+X s&lt;/strong&gt; didn&amp;#39;t work for spellcheck, but &lt;code&gt;:set spell&lt;/code&gt; worked like magic, and highlights any suspicious words.&lt;/p&gt;
&lt;h2 id=&quot;navigating-new-code-in-vim&quot;&gt;Navigating new code in Vim&lt;/h2&gt;
&lt;p&gt;Armed with some new Vim knowledge, I got started. The first task was to navigate around the QuickJS code to understand things like how to evaluate JavaScript code and how to expose native functions to JavaScript. Being able to search around the code and jump to definitions was great, but I did start to wish I was in VS Code. In Vim, I&amp;#39;m used to splitting panes horizontally and vertically, but I&amp;#39;m not sure what to do when I need to have so many things open at once that the panes are too small to be readable. In VS Code, I can keep files open without losing context. I&amp;#39;m sure this is possible in Vim, but I haven&amp;#39;t figure it out yet (and I&amp;#39;m not sure I&amp;#39;d remember all the keyboard shortcuts to make it happen).&lt;/p&gt;
&lt;p&gt;Has someone made a command palette for Vim yet?&lt;/p&gt;
&lt;h1 id=&quot;web-browser-woes&quot;&gt;Web browser woes&lt;/h1&gt;
&lt;p&gt;In addition to reading the QuickJS code, I also needed to refer to the HTML manual (although it&amp;#39;s fairly light on details, so no substitute for just reading the code). Once again, the console web browser experience was painful. It&amp;#39;s not the fault of the browsers themselves, it&amp;#39;s just that most web pages don&amp;#39;t seem to be designed with console browsers in mind. The QuickJS manual worked well, but trying to drill into search results, navigate GitHub issues, and read StackOverflow threads was a chore.&lt;/p&gt;
&lt;p&gt;At least DuckDuckGo and &lt;a href=&quot;https://developer.mozilla.org/en-US&quot;&gt;MDN&lt;/a&gt; provide decent experiences in console mode.&lt;/p&gt;
&lt;h1 id=&quot;so-slow&quot;&gt;So... &lt;em&gt;slow&lt;/em&gt;...&lt;/h1&gt;
&lt;p&gt;The preceding issues were tolerable. Performance was another story.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not sure what I was expecting from a 10 year old computer that cost $50 to begin with. I thought I&amp;#39;d heard that you could play Quake 3 on a Raspberry Pi (although I&amp;#39;m not sure which model). Having used a Raspberry Pi model B with 512 MB of RAM and a 700 MHz ARM CPU for a few days, I&amp;#39;m skeptical.&lt;/p&gt;
&lt;p&gt;Installing packages and opening web pages in w3m was pretty snappy, but compiling QuickJS was a rude awakening. I typed &lt;code&gt;make&lt;/code&gt; and then left to do something else when it became apparent that it might be a while. Later, I came back, and it was &lt;em&gt;still&lt;/em&gt; compiling! With link-time optimization, it took almost half an hour to build QuickJS.&lt;/p&gt;
&lt;p&gt;I hoped that the GCC compiler was just being slow (and link-time optimization is probably pretty CPU-intensive in general), but over the course of the day it became apparent that &lt;em&gt;everything&lt;/em&gt; was slow. Navigating large C files in Vim was slow (frequently, I could see the screen re-drawing individual lines of text). Syntax highlighting (which I think isn&amp;#39;t even parsing the full C grammar) was slow enough that it kept automatically turning itself off.&lt;/p&gt;
&lt;h1 id=&quot;success-and-leano&quot;&gt;Success! And &lt;strong&gt;leano&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;But I persisted and eventually was able to create a minimal Deno-compatible JavaScript runtime, built on QuickJS. I call the result &lt;strong&gt;leano&lt;/strong&gt;, and &lt;a href=&quot;https://github.com/jaredkrinke/leano&quot;&gt;the toy-level prototype code is up on GitHub&lt;/a&gt;. The whole thing weighs in at roughly 800 KB. But, of course, it doesn&amp;#39;t do very much--leano only implements the Deno functions/properties that md2blog uses.&lt;/p&gt;
&lt;p&gt;For the record: this blog post was written (and built) using leano on my Raspberry Pi.&lt;/p&gt;
&lt;p&gt;The implementation is fairly simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sets up a QuickJS runtime and context&lt;/li&gt;
&lt;li&gt;Exposes a couple of native functions (for performance reasons)&lt;/li&gt;
&lt;li&gt;Injects JavaScript code to implement Deno and web APIs (e.g. &lt;code&gt;Deno.args&lt;/code&gt;, &lt;code&gt;Deno.writeTextFile&lt;/code&gt;, and &lt;code&gt;TextEncoder&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Runs the requested module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;ll admit that md2blog hasn&amp;#39;t been optimized. It always regenerates the entire site, and it&amp;#39;s written in JavaScript. On my desktop computer, I can build my site in maybe 1 second. On the Raspberry Pi (admittedly using a much simpler JavaScript runtime), it took &lt;em&gt;over 6 minutes&lt;/em&gt;! Even after moving UTF-8 encode/decode to native code, it still took 4 minutes to rebuild this site.&lt;/p&gt;
&lt;h1 id=&quot;lessons-learned&quot;&gt;Lessons learned&lt;/h1&gt;
&lt;p&gt;That was just a depiction of my experience using this minimal dev environment. But what have I &lt;em&gt;learned&lt;/em&gt;?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A ten year-old, cheap computer is capable, but &lt;em&gt;slow&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Regardless, it &lt;em&gt;is&lt;/em&gt; possible to develop software in C, with most of the bells and whistles, &lt;em&gt;while using under 500 MB of disk space&lt;/em&gt; (this is probably the biggest surprise of this whole experiment)&lt;/li&gt;
&lt;li&gt;Vim with Ctags is great, but remembering all the key bindings is annoying, and I still feel less productive than in VS Code&lt;/li&gt;
&lt;li&gt;Not mentioned above, but I haven&amp;#39;t found a good debugging setup, even for C&lt;/li&gt;
&lt;li&gt;JavaScript is pretty portable, thanks to QuickJS (though I worry what will happen as the language continues to evolve beyond QuickJS&amp;#39;s implementation)&lt;/li&gt;
&lt;li&gt;Browsing most of the web on the console is tedious&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;
&lt;p&gt;First of all, it&amp;#39;s clear to me that I&amp;#39;d like a faster computer. Would a newer Raspberry Pi hit the sweet spot between performance and cheapness? What about an old laptop?&lt;/p&gt;
&lt;p&gt;Additionally, I&amp;#39;m still on the fence about wanting to stick to console mode. Ultimately, it&amp;#39;s an arbitrary goal, and I don&amp;#39;t think I&amp;#39;m aiming for it for any other reason than to see if it&amp;#39;s possible. It&amp;#39;s likely at some point I will break down and install a GUI environment. Maybe economizing a GUI is superior to maximizing the console?&lt;/p&gt;
&lt;p&gt;Regardless, I still plan to play around with a few more code editors and programming languages.&lt;/p&gt;
</content>
</entry>
<entry>
<title>In search of a minimal development environment, part 2</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html"/>
<updated>2023-02-26T00:00:00.000Z</updated>
<summary type="text">Some practical research into a minimal development environment.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html&quot;&gt;part 1&lt;/a&gt;, I was yearning for simpler times, when entire operating systems could fit on a single digit number of 1.44 MB floppy disks.&lt;/p&gt;
&lt;p&gt;What did my initial &amp;quot;minimal development environment&amp;quot; research uncover?&lt;/p&gt;
&lt;h1 id=&quot;platforms&quot;&gt;Platforms&lt;/h1&gt;
&lt;p&gt;Although it&amp;#39;s probably possible to run some useful software on a tiny or old platforms (e.g. a microcontroller or Game Boy), the smallest platform I seriously considered was a &lt;a href=&quot;https://www.raspberrypi.com/&quot;&gt;Raspberry Pi&lt;/a&gt; (for the simple reason that I inherited one and hadn&amp;#39;t been using it). My Raspberry Pi is a model B with 512 MB of RAM, apparently from 2012.&lt;/p&gt;
&lt;h1 id=&quot;operating-systems&quot;&gt;Operating systems&lt;/h1&gt;
&lt;p&gt;While investigating operating systems, I immediately had to confront the fact that I&amp;#39;m not looking for a &lt;em&gt;truly&lt;/em&gt; minimal operating system. The following OSes intrigued me, but they&amp;#39;re a little too restrictive/esoteric for my current goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://collapseos.org/&quot;&gt;Collapse OS&lt;/a&gt; runs on Z80-based hardware with 64 KB or less of RAM&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sr.ht/~vdupras/duskos/&quot;&gt;Dusk OS&lt;/a&gt; runs on x86 hardware, and can bootstrap itself into a &lt;a href=&quot;https://en.wikipedia.org/wiki/Forth_(programming_language)&quot;&gt;Forth&lt;/a&gt;-based shell with an &amp;quot;Almost C&amp;quot; compiler in just a few thousand lines of code&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fiwix.org/&quot;&gt;Fiwix&lt;/a&gt; uses a (relatively) small kernel (50k lines of code), but strives to be Linux-compatible&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://minix3.org/&quot;&gt;MINIX&lt;/a&gt; uses an educational kernel that has apparently made its way into Intel products, but the project is &lt;a href=&quot;https://github.com/o-oconnell/minixfromscratch&quot;&gt;no longer maintained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the end, I decided to focus on more popular platforms: Linux, FreeBSD, OpenBSD, and NetBSD. (Although I&amp;#39;d really like to explore Dusk OS in the future.)&lt;/p&gt;
&lt;p&gt;To my surprise, it looked like the smallest full-featured option (in terms of disk footprint, and ignoring &amp;quot;nano&amp;quot; installs that lack functionality) was probably &lt;a href=&quot;https://www.alpinelinux.org/&quot;&gt;Alpine Linux&lt;/a&gt;. A command-line only development environment on Debian weighed in at over 1.5 GB (!), but I was able to set up a somewhat comfortable C development environment on Alpine Linux in under 300 MB! (Although &lt;a href=&quot;https://wiki.alpinelinux.org/wiki/Raspberry_Pi&quot;&gt;installing Alpine Linux on a Raspberry Pi&lt;/a&gt; is tedious.)&lt;/p&gt;
&lt;p&gt;I&amp;#39;m a little nervous to adopt Alpine Linux without haven&amp;#39;t a good grasp of how updates (especially kernel updates) work, but so far it just feels like exactly what I was looking for.&lt;/p&gt;
&lt;h1 id=&quot;software&quot;&gt;Software&lt;/h1&gt;
&lt;p&gt;With a minimal Alpine Linux install on a Raspberry Pi model B, I investigated various console applications.&lt;/p&gt;
&lt;h2 id=&quot;web-browser&quot;&gt;Web browser&lt;/h2&gt;
&lt;p&gt;There are a lot of console web browser options today. I tried: &lt;a href=&quot;https://lynx.browser.org/&quot;&gt;Lynx&lt;/a&gt;, &lt;a href=&quot;http://elinks.or.cz/&quot;&gt;ELinks&lt;/a&gt;, &lt;a href=&quot;https://w3m.sourceforge.net/&quot;&gt;w3m&lt;/a&gt;, and a few that I don&amp;#39;t remember. In the past, I used ELinks because it seemed to have the most functionality, but as of today, my favorite is w3m. I liked its rendering the best, and it&amp;#39;s comfortable to use from the keyboard, thanks to vi-inspired key bindings. I will say that w3m has a steep learning curve (there aren&amp;#39;t any user-friendly menus, at least that I found), so it might not be a great choice for everyone.&lt;/p&gt;
&lt;p&gt;For the record: Lynx was oddly slow and ELinks&amp;#39;s menus seemed a little glitchy.&lt;/p&gt;
&lt;p&gt;Unfortunately, using the modern web from the console is not a pleasant experience. I ran into sites with huge navigation lists that I&amp;#39;d have to page through, sites that require JavaScript to render anything, etc. &lt;/p&gt;
&lt;h2 id=&quot;terminal-multiplexer&quot;&gt;Terminal multiplexer&lt;/h2&gt;
&lt;p&gt;I realize that &lt;a href=&quot;https://github.com/tmux/tmux/wiki&quot;&gt;tmux&lt;/a&gt; has a lot of momentum, but I&amp;#39;ve been using &lt;a href=&quot;https://www.gnu.org/software/screen/&quot;&gt;GNU Screen&lt;/a&gt; because I&amp;#39;m already familiar with it. tmux &lt;em&gt;does&lt;/em&gt; seem to have some nice features (e.g. retaining panes across detach/reattach), so it&amp;#39;s probably what I&amp;#39;d use today if I was starting from scratch.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s also &lt;a href=&quot;https://zellij.dev/&quot;&gt;Zellij&lt;/a&gt;, which has some interesting ideas (namely floating windows), wrapped up in what appears to be a user-friendly interface. I haven&amp;#39;t tried it yet, however.&lt;/p&gt;
&lt;h2 id=&quot;rss-reader&quot;&gt;RSS reader&lt;/h2&gt;
&lt;p&gt;One motivation for setting up a simpler development environment is to slow down and reduce distractions. With some freed up &amp;quot;focus&amp;quot; time, I&amp;#39;d like to get back to using RSS feeds to keep up to date on blogs I enjoy. &lt;a href=&quot;https://newsboat.org/&quot;&gt;Newsboat&lt;/a&gt; is an excellent console RSS reader.&lt;/p&gt;
&lt;h2 id=&quot;irc&quot;&gt;IRC&lt;/h2&gt;
&lt;p&gt;And why stop at RSS? Let&amp;#39;s go all the way back to 1988 and use &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Relay_Chat&quot;&gt;IRC&lt;/a&gt;! I don&amp;#39;t like how &lt;a href=&quot;https://discord.com/&quot;&gt;Discord&lt;/a&gt; has monopolized chat-based communities, but IRC is fairly tedious to set up, and the command-based interface is unfriendly (the last thing I want to do is embarrass myself by mistyping a command and having everyone see it as a chat message!).&lt;/p&gt;
&lt;p&gt;I have &lt;a href=&quot;https://irssi.org/&quot;&gt;irssi&lt;/a&gt; installed, but I haven&amp;#39;t really used it enough to say whether this is a good choice for IRC (or if IRC is even a good choice at all).&lt;/p&gt;
&lt;h2 id=&quot;code-editor&quot;&gt;Code editor&lt;/h2&gt;
&lt;p&gt;I haven&amp;#39;t investigated editor options in depth yet. The main features I&amp;#39;m looking for are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Runs in console mode&lt;/li&gt;
&lt;li&gt;Comfortable editing&lt;/li&gt;
&lt;li&gt;Helpful syntax highlighting&lt;/li&gt;
&lt;li&gt;Language-specific features (from most important to least):&lt;ul&gt;
&lt;li&gt;Auto-complete/lookup&lt;/li&gt;
&lt;li&gt;Go to definition&lt;/li&gt;
&lt;li&gt;Find all references&lt;/li&gt;
&lt;li&gt;Rename/refactor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now, I&amp;#39;m using &lt;a href=&quot;https://www.vim.org/&quot;&gt;Vim&lt;/a&gt;, with nothing but default syntax highlighting and &amp;quot;Ctrl+N&amp;quot; as a minimal auto-complete. This was great in the 90s, but I&amp;#39;m more productive with advanced language features.&lt;/p&gt;
&lt;p&gt;Here are a few options I&amp;#39;m planning to investigate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vim with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ctags&quot;&gt;Ctags&lt;/a&gt; (ideally automated)&lt;/li&gt;
&lt;li&gt;Vim/&lt;a href=&quot;https://neovim.io/&quot;&gt;NeoVim&lt;/a&gt; with an actual &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;language server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://helix-editor.com/&quot;&gt;Helix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kakoune.org/&quot;&gt;Kakoune&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and maybe even &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;Emacs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;but-am-i-making-a-mistake&quot;&gt;But... am I making a mistake?&lt;/h1&gt;
&lt;p&gt;After a couple of days using this setup, I&amp;#39;m already starting to question my decision to use the console.&lt;/p&gt;
&lt;h2 id=&quot;console-web-experience-isnt-great&quot;&gt;Console web experience isn&amp;#39;t great&lt;/h2&gt;
&lt;p&gt;The biggest issue is that the web is really hard to use from a terminal. It&amp;#39;s difficult to quickly scan headings and identify distinct content areas using only text (specifically: text that wasn&amp;#39;t designed to be used from the console). I guess I didn&amp;#39;t realize how helpful subtle font size/color changes are for quickly scanning content.&lt;/p&gt;
&lt;h2 id=&quot;sometimes-the-mouse-is-handy&quot;&gt;Sometimes the mouse is handy&lt;/h2&gt;
&lt;p&gt;Then there&amp;#39;s mouse support. I use the keyboard extensively, but the mouse is sometimes faster for selecting text and interacting with UI elements that aren&amp;#39;t in a simple order/hierarchy. &lt;a href=&quot;https://man.archlinux.org/man/gpm.8.en.html&quot;&gt;GPM&lt;/a&gt; helps, but it&amp;#39;s kind of clunky, and doesn&amp;#39;t help when I need to scroll text while using the mouse.&lt;/p&gt;
&lt;h2 id=&quot;lack-of-consistency&quot;&gt;Lack of consistency&lt;/h2&gt;
&lt;p&gt;Finally, there is very little user interface consistency between most console tools. Many include vi-like key bindings (either by default or with customizations), but that&amp;#39;s often where the consistency ends. I guess I didn&amp;#39;t realize how much I&amp;#39;d come to rely on standard GUI elements like menus, tooltips, and buttons. I &lt;em&gt;do&lt;/em&gt; think that a searchable &amp;quot;command palette&amp;quot; would go a long way toward making console tools easier to use, but I&amp;#39;m not planning on implementing those myself. Using Emacs for everything might help with consistency, but I&amp;#39;m skeptical of the performance and robustness of huge pile of Emacs extensions.&lt;/p&gt;
&lt;h1 id=&quot;to-be-continued&quot;&gt;To be continued...&lt;/h1&gt;
&lt;p&gt;Next up, I&amp;#39;m planning to document my misadventures in getting &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt; (my &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt;-based static site generator) running on a Raspberry Pi B (a platform that Deno doesn&amp;#39;t support).&lt;/p&gt;
</content>
</entry>
<entry>
<title>Future-proof programming languages, part 2</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html"/>
<updated>2023-02-17T00:00:00.000Z</updated>
<summary type="text">More research on future-proof programming languages.</summary>
<content type="html">&lt;p&gt;Almost exactly 1 year ago, in &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;part 1&lt;/a&gt;, I enumerated a bunch of popular programming languages and tried to quickly determine which ones seemed like they&amp;#39;d still be useful in another decade. In the intervening time, I&amp;#39;ve completed some nontrivial projects in both TypeScript (using both Node and Deno) and Python. I&amp;#39;ve also spent time contemplating a &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html&quot;&gt;minimal development environment&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this post, I&amp;#39;m going to add a few more items to my programming language wishlist, add a few more programming languages to my candidate list, and then briefly describe my initial experiences with a few of those languages.&lt;/p&gt;
&lt;h1 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;I don&amp;#39;t have a lot of experience with most of these programming languages. I&amp;#39;ve written a lot of code in various languages (mostly C, C++, C#, TypeScript, and Lua), but I am by no means an expert at assessing programming languages. Feel free to send corrections to &lt;a href=&quot;mailto:&amp;#108;&amp;#111;&amp;#x67;&amp;#x40;&amp;#x73;&amp;#x63;&amp;#104;&amp;#101;&amp;#109;&amp;#x65;&amp;#115;&amp;#x63;&amp;#x61;&amp;#112;&amp;#101;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#109;&quot;&gt;&amp;#108;&amp;#111;&amp;#x67;&amp;#x40;&amp;#x73;&amp;#x63;&amp;#104;&amp;#101;&amp;#109;&amp;#x65;&amp;#115;&amp;#x63;&amp;#x61;&amp;#112;&amp;#101;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#109;&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;there-can-be-more-than-one&quot;&gt;There can be more than one&lt;/h1&gt;
&lt;p&gt;Note: I&amp;#39;ve come to terms with the fact that I&amp;#39;ll probably end up needing to use several of these languages for different purposes, namely I&amp;#39;ll want to have one fast, ahead-of-time compiled language for performance-critical projects, and something simpler and more dynamic (while still low-overhead) for most everything else.&lt;/p&gt;
&lt;h1 id=&quot;wishlist&quot;&gt;Wishlist&lt;/h1&gt;
&lt;p&gt;In part 1, I &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html#indicators&quot;&gt;listed&lt;/a&gt; some indicators of a future-proof programming language, along with a wishlist of conveniences/ergonomics. Here are some additions (in &lt;strong&gt;bold&lt;/strong&gt;) to my &amp;quot;programming language wishlist&amp;quot;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No multi-gigabyte downloads just to get started&lt;/li&gt;
&lt;li&gt;Not tied to a single platform/environment/tool set&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fully usable for development on many platforms&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Small and simple (in case I want to build my own tools)&lt;/li&gt;
&lt;li&gt;Easily cross-compiled&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Trivial to deploy&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Simple and transparent build process&lt;/li&gt;
&lt;li&gt;Readily available libraries (either with source available or from reputable contributors)&lt;/li&gt;
&lt;li&gt;Ergonomic editing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Not subject to the whims of a single company&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;del&gt;Easy&lt;/del&gt; Possible to bootstrap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most these additions are in response to what I&amp;#39;ve seen while investigating a few languages. Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python and Clojure don&amp;#39;t appear to be trivial deploy (especially for Python with dependencies)&lt;/li&gt;
&lt;li&gt;C# and Go are tied to for-profit companies, both of which are known for canning unprofitable projects (one notoriously so)&lt;/li&gt;
&lt;li&gt;Small languages written in C, like Lua, would be easy to bootstrap in the future, should the need arise (e.g. if I want to move to a new or old platform that isn&amp;#39;t already supported)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;additional-candidates&quot;&gt;Additional candidates&lt;/h1&gt;
&lt;p&gt;My original (pruned) list of candidate languages included:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript/TypeScript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Lisp/Clojure&lt;/li&gt;
&lt;li&gt;Zig&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;m going to add a few more languages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tcl&lt;/strong&gt;: I&amp;#39;ve only briefly used Tcl in the past, but it seems great for command line &amp;quot;glue&amp;quot;, and the language itself (at least what I&amp;#39;ve experienced) is beautifully simple&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;: I originally discarded Lua because in the past I found its quirks to be too annoying, but that experience was mostly 10+ years ago, and there have been multiple major updates since then&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aside: I&amp;#39;m intrigued by &lt;a href=&quot;https://vale.dev/&quot;&gt;The Vale Programming Language&lt;/a&gt;, but it&amp;#39;s not even close to done yet.&lt;/p&gt;
&lt;h1 id=&quot;some-early-observations&quot;&gt;Some early observations&lt;/h1&gt;
&lt;p&gt;Eventually, I&amp;#39;ll probably compile a big table of these languages, along with an assessment with respect to each of my criteria, but for now I&amp;#39;ve just got a few initial notes.&lt;/p&gt;
&lt;h2 id=&quot;compilerruntime-installation&quot;&gt;Compiler/runtime installation&lt;/h2&gt;
&lt;h3 id=&quot;javascripttypescript&quot;&gt;JavaScript/TypeScript&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt; makes running TypeScript trivially easy, but its list of supported platforms is short (notably, it does not include 32-bit Windows!). &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node&lt;/a&gt; supports 32-bit Windows, but is much less convenient.&lt;/p&gt;
&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;
&lt;p&gt;Ah, my old nemesis: Python. I&amp;#39;ve never had a good experience setting up a Python environment. Additionally, the Python 2 to 3 migration (which included unnecessary things like &lt;a href=&quot;https://www.python.org/dev/peps/pep-0238/&quot;&gt;changing the semantics of the division operator&lt;/a&gt;) is remarkable only in that it didn&amp;#39;t kill Python entirely (at least not yet).&lt;/p&gt;
&lt;p&gt;Yet Python is consistently one of the most popular programming languages. What am I missing?&lt;/p&gt;
&lt;p&gt;Anyway, the &lt;a href=&quot;https://wiki.python.org/moin/BeginnersGuide/Download&quot;&gt;Python installation docs&lt;/a&gt; recommend seeing if you already have Python installed by typing &lt;code&gt;python&lt;/code&gt; into a command window. To my surprise, I don&amp;#39;t immediately see an &amp;quot;unrecognized command&amp;quot; error. Incredibly, it launches to a Python page in the Microsoft Store (compliments of &lt;code&gt;%LocalAppData%\Microsoft\WindowsApps\python.exe&lt;/code&gt; -- seriously!?). I&amp;#39;ll give it a try since it&amp;#39;s a surprisingly reasonable ~100 MB download. It appears to install a Python runtime and the IDLE editor.&lt;/p&gt;
&lt;p&gt;Honestly, I&amp;#39;m not thrilled that Microsoft decided to &lt;a href=&quot;https://devblogs.microsoft.com/python/python-in-the-windows-10-may-2019-update/&quot;&gt;insert this Python shim into Windows itself&lt;/a&gt; just to make it easier for people to find Python, but I guess I&amp;#39;ll try it out. Note that I&amp;#39;ll almost certainly be using VS Code and the official Python extension for editing and debugging.&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C#&lt;/h3&gt;
&lt;p&gt;To my surprise, the &lt;a href=&quot;https://github.com/dotnet/roslyn&quot;&gt;C# compiler&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime&quot;&gt;.NET runtime&lt;/a&gt; are both now open source (MIT license). Even more surprising, you can now apparently &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/iot/deployment&quot;&gt;deploy self-contained .NET executables to a Raspberry Pi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C# is a great language and the .NET standard library is probably the most thoughtfully crafted standard library I&amp;#39;ve ever used. So is my search over? Is C# the answer?&lt;/p&gt;
&lt;p&gt;First, I need to setup a C# development environment. I&amp;#39;m developing on Windows (.NET&amp;#39;s home platform), so this might give me an unrealistically positive impression of C#&amp;#39;s convenience.&lt;/p&gt;
&lt;p&gt;After selecting the .NET runtime and SDK in the Visual Studio installer, I am appalled to see that it requires &lt;em&gt;5 GB&lt;/em&gt; of disk space! There&amp;#39;s probably a bunch of extraneous junk I don&amp;#39;t need, but for comparison: Visual Studio Code is ~300 MB and Deno&amp;#39;s TypeScript runtime is ~60 MB.&lt;/p&gt;
&lt;p&gt;Since I was curious, I checked out the &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/core/install/linux-debian&quot;&gt;.NET SDK for Linux (Debian)&lt;/a&gt;, and it was closer to 500 MB. To my surprise, it was very full-featured, and I was even able to cross-compile for Windows from Linux.&lt;/p&gt;
&lt;p&gt;As much as I like C#, the unreasonable disk footprint of its tooling has sent C# to the bottom of the pile.&lt;/p&gt;
&lt;h3 id=&quot;c-1&quot;&gt;C++&lt;/h3&gt;
&lt;p&gt;C++ sort of gets a free pass because Linux distributions generally provide the GNU C++ compiler and I already had to install a C++ environment in order to use Rust on Windows. Clang is &amp;lt; 1 GB to install and there are numerous free and/or open source C++ IDEs that are less than 1 GB. Visual Studio for C++ was around 3 GB, which is much too big, but not an immediate disqualifier in light of available alternatives. At least there&amp;#39;s a free version now.&lt;/p&gt;
&lt;h3 id=&quot;c-2&quot;&gt;C&lt;/h3&gt;
&lt;p&gt;C is similar to C++, with the notable property that it is trivially bootstrap-able on some popular architectures using the &lt;a href=&quot;https://bellard.org/tcc/&quot;&gt;Tiny C Compiler&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;go&quot;&gt;Go&lt;/h3&gt;
&lt;p&gt;Go for Windows is a reasonable ~125 MB download, and VS Code has an official Go extension. I&amp;#39;ve heard that Go&amp;#39;s tooling is excellent and what I&amp;#39;ve seen thus far (e.g. &lt;code&gt;go fmt&lt;/code&gt;) is similar to what I liked about &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../web-development/one-month-with-deno.html&quot;&gt;Deno&lt;/a&gt;. It only took a couple of minutes (for me, a complete Go newbie) to get a &amp;quot;hello world&amp;quot; program up and running (with debugging, no less).&lt;/p&gt;
&lt;h3 id=&quot;rust&quot;&gt;Rust&lt;/h3&gt;
&lt;p&gt;Setting up a Rust environment on Windows &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;is not pleasant&lt;/a&gt; because it requires first installing Visual C++ (a multi-gigabyte download). On Linux, installation is a breeze, but that doesn&amp;#39;t help me much.&lt;/p&gt;
&lt;h3 id=&quot;lispclojure&quot;&gt;Lisp/Clojure&lt;/h3&gt;
&lt;p&gt;Honestly, I haven&amp;#39;t investigated this option yet.&lt;/p&gt;
&lt;p&gt;Clojure requires a Java runtime and, at the moment, I don&amp;#39;t really want to install one. I used Java a lot in the past (back when it would pop up messages saying a new version of Java was available, with a possibly ironic exclamation mark), but I don&amp;#39;t want to deal with deploying Java whenever I want to run something.&lt;/p&gt;
&lt;p&gt;Some other Lisp options include &lt;a href=&quot;https://racket-lang.org/&quot;&gt;Racket&lt;/a&gt; (which I&amp;#39;ve briefly used in the past) and &lt;a href=&quot;http://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt; (which I have no experience with, but seems more popular).&lt;/p&gt;
&lt;h3 id=&quot;zig&quot;&gt;Zig&lt;/h3&gt;
&lt;p&gt;Zig is a smallish download, with a developer-friendly command line interface that appears to be on par with Go and Deno.&lt;/p&gt;
&lt;h3 id=&quot;tcl&quot;&gt;Tcl&lt;/h3&gt;
&lt;p&gt;Tcl is a trivially small download. I&amp;#39;ll need to see how adding libraries (namely &lt;a href=&quot;https://www.tcl.tk/software/tcllib/&quot;&gt;Tcllib&lt;/a&gt;) works.&lt;/p&gt;
&lt;h3 id=&quot;lua&quot;&gt;Lua&lt;/h3&gt;
&lt;p&gt;While Lua binaries are available, Lua is more of a library that&amp;#39;s meant to be embedded in an application. I thought there was a simple command line wrapper for Windows, but the main one I&amp;#39;ve found for Windows (&lt;a href=&quot;https://github.com/rjpcomputing/luaforwindows&quot;&gt;Lua for windows&lt;/a&gt;) appears to be unmaintained. It&amp;#39;s possible &lt;a href=&quot;https://luarocks.org/&quot;&gt;LuaRocks&lt;/a&gt; might be what I&amp;#39;m looking for, but I&amp;#39;m not sure yet.&lt;/p&gt;
&lt;p&gt;The good news is that I could easily bootstrap my own Lua shell (similar to what &lt;a href=&quot;https://blubsblog.bearblog.dev/writing-software-that-will-still-build-and-run-in-20-years/&quot;&gt;Blub describes in a blog post&lt;/a&gt;).&lt;/p&gt;
&lt;h1 id=&quot;closing-thoughts&quot;&gt;Closing thoughts&lt;/h1&gt;
&lt;p&gt;Based on intuition and my experiences thus far, a few languages are at the bottom of the pack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;: A complicated language, with an inscrutable standard library, still without a good module or build system -- but I have a lot of experience with it, and it&amp;#39;s definitely not going anywhere&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zig&lt;/strong&gt;: The most promising &amp;quot;better C&amp;quot;, with great tooling, but still immature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A few languages are lingering in the middle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt;: A great language, with probably the best standard library, but the toolchain is enormous&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: Arguably the most portable language, just with a mostly awful standard library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: Supposedly even more complicated than C++, but at least it provides memory safety and a build system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lisp&lt;/strong&gt;: An interesting and versatile language, but is it &lt;em&gt;used&lt;/em&gt; as much as it&amp;#39;s &lt;em&gt;discussed&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;: Almost as portable as C, but I&amp;#39;m not sure I want to bring my own everything&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And then there are a few languages near the top of my list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript/TypeScript&lt;/strong&gt;: A convenient language, made better by Deno&amp;#39;s tooling and standard library, but still fairly volatile and without an official ecosystem-wide standard library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;: An ugly pile of hacks that is adored by many and is ubiquitous -- do I just need to get over my aversion to Python? Has deployment been solved yet?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go&lt;/strong&gt;: Great tooling, a simple language, memory safety, and an allegedly great standard library -- I&amp;#39;d never considered Go before, but it has a lot of attractive qualities&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tcl&lt;/strong&gt;: A beautifully simple language with a tiny footprint and great for gluing things together -- but will it be forgotten in another decade or two?&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>In search of a minimal development environment</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html"/>
<updated>2023-02-11T00:00:00.000Z</updated>
<summary type="text">What would a minimal development environment look like? How small could it be?</summary>
<content type="html">&lt;p&gt;Feel free to &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/#the-plan&quot;&gt;skip over the obligatory whining about today&amp;#39;s bloat&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;back-in-my-day&quot;&gt;Back in my day...&lt;/h1&gt;
&lt;p&gt;I think the first computer I ever used was a &lt;a href=&quot;https://en.wikipedia.org/wiki/Commodore_64&quot;&gt;Commodore 64&lt;/a&gt;. Wikipedia tells me that it had a 1 MHz processor and 64 KB of RAM, all packed into an &amp;quot;obese keyboard&amp;quot; form factor. Despite being 100,000+ times slower (with a similar fraction of memory) compared to a modern computer, it could run a word processor, play games, and print documents.&lt;/p&gt;
&lt;p&gt;Later on, I remember installing Linux on a 1.44 MB floppy disk to turn an aging 486 computer into a network router. Even back then, that was impressive!&lt;/p&gt;
&lt;p&gt;A few years later, I remember working on a simple arcade game which used OpenGL for graphics... developed partly on a computer that was command line-only! I have fond memories of using &lt;a href=&quot;https://www.gnu.org/software/screen/&quot;&gt;GNU Screen&lt;/a&gt; and &lt;a href=&quot;https://www.vim.org/&quot;&gt;Vim&lt;/a&gt;, along with &lt;a href=&quot;https://en.wikipedia.org/wiki/Man_page&quot;&gt;man pages&lt;/a&gt;, to write the code. Aside: I remember using &lt;a href=&quot;https://en.wikipedia.org/wiki/Concurrent_Versions_System&quot;&gt;CVS&lt;/a&gt;, but &lt;em&gt;not&lt;/em&gt; fondly.&lt;/p&gt;
&lt;h1 id=&quot;contrast-with-today&quot;&gt;Contrast with today&lt;/h1&gt;
&lt;p&gt;Fast-forward to 2023, and I&amp;#39;ve been contemplating porting my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../game-development/sic-1.html&quot;&gt;single-instruction programming game&lt;/a&gt; to &lt;a href=&quot;https://www.electronjs.org/&quot;&gt;Electron&lt;/a&gt; (possibly the heaviest popular app framework of all time), to support Linux (and ideally macOS) builds on Steam.&lt;/p&gt;
&lt;p&gt;For the record, SIC-1 started out as a trim 25 KB zip file (although it has ballooned to 10 MB, mostly due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulse-code_modulation&quot;&gt;PCM&lt;/a&gt; music). Browsers provide a deceptive environment. With a few kilobytes of HTML, CSS, and JavaScript, you can build surprisingly complex (and fast) apps. Of course, the browser itself is hundreds of megabytes, so it&amp;#39;s actually a pretty hefty runtime. How hefty? Ask me after I use Electron.&lt;/p&gt;
&lt;p&gt;Is it any surprise I&amp;#39;m craving a bit of simplicity?&lt;/p&gt;
&lt;h1 id=&quot;the-plan&quot;&gt;The plan&lt;/h1&gt;
&lt;p&gt;So what am I going to do about bloat?&lt;/p&gt;
&lt;p&gt;This is probably a terrible idea, but I&amp;#39;d like to set up a minimal development environment. And I really do mean &amp;quot;minimal&amp;quot;, i.e.:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command line only&lt;/li&gt;
&lt;li&gt;Runs acceptably on a slow computer (possibly a &lt;a href=&quot;https://en.wikipedia.org/wiki/Raspberry_Pi&quot;&gt;Raspberry Pi&lt;/a&gt; 1)&lt;/li&gt;
&lt;li&gt;Minimal disk footprint&lt;/li&gt;
&lt;li&gt;As full-featured as possible, given the previous constraints&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, &amp;quot;minimal disk footprint&amp;quot; and &amp;quot;as full-featured as possible&amp;quot; are opposing goals, so this plan isn&amp;#39;t well-defined--I&amp;#39;m content to just see where it leads me.&lt;/p&gt;
&lt;h1 id=&quot;the-software&quot;&gt;The software&lt;/h1&gt;
&lt;p&gt;I suspect the following software will play a part:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.alpinelinux.org/&quot;&gt;Alpine Linux&lt;/a&gt; or a minimal &lt;a href=&quot;https://www.debian.org/&quot;&gt;Debian&lt;/a&gt; installation (or &lt;a href=&quot;https://www.freebsd.org/&quot;&gt;FreeBSD&lt;/a&gt;? &lt;a href=&quot;https://minix3.org/&quot;&gt;MINIX 3&lt;/a&gt;? I&amp;#39;m open to suggestions)&lt;/li&gt;
&lt;li&gt;Vim (or &lt;a href=&quot;https://neovim.io/&quot;&gt;NeoVim&lt;/a&gt;?)&lt;/li&gt;
&lt;li&gt;GNU Screen (or &lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux&lt;/a&gt;?)&lt;/li&gt;
&lt;li&gt;A terminal mode web browser (&lt;a href=&quot;https://lynx.browser.org/&quot;&gt;Lynx&lt;/a&gt;?)&lt;/li&gt;
&lt;li&gt;Maybe a terminal mode &lt;a href=&quot;https://en.wikipedia.org/wiki/RSS&quot;&gt;RSS&lt;/a&gt; reader or &lt;a href=&quot;https://mastodon.social/&quot;&gt;Mastodon&lt;/a&gt; client, just for fun&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;the-programming-language&quot;&gt;The programming language&lt;/h1&gt;
&lt;p&gt;You may note that I didn&amp;#39;t specify any compilers or build tools. That&amp;#39;s because I&amp;#39;d like to use this minimal environment to test out some of my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../programming-languages/future-proof-languages.html&quot;&gt;future-proof programming language candidates&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll admit that it&amp;#39;s unreasonable to expect modern programming languages to support development on a Raspberry Pi, but that also means that I&amp;#39;ll be &lt;em&gt;unreasonably impressed&lt;/em&gt; if a programming language is useful in a ridiculously constrained environment like this.&lt;/p&gt;
&lt;h1 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h1&gt;
&lt;p&gt;Feel free to let me know if you have any suggestions or if you&amp;#39;ve attempted anything similar (or want to!). You can email me at any address at the &amp;quot;.com&amp;quot; address in the address bar.&lt;/p&gt;
&lt;p&gt;Wish me luck!&lt;/p&gt;
</content>
</entry>
<entry>
<title>SIC-1: A single-instruction programming game</title>
<id>https://log.schemescape.com/posts/game-development/sic-1.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1.html"/>
<updated>2022-12-06T00:00:00.000Z</updated>
<summary type="text">SIC-1 is a single-instruction (subleq) programming game that can be played via Steam or the browser.</summary>
<content type="html">&lt;p&gt;&lt;strong&gt;SIC-1&lt;/strong&gt; is a single-instruction (&lt;a href=&quot;https://esolangs.org/wiki/Subleq&quot;&gt;subleq&lt;/a&gt;) programming game with &amp;quot;zachlike&amp;quot; optimization leaderboards. It can be played here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://store.steampowered.com/app/2124440/SIC1/&quot;&gt;SIC-1 on Steam (Windows)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jaredkrinke.itch.io/sic-1&quot;&gt;SIC-1 on itch.io (browser)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;This game originally started as an experiment to write a subleq assembler that supported labels. After creating the initial assembler, I was inspired by the &lt;a href=&quot;https://www.zachtronics.com/index.html&quot;&gt;Zachtronics&lt;/a&gt; game &lt;a href=&quot;https://www.zachtronics.com/tis-100/&quot;&gt;TIS-100&lt;/a&gt; to create a series of programming puzzles involving subleq.&lt;/p&gt;
&lt;p&gt;I mostly just wanted to learn for myself how to implement variables and functions in a subleq computer.&lt;/p&gt;
&lt;h2 id=&quot;prototype-and-initial-release&quot;&gt;Prototype and initial release&lt;/h2&gt;
&lt;p&gt;After getting thoroughly carried away, I ended up creating a service (initially using &lt;a href=&quot;https://www.sqlite.org/index.html&quot;&gt;SQLite&lt;/a&gt;, then later &lt;a href=&quot;https://firebase.google.com/docs/firestore/&quot;&gt;Firestore&lt;/a&gt; + &lt;a href=&quot;https://functions.netlify.com/&quot;&gt;Netlify Functions&lt;/a&gt;) for storing players&amp;#39; scores so that people could compete against one another to find the most efficient programs.&lt;/p&gt;
&lt;p&gt;I released the game (for free) in late 2019 on &lt;a href=&quot;https://itch.io/&quot;&gt;itch.io&lt;/a&gt; and it eventually took the top free spot on itch.io for the search term &amp;quot;zachlike&amp;quot;. Over the ensuing two years, the game was played thousands of times (although only roughly 1,000 people completed nontrivial puzzles). I was thrilled to hear from people I&amp;#39;d never met before that they loved the game.&lt;/p&gt;
&lt;h2 id=&quot;preparing-for-a-release-on-steam&quot;&gt;Preparing for a release on Steam&lt;/h2&gt;
&lt;p&gt;In the fall of 2022, after putting it off for far too long, I decided to start porting SIC-1 to Steam. I&amp;#39;d always wanted to release a game on Steam, and I thought Steam might provide a new audience for the game.&lt;/p&gt;
&lt;p&gt;Although Steam allows anyone to release a game (after paying the $100 Steam Direct fee), I wanted to improve the quality of the game so that it looked more like a real game instead of a prototype. This plan snowballed into multi-month effort that included learning many new skills and tools to add game features such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;Sound effects&lt;/li&gt;
&lt;li&gt;Achievements&lt;/li&gt;
&lt;li&gt;A new narrative&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Despite being tedious at times, experimenting with things like creating music using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Yamaha_DX7&quot;&gt;Yamaha DX7&lt;/a&gt;-inspired &lt;a href=&quot;https://asb2m10.github.io/dexed/&quot;&gt;dexed synth&lt;/a&gt; turned out to be surprisingly enjoyable. Having a goal in mind and a rough schedule motivated me to produce several tracks of music--something I&amp;#39;d never really done before.&lt;/p&gt;
&lt;p&gt;The most difficult decision I had to make was whether or not to try and charge for the game. In the end, I decided to keep the game free for a couple of reasons:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It seemed unlikely I would sell enough copies to have a meaningful financial impact on my life&lt;/li&gt;
&lt;li&gt;I wanted as many people to play the game as possible, partly to ensure the leaderboards would have enough scores to spur competition&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;steam-release&quot;&gt;Steam release&lt;/h1&gt;
&lt;p&gt;Last Friday, I released SIC-1 on Steam.&lt;/p&gt;
&lt;p&gt;Although marketing is not my strong suit, I created a marketing plan with a list of ideas and a rough schedule. Unfortunately, my most promising marketing idea (sharing the game on a web site where esoteric programming languages are popular) garnered very little attention. In the end, the most impactful marketing for the game has simply been pushing the &amp;quot;release&amp;quot; button on Steam. In other words, my marketing efforts had negligible impact.&lt;/p&gt;
&lt;h1 id=&quot;near-term-goals&quot;&gt;Near-term goals&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ve never been clear on what my goal was with developing this game. It&amp;#39;s morphed over time and included thoughts such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I just want to see if I can make a good game&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to see if there&amp;#39;s an audience for my work&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to have the experience of releasing a game, specifically on Steam&lt;/li&gt;
&lt;li&gt;I want people to enjoy something I&amp;#39;ve created&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For now, my only concrete goal is to &lt;strong&gt;get 10 reviews on Steam by the end of 2022&lt;/strong&gt;. I&amp;#39;m not sure if this threshold is used for free games, but I&amp;#39;ve heard that games need 10 reviews on Steam before they&amp;#39;re marked with &amp;quot;positive&amp;quot; (or &amp;quot;mixed&amp;quot; or &amp;quot;negative&amp;quot;) reviews.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: SIC-1 ended the month (and calendar year) with 8 reviews on Steam. That&amp;#39;s within striking distance of my goal of 10 reviews, so I&amp;#39;ll consider this goal to be &lt;em&gt;almost&lt;/em&gt; achieved.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Second Update&lt;/strong&gt;: SIC-1 hit 10 Steam reviews on January 18th! The amount of traffic to the Steam page has increased roughly 10x (the number of people &lt;em&gt;playing&lt;/em&gt; SIC-1 has not increased nearly as dramatically--but that&amp;#39;s ok, given that it&amp;#39;s a niche game).&lt;/p&gt;
&lt;h1 id=&quot;one-last-note&quot;&gt;One last note&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s all for now. Wish me luck! And if you like programming games or are interested in subleq, please give SIC-1 a try on Steam:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://store.steampowered.com/app/2124440/SIC1/&quot;&gt;https://store.steampowered.com/app/2124440/SIC1/&lt;/a&gt;&lt;/p&gt;
</content>
</entry>
</feed>
