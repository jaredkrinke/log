<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-04-06T22:42:56.414Z</updated>

<entry>
<title>Minimal dev environment, part 4</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-4.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-4.html"/>
<updated>2023-04-06T00:00:00.000Z</updated>
<summary type="text">My minimal development environment was too minimal, so I upgraded to a faster computer.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html&quot;&gt;part 3&lt;/a&gt;, I tried out a minimal development environment (based on Alpine Linux) on a Raspberry Pi 1 B. This update is essentially the conclusion of my Raspberry Pi experiment.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s a summary of what I&amp;#39;ve learned so far:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I love Alpine Linux--it honestly feels like the only sane way to manage a Linux distribution--because it&amp;#39;s fast, light, and (mostly) only contains the tools you ask for&lt;/li&gt;
&lt;li&gt;The Raspberry Pi 1 B is &lt;em&gt;very&lt;/em&gt; slow--I was willing to accept that my JavaScript/Deno-based static site generator might be slow (I never really optimized it), but paging through code in Vim (in the terminal) is something I &lt;em&gt;need&lt;/em&gt; to be fast, and my Pi-based setup failed at this&lt;/li&gt;
&lt;li&gt;Browsing the modern web in a terminal is unpleasant&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;enter-the-gui&quot;&gt;Enter the GUI&lt;/h1&gt;
&lt;p&gt;To address the last point, I decided to see if I could get a lightweight GUI environment running on the Pi. I hadn&amp;#39;t run a Linux desktop in over a decade, but I previously used &lt;a href=&quot;http://fluxbox.org/&quot;&gt;Fluxbox&lt;/a&gt; and later &lt;a href=&quot;https://www.gnome.org/&quot;&gt;GNOME&lt;/a&gt;, so I&amp;#39;m not completely lost. The latter is a full desktop environment, and fairly heavy, so I decided to give Fluxbox a shot first (after reading up on how to run rootless X.org).&lt;/p&gt;
&lt;p&gt;Getting X.org up and running with Fluxbox wasn&amp;#39;t too difficult, and then I was able to use the &lt;a href=&quot;https://www.dillo.org/&quot;&gt;Dillo browser&lt;/a&gt; to improve my web browsing experience. Unfortunately, everything GUI-related was painfully slow, especially moving windows around. Just in case I was missing some sort of hardware acceleration or something, I tested out the official Raspberry Pi OS. It was unbearably slow as well (and the build of Chromium appeared to be for ARMv7, which my Pi doesn&amp;#39;t support).&lt;/p&gt;
&lt;h1 id=&quot;goodbye-pi&quot;&gt;Goodbye, Pi&lt;/h1&gt;
&lt;p&gt;To be honest, it&amp;#39;s impressive how much you can do with a 10+ year-old, less than $50 (originally) single-board computer (running at 3.5 Watts). I could run Linux, edit and compile C code, browse the web in a terminal, read RSS feeds, and even run Node/NPM. It seems perfect for running a low-traffic server at home (something I &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../services/cheap-hosting.html&quot;&gt;don&amp;#39;t need to do at the moment&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;But the bottom line is that I want something faster.&lt;/p&gt;
&lt;p&gt;There are newer Raspberry Pi models that should be &lt;em&gt;much&lt;/em&gt; faster than my almost-original--and I&amp;#39;d like to try one out someday--but for now I&amp;#39;m proceeding with hardware that I already own. &lt;/p&gt;
&lt;h1 id=&quot;hello-netbook&quot;&gt;Hello, netbook&lt;/h1&gt;
&lt;p&gt;Specifically, I&amp;#39;m upgrading to a 12 year-old Dell netbook (Inspiron Mini 1018) with a 1.66 GHz Intel Atom (N455) processor and 1 GB of RAM.&lt;/p&gt;
&lt;h2 id=&quot;linux-on-a-laptop-is-pretty-great&quot;&gt;Linux on a laptop... is pretty great!&lt;/h2&gt;
&lt;p&gt;As an aside, I&amp;#39;m compelled to comment on how much the laptop experience on Linux has improved since I last gave up (in the mid-00s). The sub-200 MB Alpine Linux installer &lt;em&gt;just worked&lt;/em&gt;, even for Wi-Fi! Additionally, I discovered that, even though the netbook shipped with 32-bit Windows, its processor is actually 64-bit, so now I&amp;#39;m running an architecture that is &lt;em&gt;still relevant&lt;/em&gt;. This is intriguing to me because Deno only supports 64-bit processors, and I assumed that the old hardware I had laying around couldn&amp;#39;t run Deno.&lt;/p&gt;
&lt;p&gt;Having said that, at one point I decided to see if Debian would work better than Alpine. The Debian installer worked great (it automatically supported wireless networking on my netbook), but after installation wireless stopped working. After a few hours of researching and trying to fix the problem, I reverted back to Alpine.&lt;/p&gt;
&lt;p&gt;For the record, only &amp;quot;suspend&amp;quot; works on this laptop (hibernate is indistinguishable from powering off). I also have to manually adjust the terminal resolution using &lt;code&gt;fbset&lt;/code&gt; (after enabling Linux &amp;quot;Kernel Mode Setting&amp;quot;, a.k.a. KMS). Not a seamless experience, but still acceptable.&lt;/p&gt;
&lt;h1 id=&quot;performance&quot;&gt;Performance&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s a quick performance comparison of building this site using &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt;, on various JavaScript runtimes, between my Raspberry Pi 1 B and my Dell Inspiron Mini 1018:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Build time by device&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;&lt;a href=&quot;https://github.com/jaredkrinke/leano&quot;&gt;leano&lt;/a&gt;&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Node&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Deno&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Raspberry Pi&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4 minutes&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2 minutes&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;not possible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Netbook&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1 minute&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;20 seconds&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I had to resort to using &lt;a href=&quot;https://github.com/NixOS/nix&quot;&gt;Nix&lt;/a&gt; to get Deno running because Deno depends on &lt;a href=&quot;https://www.gnu.org/software/libc/&quot;&gt;glibc&lt;/a&gt; and doesn&amp;#39;t support &lt;a href=&quot;https://musl.libc.org/&quot;&gt;musl&lt;/a&gt; (the C standard library implementation that Alpine Linux uses).&lt;/p&gt;
&lt;p&gt;Overall, this is a 4 - 6x performance improvement (on a machine that coincidentally cost 4 - 6 times as much as the Pi 1 B, originally).&lt;/p&gt;
&lt;h2 id=&quot;battery-life&quot;&gt;Battery life&lt;/h2&gt;
&lt;p&gt;My old setup chained me to my desk, but now I can take my laptop wherever. I don&amp;#39;t really remember what the battery life was like originally (or on Windows), but I&amp;#39;m able to get 4 - 6 hours of intensive use. That is plenty for me at the moment, although it certainly doesn&amp;#39;t seem like &amp;quot;good&amp;quot; battery life. I&amp;#39;ve also noticed that the (rotational) hard drive seems to spin up and down consistently every 5 seconds, even when I&amp;#39;m not doing anything. I&amp;#39;m not sure if it&amp;#39;s a hardware, driver, or Linux problem, but I&amp;#39;m just trying to ignore it for now. &lt;/p&gt;
&lt;h2 id=&quot;power-consumption&quot;&gt;Power consumption&lt;/h2&gt;
&lt;p&gt;One area where the Raspberry Pi excelled was power consumption. At max capacity, I measured it at around 3.5 Watts.&lt;/p&gt;
&lt;p&gt;My netbook is much less efficient, but overall not too bad. At full load, it seems to peak around 15 - 20 Watts. In standby, it consumes rougly 4 Watts, which is pretty similar to the Raspberry Pi (considering that I never powered down the Pi).&lt;/p&gt;
&lt;h1 id=&quot;to-be-continued&quot;&gt;To be continued...&lt;/h1&gt;
&lt;p&gt;Now that I&amp;#39;ve got a tolerably fast computer, I can get some &lt;em&gt;real&lt;/em&gt; work done. In the next post, I&amp;#39;m planning to cover the software side of things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding a console &amp;quot;taskbar&amp;quot; to GNU Screen&lt;/li&gt;
&lt;li&gt;Attempting to use a language server with a text editor&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog, part 2</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html"/>
<updated>2023-04-02T00:00:00.000Z</updated>
<summary type="text">Using GNU Make to enable incremental builds of this site.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html&quot;&gt;part 1&lt;/a&gt;, I brainstormed some ideas to speed up rebuilds of my static site (because I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html&quot;&gt;playing around with using old/slow computers&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In this update, I&amp;#39;m going to share a potentially misguided (but functional!) approach to supporting incremental builds using &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;GNU Make&lt;/a&gt;. The code is &lt;a href=&quot;https://github.com/jaredkrinke/make-blog&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;My static site generator, &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html&quot;&gt;md2blog&lt;/a&gt;, is written in TypeScript, simply because I&amp;#39;m used to the language and it&amp;#39;s popular. On my desktop computer, rebuilding this site is trivially fast. But once I switched to a Raspberry Pi 1 B (and now a 12 year-old netbook), the overhead of JavaScript became more noticeable. On my netbook, I&amp;#39;ve been able to get the full rebuild time of this site (only full rebuilds are supported in md2blog) down to about 12 seconds. This is tolerable, but obviously still inefficient. If I&amp;#39;m only adding or modifying a single post, why should I rebuild the entire site?&lt;/p&gt;
&lt;p&gt;Incremental builds should be possible by caching some intermediate state. Originally, I&amp;#39;d hoped to implement a generic solution in TypeScript, but part way through I realized that I was essentially reimplementing Make. So why not just use Make?&lt;/p&gt;
&lt;h1 id=&quot;md2blogs-build-process&quot;&gt;md2blog&amp;#39;s build process&lt;/h1&gt;
&lt;p&gt;md2blog is designed to be simple, but complete. This means that the build process is straight-forward:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clean up the output directory (delete everything)&lt;/li&gt;
&lt;li&gt;Read (and validate) site-wide metadata from &lt;code&gt;site.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Read (and validate) front matter from all posts (and remove drafts, if requested)&lt;/li&gt;
&lt;li&gt;Implicitly tag posts with their parent directory name (in addition to any explicitly-entered keywords)&lt;/li&gt;
&lt;li&gt;Generate an index of tags to posts&lt;/li&gt;
&lt;li&gt;Generate some necessary files (error page, stylesheet)&lt;/li&gt;
&lt;li&gt;Process Markdown (adding syntax highlighting and rewriting relative &lt;code&gt;*.md&lt;/code&gt; links, as needed)&lt;/li&gt;
&lt;li&gt;Generate an Atom feed of recent posts&lt;/li&gt;
&lt;li&gt;Generate an archive and tag index pages&lt;/li&gt;
&lt;li&gt;Validate all internal links&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After writing down that list, I&amp;#39;m realizing there are a lot of steps, but they&amp;#39;re mostly just to support implicit tags and various index pages. Regardless, it&amp;#39;s relatively straight-forward.&lt;/p&gt;
&lt;h1 id=&quot;using-gnu-make&quot;&gt;Using GNU Make&lt;/h1&gt;
&lt;p&gt;Like a good little developer, I&amp;#39;ve shied away from using GNU Make-specific functionality, and have just used the limited subset of Make that is widely supported. But for this project, I ended up needing to dig deep into GNU Make&amp;#39;s functionality to model md2blog&amp;#39;s build process correctly.&lt;/p&gt;
&lt;p&gt;Specifically, there were a few aspects of md2blog&amp;#39;s build process that were tricky to implement using GNU Make:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerating posts and their implicit directory structure&lt;/li&gt;
&lt;li&gt;Cleaning up extraneous files in the &lt;code&gt;out&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;Aggregating all posts into a single archive&lt;/li&gt;
&lt;li&gt;Discovering and handling tags that don&amp;#39;t correspond to any directory (i.e. keywords)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;enumerating-and-cleaning-files&quot;&gt;Enumerating and cleaning files&lt;/h2&gt;
&lt;p&gt;In this case, I wanted to avoid listing all posts explicitly in my &lt;code&gt;Makefile&lt;/code&gt;--I just wanted it to discover all of the files in the file system, a la &amp;quot;classic&amp;quot; md2blog. GNU Make supports enumerating files by letting you delegate that job to the &lt;code&gt;find&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Use &amp;quot;find&amp;quot; to enumerate all directories and files under &amp;quot;content/&amp;quot; (excluding &amp;quot;content/&amp;quot; itself)&lt;/span&gt;
INPUT_FILES := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; find content -follow -type f -not -name &amp;#x27;.*&amp;#x27;)&lt;/span&gt;
INPUT_DIRECTORIES := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out content,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; find content -follow -type d)&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in the above snippet I also enumerate directories. This is so that I can recreate the same directory structure in the output directory. I also exclude files beginning with a dot (e.g. swap files).&lt;/p&gt;
&lt;p&gt;How do I &amp;quot;clean&amp;quot; up any extraneous files &lt;em&gt;before&lt;/em&gt; anything builds? The only reliable solution I could come up with was to sneakily run a command while expanding an usused &lt;em&gt;simply expanded&lt;/em&gt; (&lt;code&gt;:=&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;) variable (note: it must be simply expanded to ensure it is expanded first, and only once):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;INPUT_FILES_POSTS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt; content/posts/%.md,&lt;span class=&quot;hljs-variable&quot;&gt;$(INPUT_FILES)&lt;/span&gt;)&lt;/span&gt;
INTERMEDIATE_FILES_POST_METADATA := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;patsubst&lt;/span&gt; content/posts/%.md,cache/posts/%.metadata.json,&lt;span class=&quot;hljs-variable&quot;&gt;$(INPUT_FILES_POSTS)&lt;/span&gt;)&lt;/span&gt;
...
INTERMEDIATE_FILES_EXTRANEOUS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES)&lt;/span&gt;,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; mkdir -p cache &amp;amp;&amp;amp; find cache -type f)&lt;/span&gt;)
...
TIDY_RESULT := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; rm -f &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES_EXTRANEOUS)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feels like a hack, since it relies on a side-effect of a &lt;code&gt;$(shell ...)&lt;/code&gt; expansion, but it&amp;#39;s the best solution I could come up with.&lt;/p&gt;
&lt;h2 id=&quot;aggregating-posts&quot;&gt;Aggregating posts&lt;/h2&gt;
&lt;p&gt;Aggregating a bunch of posts into a single index sounds like a trivial problem, and it really should be. But since GNU Make relies on command lines, I&amp;#39;m paranoid that any solution which relies on passing paths to &lt;em&gt;every&lt;/em&gt; post via the command line will run into the dreaded command line length limit (which varies significantly in the wild, and isn&amp;#39;t always documented properly).&lt;/p&gt;
&lt;p&gt;The only solution I could come up with was to pass the large list via the file system. This could either be done using a file that lists the paths, or it could be implicit by searching a directory tree (assuming that the tree has been purged of extraneous files--as I do above).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;cache/posts/index.json: &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES_POST_METADATA)&lt;/span&gt; | &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_DIRECTORIES)&lt;/span&gt;&lt;/span&gt;
    deno run --allow-read=cache --allow-write=cache index.ts cache/posts &lt;span class=&quot;hljs-variable&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the order-only prerequisite for &lt;code&gt;$(INTERMEDIATE_DIRECTORIES)&lt;/code&gt; that ensures the directory structure is already in place before the script runs.&lt;/p&gt;
&lt;h3 id=&quot;aside-on-aigpt&quot;&gt;Aside on AI/GPT&lt;/h3&gt;
&lt;p&gt;Given that I was somewhat stumped by this problem, I decided to try asking Bing&amp;#39;s fancy new GPT-based AI chat thingy. Its response was pretty underwhelming. Its first suggestion was to switch from GNU Make to... GNU Make. The second suggestion was to use VPATHs--but that&amp;#39;s a solution to a different problem. And its last suggestion was just clearly copy-pasted--without proper context!--from GNU Make&amp;#39;s documentation.&lt;/p&gt;
&lt;p&gt;Overall, the answer pointed to documentation I had already consulted (so it &lt;em&gt;did&lt;/em&gt; find information I had already noted as potentially relevant), but the answer was mostly &amp;quot;just don&amp;#39;t do that, duh!&amp;quot;. Color me not impressed.&lt;/p&gt;
&lt;h2 id=&quot;discovering-tags-that-dont-exist-as-directories&quot;&gt;Discovering tags that don&amp;#39;t exist as directories&lt;/h2&gt;
&lt;p&gt;My current solution to discovering tags that don&amp;#39;t also exist as directories runs a script that enumerates tags programmatically and then outputs &lt;em&gt;all&lt;/em&gt; index pages. This requires also managing the creation and non-cleanup-ification of those directories. Sadly, my current solution has a bug (it doesn&amp;#39;t programmatically clean up extraneous tag indexes), but the scenario (deleting a unique keyword) is rare enough that I haven&amp;#39;t bothered to fix the bug yet.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s where I had to hack in a pattern to avoid treating programmatically-discovered tags&amp;#39; index pages as extraneous (for the purposes of cleaning up the output directory):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;OUTPUT_FILES_EXTRANEOUS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out &lt;span class=&quot;hljs-variable&quot;&gt;$(OUTPUT_FILES)&lt;/span&gt; out/posts/%/index.html,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; mkdir -p out &amp;amp;&amp;amp; find out -type f)&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;performance&quot;&gt;Performance&lt;/h1&gt;
&lt;p&gt;So was this all worth it? The answer is: kind of. Here&amp;#39;s a table with the results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Scenario&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Elapsed time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;classic&amp;quot; md2blog&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;make&amp;quot;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;90 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Incremental build using &amp;quot;make&amp;quot;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;I haven&amp;#39;t heavily optimized the incremental build process, but as it stands currently, an incremental build using Make is 4x faster, but a full rebuild using Make is 8x slower. If I could get the &amp;quot;full rebuild&amp;quot; time down to a reasonable level, I&amp;#39;d be very happy.&lt;/p&gt;
&lt;h2 id=&quot;bottlenecks&quot;&gt;Bottlenecks&lt;/h2&gt;
&lt;p&gt;The biggest issue with leveraging Make in this case is that it spins up a separate process for each build command, but I&amp;#39;m using a JavaScript runtime that has a significant startup cost. I&amp;#39;m not sure exactly how Deno works internally, but setting up a relatively heavy JavaScript environment for processing markdown and adding syntax highlighting, just for a single file, seems wasteful and slow (even when running in parallel--something that GNU Make enables).&lt;/p&gt;
&lt;h2 id=&quot;potential-improvements&quot;&gt;Potential improvements&lt;/h2&gt;
&lt;p&gt;There&amp;#39;s a silver lining, however. Because Make decomposes each step into a separate command line, I could theoretically replace the underlying tool of the slowest commands with a more efficient implementation (without touching anything else). In my case, the slowest processes are syntax highlighting and processing markdown (in that order). I&amp;#39;m tempted to try using native code implementations of these two steps to see how much startup/process creation overhead that avoids.&lt;/p&gt;
&lt;p&gt;Another solution might be to run a persistent JavaScript server and use a trivial tool to communicate with it. For example, running an HTTP server with Deno and using &lt;code&gt;wget&lt;/code&gt; in my command lines to send it processing jobs. I&amp;#39;m not sure if GNU Make has any support for such a server process, but I suspect I could hack something together by launching a server process into the background and just having it spin itself down after some number of seconds of inactivity.&lt;/p&gt;
&lt;h1 id=&quot;this-post-brought-to-you-by-make-blog&quot;&gt;This post brought to you by &lt;strong&gt;make-blog&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;A 9 second improvement for incremental builds doesn&amp;#39;t sound terribly noticeable, but just in the process of authoring this post I&amp;#39;m already finding it useful. Now I can tweak a few words or a bit of formatting and view the result (almost) immediately, even on my super slow twelve year-old netbook.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll most likely continue using &amp;quot;old&amp;quot; md2blog for officially updating the site prior to publishing (just because I&amp;#39;m paranoid), but I&amp;#39;m still satisfied with my improved local workflow.&lt;/p&gt;
&lt;p&gt;In case anyone&amp;#39;s curious, here is the code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaredkrinke/make-blog&quot;&gt;make-blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Reflecting on my first release on Steam, SIC-1</title>
<id>https://log.schemescape.com/posts/game-development/sic-1-retrospective.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1-retrospective.html"/>
<updated>2023-03-25T00:00:00.000Z</updated>
<summary type="text">This is a retrospective on my first game I&apos;ve released on Steam, along with some thoughts about the future.</summary>
<content type="html">&lt;p&gt;It&amp;#39;s been almost four months since I released &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html&quot;&gt;SIC-1&lt;/a&gt; (a single-instruction programming game) for free on Steam (and re-released it &lt;a href=&quot;https://jaredkrinke.itch.io/sic-1&quot;&gt;on itch.io&lt;/a&gt;). This is an update on how the release went, and my plans for the future.&lt;/p&gt;
&lt;h1 id=&quot;financial-summary&quot;&gt;Financial summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Revenue: $0&lt;/li&gt;
&lt;li&gt;Expenses: $134.07&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIC-1 can be played by anyone for free (with no ads), so it&amp;#39;s earned a grand total of $0 in revenue. Expenses include a $100 Steam direct fee, and roughly $34 for a year of (completely optional) web hosting.&lt;/p&gt;
&lt;h2 id=&quot;do-i-regret-releasing-sic-1-for-free&quot;&gt;Do I regret releasing SIC-1 for free?&lt;/h2&gt;
&lt;p&gt;I released SIC-1 for free because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Free games attract more players, and I wanted as many players as possible to fill up the charts/leaderboards&lt;/li&gt;
&lt;li&gt;I strongly doubted I would ever earn enough money from SIC-1 to make a meaningful financial difference in my life&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the absolute best case scenario, let&amp;#39;s assume that all 1,800 players on Steam bought the game for my hypothetical full price of $10. Taking out Steam&amp;#39;s 30% fee and another 15% for taxes, that would be a little under $11,000 in my theoretical pocket. An extra $11k actually sounds pretty great! Realistically, however, &lt;a href=&quot;https://vginsights.com/insights/article/infographic-indie-game-revenues-on-steam&quot;&gt;most indie games make less than $4,000 (lifetime)&lt;/a&gt;, and SIC-1 probably would have ended up even lower (on a couple hundred sales, at less than $4 net profit per sale).&lt;/p&gt;
&lt;p&gt;Additionally, if I had wanted to charge for the game on Steam, I would have had to either start charging for the previously free game on itch.io or take that version down entirely. That would feel like a betrayal of existing players. On the flip side, if I had charged for the game, I would have felt like I couldn&amp;#39;t eventually make the game free (or open source) because that might annoy my biggest fans (the ones who actually gave me money). A freemium model might have resolved these problems, but I didn&amp;#39;t want to fragment the player base over a small amount of money.&lt;/p&gt;
&lt;p&gt;In the end, earning some extra money would have been nice from a motivational standpoint, but I think I made the right decision to release the game for free.&lt;/p&gt;
&lt;h1 id=&quot;statistics&quot;&gt;Statistics&lt;/h1&gt;
&lt;h2 id=&quot;steamitchio-statistics&quot;&gt;Steam+itch.io statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;3,500 people started in the in-game tutorial&lt;/li&gt;
&lt;li&gt;1,700 completed the first puzzle&lt;/li&gt;
&lt;li&gt;500 completed the most difficult arithmetic task&lt;/li&gt;
&lt;li&gt;230 completed the first sequence task&lt;/li&gt;
&lt;li&gt;50 completed (correctly) the entire set of sequence puzzles&lt;/li&gt;
&lt;li&gt;30 completed the original set of 30 puzzles&lt;/li&gt;
&lt;li&gt;11 have completed the (new) final puzzle&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;steam-specific-statistics&quot;&gt;Steam-specific statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;13,000 free licenses granted&lt;/li&gt;
&lt;li&gt;1,800 lifetime unique users&lt;/li&gt;
&lt;li&gt;20 positive reviews&lt;/li&gt;
&lt;li&gt;Peak concurrent players: 10&lt;/li&gt;
&lt;li&gt;Daily active users peaked at 65 in January and trended down to 10 as of late March&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;statistics-summary&quot;&gt;Statistics summary&lt;/h2&gt;
&lt;p&gt;I made SIC-1 for fun. I knew that the market for programming games was probably pretty small. But I guess I didn&amp;#39;t quite realize &lt;em&gt;how small&lt;/em&gt; that market actually is. Even &lt;a href=&quot;https://www.zachtronics.com/last-call-bbs/&quot;&gt;Last Call BBS&lt;/a&gt;, the most recent (and final) game from &lt;a href=&quot;https://www.zachtronics.com/&quot;&gt;Zachtronics&lt;/a&gt; only has roughly 700 positive reviews (and approximately 22k sales).&lt;/p&gt;
&lt;p&gt;SIC-1 was able to reach 20 positive reviews in four months (with no negative reviews) and &lt;a href=&quot;https://vginsights.com/game/2124440&quot;&gt;Video Game Insights estimates that SIC-1 is in the top 45% for positive reviews and units &amp;quot;sold&amp;quot;&lt;/a&gt;. Given the niche audience and punishing nature of single-instruction programming, that actually sounds pretty good!&lt;/p&gt;
&lt;p&gt;Unfortunately, I didn&amp;#39;t really do any market research before diving into the Steam release for SIC-1, so I&amp;#39;d been hoping for a small single digit multiple of all the numbers above. Oh well, next time I&amp;#39;ll mentally set the bar lower.&lt;/p&gt;
&lt;h1 id=&quot;marketing&quot;&gt;Marketing&lt;/h1&gt;
&lt;p&gt;As SIC-1&amp;#39;s Steam debut approached, I cobbled together a long list of potential marketing activities. For example, sharing the game on sites that are popular with programmers, esolang enthusiasts, and zachlike players. As &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html#steam-release&quot;&gt;noted in the previous post&lt;/a&gt;, none of my marketing activities were terribly fruitful, but I was at least heartened to eventually see &lt;em&gt;someone else&lt;/em&gt; organically share my game on the unofficial Zachtronics Discord server (someone even streamed it on Twitch!). Regardless, until late December 2022, just relying on Steam was my best marketing activity (and, spoiler alert, not much has changed).&lt;/p&gt;
&lt;h2 id=&quot;december-2022-traffic-spike&quot;&gt;December 2022 traffic spike&lt;/h2&gt;
&lt;p&gt;After the first few disappointing weeks on Steam, I seriously started to consider shelving the entire project. But one day I saw a large spike in traffic coming from (of all places) GitHub. It took a little bit of searching to find out that &lt;a href=&quot;https://github.com/jaredkrinke/sic1&quot;&gt;SIC-1&amp;#39;s GitHub repository&lt;/a&gt; had been shared on Twitter... by someone will millions of followers!&lt;/p&gt;
&lt;p&gt;Specifically, &lt;a href=&quot;https://twitter.com/notch/status/1604998134354137099&quot;&gt;the original creator of Minecraft, Notch, shared my game&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Zachlike subleq &amp;quot;game&amp;quot; ... I&amp;#39;m going to lose a lot of braincells to this one ... ie, highly recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given that Notch had 3.5 million followers, I thought this might be my big break, and I did get quite a few new players at the time, but the total impact was probably only in the (very) low hundreds of new players. Regardless, it was fairly surreal to see a billionaire live-tweeting about playing my game (during the winter holiday season, no less).&lt;/p&gt;
&lt;h2 id=&quot;positive-rating-on-steam&quot;&gt;&amp;quot;Positive&amp;quot; rating on Steam&lt;/h2&gt;
&lt;p&gt;But it turns out the best marketing for SIC-1 was, again, just to let Steam provide some visibility. Once SIC-1 hit 10 reviews, it got a &amp;quot;Positive&amp;quot; rating and a very large spike in traffic (over 5,000 visitors in one day). The spike has been receding, but I&amp;#39;m still seeing over 100 unique visitors to the Steam page per day.&lt;/p&gt;
&lt;h2 id=&quot;marketing-summary&quot;&gt;Marketing summary&lt;/h2&gt;
&lt;p&gt;All things considered, I should probably be content with where SIC-1 ended up, given the small audience and my apparent lack of marketing prowess, but I can&amp;#39;t shake the feeling that the game didn&amp;#39;t attract as many players as I&amp;#39;d hoped.&lt;/p&gt;
&lt;h1 id=&quot;overall&quot;&gt;Overall&lt;/h1&gt;
&lt;p&gt;Obviously, I learned a lot producing and launching a small (but complete) game on Steam, not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How Steam works behind the scenes&lt;/li&gt;
&lt;li&gt;How to make a trailer for a game&lt;/li&gt;
&lt;li&gt;How to create Yamaha DX7 music (without owning any synthesizers or spending any money)&lt;/li&gt;
&lt;li&gt;How to write a narrative for a game&lt;/li&gt;
&lt;li&gt;How to run asynchronous operations with WebView2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of the list above, creating original music was definitely the most enjoyable activity, so it&amp;#39;s good that SIC-1 provided motivation to learn more about that process.&lt;/p&gt;
&lt;p&gt;Releasing a game on Steam was a bucket list item for me, and I&amp;#39;m glad I did it. It remains to be seen if I&amp;#39;ll make any more games in the future.&lt;/p&gt;
&lt;h1 id=&quot;the-future&quot;&gt;The future&lt;/h1&gt;
&lt;p&gt;Speaking of the future, SIC-1 is mostly complete. I&amp;#39;d like to add an interactive tutorial and support for custom puzzles, but given the lower player count I&amp;#39;m not convinced that would be a good use of my (limited) free time.&lt;/p&gt;
&lt;p&gt;Here are the biggest remaining open questions for me&lt;/p&gt;
&lt;h2 id=&quot;should-i-open-source-sic-1&quot;&gt;Should I open-source SIC-1?&lt;/h2&gt;
&lt;p&gt;Currently the game is free and source is available, but it&amp;#39;s not &lt;a href=&quot;https://opensource.org/osd/&quot;&gt;Open Source&lt;/a&gt; because I don&amp;#39;t allow redistribution/resale/modifications. I love open source software, but there are two reasons I&amp;#39;m hesitant to release my game as open source:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t want someone else to turn around and sell my game (that I released for free)&lt;/li&gt;
&lt;li&gt;I&amp;#39;m proud of the music and characters/narrative, and I don&amp;#39;t want other people to be able to profit off of them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An obvious solution would be to release everything except the narrative and music as open source, but I&amp;#39;m not sure that&amp;#39;s worth the effort.&lt;/p&gt;
&lt;h2 id=&quot;should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;Should I port the Steam version of the game to Linux?&lt;/h2&gt;
&lt;p&gt;I feel bad for only supporting Windows for the Steam release. My original reasoning was:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The web version already works on Linux/macOS/whatever&lt;/li&gt;
&lt;li&gt;By using WebView2 (instead of Electron), I could keep the download size reasonable (less than 30 MB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In retrospect, I should have just used Electron from the beginning. Not only would it have been easier to implement, but then I could have easily supported Steam on Linux (and maybe even macOS), allowing those players to sync save data across devices and compare achievement statistics. The only downside is that the download would be roughly 5 times as large (which &lt;em&gt;does&lt;/em&gt; seem excessive for a mostly text-based game).&lt;/p&gt;
&lt;p&gt;But once again, I&amp;#39;m just not sure that the game is popular enough to warrant porting to Linux. It might please a handful of people (and make me feel better), but I should probably focus on more impactful projects.&lt;/p&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all, for now&lt;/h1&gt;
&lt;p&gt;Thus concludes my brain dump. Feel free to send questions or comments to &lt;a href=&quot;mailto:log@schemescape.com&quot;&gt;log@schemescape.com&lt;/a&gt;. If you enjoyed the game, I&amp;#39;d love to hear from you!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html"/>
<updated>2023-03-07T00:00:00.000Z</updated>
<summary type="text">md2blog is fast on my desktop, but slow on my Raspberry Pi. Here are my plans to improve rebuild performance.</summary>
<content type="html">&lt;p&gt;I&amp;#39;ve been happily using &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html&quot;&gt;md2blog&lt;/a&gt; to generate this site for over a year now, but I recently ran into a problem: it&amp;#39;s not as fast as it could be.&lt;/p&gt;
&lt;p&gt;On my desktop computer, this is no big deal because a clean build only takes a couple of seconds and a live rebuild takes less than 2 seconds. But on my &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html&quot;&gt;minimal development environment I&amp;#39;ve been playing with&lt;/a&gt; (which runs on a Raspberry Pi 1, model B), even after some basic optimization, it still takes 2 minutes to build the site from scratch! I haven&amp;#39;t bothered to attempt a &amp;quot;live&amp;quot; rebuild.&lt;/p&gt;
&lt;p&gt;One reason for this is the fact that md2blog always rebuilds the entire site, regardless of whether or not anything changed. This was a design decision I made solely to simplify the implementation, with the understanding that my site was small enough and my computer fast enough that it wouldn&amp;#39;t matter. Now, my computer is slow.&lt;/p&gt;
&lt;h1 id=&quot;solutions-to-explore&quot;&gt;Solutions to explore&lt;/h1&gt;
&lt;p&gt;Here are some ideas I had for improving performance on low-end devices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hugo&lt;/strong&gt;: Give up on JavaScript/Deno/&lt;a href=&quot;https://github.com/jaredkrinke/goldsmith&quot;&gt;Goldsmith&lt;/a&gt; and port everything to &lt;a href=&quot;https://gohugo.io/&quot;&gt;Hugo&lt;/a&gt; (which is implemented in Go and therefore compiled to native code, so probably faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: Give up on JavaScript and rewrite md2blog (and possibly Goldsmith) in Rust (also compiles to native code, but without a garbage collector, so maybe even faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caching&lt;/strong&gt;: Refactor Goldsmith so that it avoids rebuilding items whose source files haven&amp;#39;t changed&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hugo&quot;&gt;Hugo&lt;/h2&gt;
&lt;p&gt;Hugo is a popular static site generator. I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/hugo.html&quot;&gt;tried it out&lt;/a&gt; when I was first creating this site, but I hated the template language and the learning curve for creating new themes was fairly steep. Despite my complaints, I admire Hugo&amp;#39;s portability and speed, so I&amp;#39;m willing to give it another shot, so this option remains on the table.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I looked into Hugo more, and it doesn&amp;#39;t support deriving taxonomies from file system metadata (namely: parent directory), so I&amp;#39;d have to make some compromises (either to my workflow or the site design) if I wanted to switch to Hugo. Still on the table (just less attractive).&lt;/p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;/h2&gt;
&lt;p&gt;I&amp;#39;d like to learn Rust because it&amp;#39;s unique as a &lt;em&gt;safe&lt;/em&gt; systems language, and redesigning/reimplementing Goldsmith+md2blog in Rust would be a great way to learn the language. Using a compiled language would enable parallel builds (although my Raspberry Pi 1 only has a single CPU core), and I suspect that native Markdown/syntax highlighting libraries would speed things up.&lt;/p&gt;
&lt;p&gt;This would be a large project, but educational enough that I&amp;#39;m open to it.&lt;/p&gt;
&lt;h2 id=&quot;caching&quot;&gt;Caching&lt;/h2&gt;
&lt;p&gt;It&amp;#39;s hard to estimate the impact of caching intermediate objects and outputs, but done correctly this would at least reduce the number of files written out from roughly 100, down to just a handful.&lt;/p&gt;
&lt;p&gt;This option also has the attractive quality that it doesn&amp;#39;t require reimplementing everything in a new language or framework, so it&amp;#39;s probably the shortest path to performance improvements without functional regressions.&lt;/p&gt;
&lt;p&gt;For now, I&amp;#39;m planning to investigate caching first since it&amp;#39;s the easiest and safest option.&lt;/p&gt;
&lt;h1 id=&quot;adding-caching-to-goldsmith&quot;&gt;Adding caching to Goldsmith&lt;/h1&gt;
&lt;p&gt;I never got around to documenting Goldsmith (the base upon which md2blog is built), but it&amp;#39;s essentially &amp;quot;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt; for Deno, with very few dependencies&amp;quot;. Unfortunately, Metalsmith&amp;#39;s data model (which Goldsmith copies) doesn&amp;#39;t trivially lend itself to caching.&lt;/p&gt;
&lt;h2 id=&quot;goldsmiths-data-model-vs-caching&quot;&gt;Goldsmith&amp;#39;s data model vs. caching&lt;/h2&gt;
&lt;p&gt;Goldsmith&amp;#39;s data model is essentially one giant mutable map of filenames to metadata and content. A sequence of plugins manipulate this map, in order to transform input files to output files (adding/modifying metadata along the way). At the end of the plugin chain, files are written out to disk.&lt;/p&gt;
&lt;p&gt;The problem with this approach is that output files never specify their dependencies. Looking at it from the other direction, if I modify this post&amp;#39;s Markdown file, the only change to Goldsmith&amp;#39;s initial data model is the content of this Markdown file. The problem is that this one input file could impact numerous output files: the post itself, the Atom feed, any category/keyword index pages (especially if keywords are added or removed), the home page, and, of course, the archive page.&lt;/p&gt;
&lt;h2 id=&quot;caching-requirements&quot;&gt;Caching requirements&lt;/h2&gt;
&lt;p&gt;In order to rebuild the minimal set of files when a change is detected, I need an accurate dependency graph. There are a couple of pitfalls:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The pipeline itself can change&lt;/strong&gt; (in general for Goldsmith, and in configuration for md2blog)&lt;/li&gt;
&lt;li&gt;Plugins always consume the entire data model (plugins internally may filter the set of files, but that&amp;#39;s an implementation detail)&lt;/li&gt;
&lt;li&gt;Plugins can add/delete files at will (there isn&amp;#39;t even a &amp;quot;rename&amp;quot; operation--it just shows up as two independent operations: add and delete)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;brainstorming-dependency-graph-approaches&quot;&gt;Brainstorming dependency graph approaches&lt;/h2&gt;
&lt;p&gt;Obviously, I could just mandate that Goldsmith plugins have to accurately enumerate their dependencies when adding or modifying entires in the collection data model. For md2blog, with its fixed pipeline, this should be feasible, but potentially error-prone.&lt;/p&gt;
&lt;p&gt;Another approach would be to automatically gather dependency information for each output by providing the data model wrapped in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;proxy object&lt;/a&gt;. The trick is scoping the proxy object to a single output, and I don&amp;#39;t see a way to accomplish this without changing the plugin contract. One approach might be to create a new class of plugins that &lt;em&gt;only&lt;/em&gt; transform/rename files individually. &lt;strong&gt;This would also open the door to parallel processing of these &amp;quot;per-file&amp;quot; plugins&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Having the dependency graph computed automatically is preferable, so I&amp;#39;ll try that first.&lt;/p&gt;
&lt;h2 id=&quot;from-dependencies-to-caching&quot;&gt;From dependencies to caching&lt;/h2&gt;
&lt;p&gt;Creating the dependency graph is necessary, but not sufficient. I&amp;#39;ll need to also cache the intermediate results from plugins, along with the timestamps of input files so that I can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check to see which files have changed&lt;/li&gt;
&lt;li&gt;Restart the build pipeline from the deepest point that hasn&amp;#39;t changed&lt;/li&gt;
&lt;li&gt;Add back in unmodified data model entries&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Other than ad-hoc tests, it will probably be a good idea to &lt;strong&gt;run both the new cache-aware pipeline and the old rebuild-the-world approach to ensure there aren&amp;#39;t any differences&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll also, of course, need to &lt;strong&gt;ensure that the additional overhead from caching isn&amp;#39;t so large as to negate any of the benefits&lt;/strong&gt;, at least on my personal site (I&amp;#39;m not the only md2blog use in the entire world, but there are very few, and I suspect most won&amp;#39;t ever find the updated version).&lt;/p&gt;
&lt;h1 id=&quot;stay-tuned&quot;&gt;Stay tuned&lt;/h1&gt;
&lt;p&gt;I have no idea how long this project will take or whether I&amp;#39;ll abandon it, but if I make progress, I&amp;#39;ll be sure to post an update (and link it from here--hopefully the rebuild picks up the change!).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I prototyped &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;incremental builds using GNU Make&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Future-proof programming languages, part 3</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html"/>
<updated>2023-03-03T00:00:00.000Z</updated>
<summary type="text">Finally! I&apos;ve landed on my set of future-proof languages.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;part 1&lt;/a&gt;, I narrowed down a list of popular programming languages to the ones I liked and that I  thought would still be useful in the future. In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html&quot;&gt;part 2&lt;/a&gt;, I recorded some initial impressions, and added a few more languages to the mix.&lt;/p&gt;
&lt;p&gt;In this update, I&amp;#39;m recording my experiences with a trivial program in each language, with an eye towards possibly incorporating one or more of these languages into my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html&quot;&gt;minimal development environment&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;scenarios-and-metrics&quot;&gt;Scenarios and metrics&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;This post is not an attempt to definitively benchmark or objectively compare programming languages in depth!&lt;/strong&gt; Instead, I&amp;#39;m playing around with each language and environment to see which ones are even worth my consideration. Specifically, I&amp;#39;m looking at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDK size (measured on x86_64 Alpine Linux), as a proxy for &lt;strong&gt;simplicity&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;Hello, world!&amp;quot; program size, as a proxy for &lt;strong&gt;overhead&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Stand-alone executable size, as a proxy for &lt;strong&gt;ease of deployment&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Cross-compiling for a Raspberry Pi B, as a proxy for &lt;strong&gt;portability&lt;/strong&gt; and &lt;strong&gt;developer experience&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;For reference, my Alpine Linux baseline image was around 150 MB. Here are the results, ordered by descending SDK size:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;SDK size&lt;/th&gt;
&lt;th&gt;Program size&lt;/th&gt;
&lt;th&gt;Stand-alone size&lt;/th&gt;
&lt;th&gt;Build on Pi?&lt;/th&gt;
&lt;th&gt;Cross-compile for Pi?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Rust&lt;/td&gt;
&lt;td&gt;650 MB&lt;/td&gt;
&lt;td&gt;300 KB&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Probably&lt;/td&gt;
&lt;td&gt;Mostly easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go&lt;/td&gt;
&lt;td&gt;550 MB&lt;/td&gt;
&lt;td&gt;1.2 MB&lt;/td&gt;
&lt;td&gt;1.2 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C#&lt;/td&gt;
&lt;td&gt;510 MB&lt;/td&gt;
&lt;td&gt;75 KB&lt;/td&gt;
&lt;td&gt;67 MB&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Failed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zig&lt;/td&gt;
&lt;td&gt;335 MB&lt;/td&gt;
&lt;td&gt;800 KB&lt;/td&gt;
&lt;td&gt;800 KB&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Mostly easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;230 MB&lt;/td&gt;
&lt;td&gt;14 KB&lt;/td&gt;
&lt;td&gt;940 KB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Tedious&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;144 MB&lt;/td&gt;
&lt;td&gt;14 KB&lt;/td&gt;
&lt;td&gt;13 KB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Tedious&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;75 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;7 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript (Node)&lt;/td&gt;
&lt;td&gt;60 MB&lt;/td&gt;
&lt;td&gt;1KB&lt;/td&gt;
&lt;td&gt;80 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lisp (SBCL)&lt;/td&gt;
&lt;td&gt;45 MB&lt;/td&gt;
&lt;td&gt;1KB&lt;/td&gt;
&lt;td&gt;40 MB&lt;/td&gt;
&lt;td&gt;Probably&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tcl&lt;/td&gt;
&lt;td&gt;8 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lua&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;sdk-size&quot;&gt;SDK size&lt;/h2&gt;
&lt;p&gt;Just looking at SDK size, Rust is an outlier. Even compared to a similarly complex language like C++, the Rust SDK is absolutely huge. At the moment, I don&amp;#39;t know why the SDK is so big. Even after allowing for a build tool, custom linker, and standard library, the Rust SDK is disappointingly heavy. This unfortunately matches my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;previous experience with Rust on Windows&lt;/a&gt;. &lt;strong&gt;Update&lt;/strong&gt;: Using the &amp;quot;minimal&amp;quot; profile, the SDK was closer to 650 MB for native compilation and another 150 MB for cross-compilation.&lt;/p&gt;
&lt;p&gt;Obviously, it&amp;#39;s not fair to compare the compile-to-native languages to scripting languages, but comparisons within each category seem appropriate. Go is the second largest, but it comes with some impressive features: the ability to trivially cross-compile and &lt;a href=&quot;https://pkg.go.dev/std&quot;&gt;a large standard library&lt;/a&gt;. Go&amp;#39;s offering seems on par with C#, but with a better &amp;quot;compile to native code&amp;quot; story (and, obviously, larger differences in the programming languages themselves).&lt;/p&gt;
&lt;p&gt;Zig is larger than I expected for a simple language, but it can cross-compile for different architectures (similar to Go), and &lt;a href=&quot;https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j&quot;&gt;Zig can even compile C/C++ code&lt;/a&gt;, so it&amp;#39;s arguably worth the footprint.&lt;/p&gt;
&lt;p&gt;Looking at interpreted languages, the results are pretty similar except for Tcl and Lua (both of which don&amp;#39;t come with much of a standard library).&lt;/p&gt;
&lt;h2 id=&quot;hello-world-program-size&quot;&gt;&amp;quot;Hello, world!&amp;quot; program size&lt;/h2&gt;
&lt;p&gt;The Go binary shows one of Go&amp;#39;s weaknesses -- it&amp;#39;s compiled to native, but it has to include the entire runtime in each binary. This isn&amp;#39;t a deal-breaker for me, so I&amp;#39;m not too concerned.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;am&lt;/em&gt; curious why the Zig binary is so large, but I haven&amp;#39;t investigated any further yet. Given that Zig supports &amp;quot;freestanding&amp;quot; binaries, I&amp;#39;m sure it&amp;#39;s possible to create minimal binaries with Zig.&lt;/p&gt;
&lt;p&gt;The C++ binary using &amp;quot;iostream&amp;quot; was unacceptably big, but using &amp;quot;stdio.h&amp;quot; gets it back in line with C, in the low double-digit kilobytes.&lt;/p&gt;
&lt;h2 id=&quot;stand-alone-executable-size&quot;&gt;Stand-alone executable size&lt;/h2&gt;
&lt;p&gt;Deployment is probably my least favorite part of software. Obviously, there are exceptions, but in most cases, a &amp;quot;program that does X&amp;quot; would be most convenient as a single executable (or at least a single zip file) that just does X. Here, I&amp;#39;m looking at fully statically-linked or bundled binaries.&lt;/p&gt;
&lt;p&gt;Native languages generally compile to a single binary. I didn&amp;#39;t try to get a fully static binary from Rust, but I&amp;#39;ve read that it&amp;#39;s possible. C certainly is good at producing small executables (in the past, this was a prerequisite!).&lt;/p&gt;
&lt;p&gt;The other languages show some interesting results: JavaScript and C# appear to be the most bloated, closely followed by SBCL (a Common Lisp implementation). But for JavaScript there are multiple runtimes--80 MB is for Deno, but QuickJS is under 1 MB--so JavaScript supports indirectly optimizing for either size or speed. Lisp has a similar story, although I didn&amp;#39;t investigate it in depth. Python was impressively slim (definitely a surprise for me!).&lt;/p&gt;
&lt;p&gt;That leaves C# which, sadly, just appears to be bloated. For the record, I couldn&amp;#39;t get a Tcl bundle working, but I suspect it would be &amp;lt; 10 MB.&lt;/p&gt;
&lt;h2 id=&quot;developing-on-a-raspberry-pi&quot;&gt;Developing &lt;em&gt;on&lt;/em&gt; a Raspberry Pi&lt;/h2&gt;
&lt;p&gt;Note: this section is about developing/compiling &lt;em&gt;on&lt;/em&gt; a Raspberry Pi B.&lt;/p&gt;
&lt;p&gt;The only languages that appeared to not be trivial to compile on a Raspberry Pi B with Alpine Linux were C# (this appears to be an unsupported platform) and Zig (theoretically, you might be able to bootstrap an environment, but I haven&amp;#39;t attempted that yet).&lt;/p&gt;
&lt;h2 id=&quot;cross-compiling-for-a-raspberry-pi&quot;&gt;Cross-compiling for a Raspberry Pi&lt;/h2&gt;
&lt;p&gt;Although I&amp;#39;m interested in developing directly on a Pi (as part of &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html&quot;&gt;my minimal development environment&lt;/a&gt;), it&amp;#39;s likely I&amp;#39;ll end up doing some development on a (faster) desktop, and then want to run the output on a Pi. Results here are easily categorized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cross-compiling not needed&lt;ul&gt;
&lt;li&gt;JavaScript (QuickJS, Node, but &lt;em&gt;not&lt;/em&gt; Deno)&lt;/li&gt;
&lt;li&gt;Lua&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Tcl&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trivial to cross-compile&lt;ul&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust (note: requires &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;editing Cargo&amp;#39;s config file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Zig (&lt;a href=&quot;https://github.com/ziglang/zig/issues/4875&quot;&gt;except for C/C++ code&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tedious, but possible to cross-compile&lt;ul&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cross-compile failed/didn&amp;#39;t work/not possible&lt;ul&gt;
&lt;li&gt;C# (executable failed to run)&lt;/li&gt;
&lt;li&gt;SBCL (not necessary with runtime, but not possible &lt;em&gt;without&lt;/em&gt; a runtime)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scripting languages sort of get a free pass here, but there are almost certainly large differences in ease of deployment.&lt;/p&gt;
&lt;p&gt;Go and Zig have excellent tooling for cross-compiling. And if Zig can eventually support cross-compiling C/C++ code without requiring a separate toolchain, that would be huge! &lt;strong&gt;Update&lt;/strong&gt;: Cross-compilation for Rust worked well, once I found out &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;how to tell Rust to use its bundled linker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C/C++ support cross-compiling through a painful process of setting up an entire compilation environment for the target. It&amp;#39;s tedious and annoying, and I hope I never have to do it again.&lt;/p&gt;
&lt;p&gt;As for C#, I suspect there&amp;#39;s some way to get them to successfully cross-compile for a Pi, but neither worked for me. I put SBCL in the last category because it seems to require running on the target in order to produce a bundle.&lt;/p&gt;
&lt;h1 id=&quot;analysis&quot;&gt;Analysis&lt;/h1&gt;
&lt;p&gt;Subjectively, I was least impressed with the following languages, so they&amp;#39;ve been cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C#: big and bloated, with poor support for Raspberry Pi -- it&amp;#39;s a shame because I really like C# and the .NET standard library&lt;/li&gt;
&lt;li&gt;Lisp: unimpressive bundle size/cross-compiling story -- but honestly, it&amp;#39;s too esoteric for me, and the community is highly fragmented&lt;/li&gt;
&lt;li&gt;Tcl: inconvenient tooling and, sadly, not popular enough to ensure it doesn&amp;#39;t fade away&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;ll tackle the remaining languages in two categories: native/compiled/statically typed vs. interpreted/dynamically typed.&lt;/p&gt;
&lt;h2 id=&quot;native-languages&quot;&gt;Native languages&lt;/h2&gt;
&lt;p&gt;Here are the remaining native languages, along with my favorite and least favorite qualities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C: simple and portable, but requires macros for many abstractions (and has an error-prone standard library)&lt;/li&gt;
&lt;li&gt;C++: powerful abstractions, but an inconsistent standard library&lt;/li&gt;
&lt;li&gt;Go: excellent tooling, but I still don&amp;#39;t like the overhead of a garbage collector for native code&lt;/li&gt;
&lt;li&gt;Rust: memory safety without a garbage collector, but the SDK is enormous (and supposedly slow)&lt;/li&gt;
&lt;li&gt;Zig: efficient tooling, but immature (likely with breaking changes)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;c-and-rust&quot;&gt;C++ and Rust&lt;/h3&gt;
&lt;p&gt;If I need powerful abstractions, C++ and Rust are the candidates. At the moment, I&amp;#39;m leaning towards giving Rust a try (despite the gigantic SDK). I&amp;#39;m familiar with C++, and it&amp;#39;s certainly capable, but Rust&amp;#39;s memory safety guarantees are worth exploring in depth. Hopefully that doesn&amp;#39;t end up being a mistake...&lt;/p&gt;
&lt;h3 id=&quot;c-go-zig&quot;&gt;C, Go, Zig&lt;/h3&gt;
&lt;p&gt;If I&amp;#39;m just looking for a simple and fast language, that would leave C, Go, and Zig. C is almost certainly future-proof for another decade or two and the SDK is reasonably sized. I&amp;#39;m less sure about Go and Zig, despite their efficient tooling. I&amp;#39;m skeptical of Go&amp;#39;s niche (native code, but with a garbage collector). Zig seems too immature, but its C/C++ compatibility is attractive.&lt;/p&gt;
&lt;p&gt;Overall, Rust&amp;#39;s unique combination of safety and speed is compelling, and I&amp;#39;m sure I&amp;#39;ll end up using it eventually. I&amp;#39;ll probably also need to use C where it&amp;#39;s already entrenched.&lt;/p&gt;
&lt;h2 id=&quot;interpreted-languages&quot;&gt;Interpreted languages&lt;/h2&gt;
&lt;p&gt;Here are the remaining interpreted/dynamic languages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python: ubiquitous, with a large standard library, but the language has a lot of warts and a history of compatibility problems&lt;/li&gt;
&lt;li&gt;JavaScript/TypeScript: the only option for the web, with a convenient type system in TypeScript, but without a standard library and runtime (and the module story is &lt;em&gt;still&lt;/em&gt; fragmented!)&lt;/li&gt;
&lt;li&gt;Lua: minimalist, but no standard library&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are almost a battery inclusion continuum from &amp;quot;included&amp;quot; to &amp;quot;sold separately&amp;quot;.&lt;/p&gt;
&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;
&lt;p&gt;I don&amp;#39;t like Python. But it&amp;#39;s everywhere! Now that Python is convenient on Windows, Python is almost a defacto portable shell scripting language (with a lot more). For example, the &lt;a href=&quot;https://github.com/ziglang/zig-bootstrap&quot;&gt;Zig bootstrap process&lt;/a&gt; requires Python! If it had required Node, people would have lost their minds. I think it&amp;#39;s high time I give in and just embrace Python.&lt;/p&gt;
&lt;h3 id=&quot;javascript&quot;&gt;JavaScript&lt;/h3&gt;
&lt;p&gt;JavaScript has somehow leap-frogged Python to become a convenient language, and TypeScript makes it even better for large projects. But I will admit that Node&amp;#39;s API is irritating, and the NPM ecosystem continually has to grapple with the lack of a standard library. Deno&amp;#39;s tooling is excellent, but Deno also breaks compatibility left and right. JavaScript is definitely future-proof, but the non-browser runtimes I&amp;#39;m less sure about.&lt;/p&gt;
&lt;h3 id=&quot;lua&quot;&gt;Lua&lt;/h3&gt;
&lt;p&gt;Lua is a great language for embedding, but I&amp;#39;m not sure it can compete with the popularity of Python and JavaScript for general software tasks.&lt;/p&gt;
&lt;h3 id=&quot;all-of-the-above&quot;&gt;All of the above&lt;/h3&gt;
&lt;p&gt;Realistically, I&amp;#39;m probably going to use all three of these scripting languages, just for different purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python for tools and scripts&lt;/li&gt;
&lt;li&gt;JavaScript on the web&lt;/li&gt;
&lt;li&gt;Lua for embedding&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-all&quot;&gt;That&amp;#39;s all!&lt;/h1&gt;
&lt;p&gt;When I started this investigation, I thought Rust was a shoo-in, but it&amp;#39;s big and not as stable/polished as I&amp;#39;d expected. It&amp;#39;s still at the top of my &amp;quot;native&amp;quot; list, but only because of its unique combination of memory safety and systems-level design.&lt;/p&gt;
&lt;p&gt;Prior to digging in a bit more, I wanted to continue avoiding Python in favor of JavaScript/TypeScript (running under Deno where possible, and Node otherwise). I&amp;#39;ve finally given in, and I think I&amp;#39;ll be writing a lot more Python in the future. I&amp;#39;d also written off Lua, but its minimalist design dovetails nicely with my minimal development environment aspirations, so I might give Lua another shot. I&amp;#39;ll happily continue using JavaScript (really TypeScript) for the web, of course.&lt;/p&gt;
&lt;h2 id=&quot;addendumnotes&quot;&gt;Addendum/notes&lt;/h2&gt;
&lt;p&gt;The next section is just a collection of notes I made while testing out languages. It&amp;#39;s likely riddled with factual errors.&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C#&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Install involves running a script -- will it pollute my system? Can I fully remove it?&lt;/li&gt;
&lt;li&gt;Docker images are provided -- would that be the safest way to try it out?&lt;/li&gt;
&lt;li&gt;Not seeing a Dockerfile on GitHub for ARMv6...&lt;/li&gt;
&lt;li&gt;What about Mono? Didn&amp;#39;t see any packages starting with &amp;quot;mono&amp;quot; on Alpine Linux...&lt;/li&gt;
&lt;li&gt;Cross-compile for Pi didn&amp;#39;t work&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;go&quot;&gt;Go&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Set &lt;code&gt;GOOS&lt;/code&gt; and &lt;code&gt;GOARCH&lt;/code&gt; to set OS and architecture for cross-compilation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;lisp-sbcl&quot;&gt;Lisp (SBCL)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Native package&lt;/li&gt;
&lt;li&gt;Arrow keys didn&amp;#39;t work in interpreter&lt;/li&gt;
&lt;li&gt;It seems like producing a self-contained, native executable for a different platform is frequently not supported by Lisps&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;lua-1&quot;&gt;Lua&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Has tons of native packages... but is it portable to Windows?&lt;/li&gt;
&lt;li&gt;Language server: &lt;a href=&quot;https://github.com/LuaLS/lua-language-server&quot;&gt;https://github.com/LuaLS/lua-language-server&lt;/a&gt; -- note that it&amp;#39;s complicated to build...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;jsts&quot;&gt;JS/TS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Probably will need Node at some point, but that runs on Raspberry Pi&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;python-1&quot;&gt;Python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Zig bootstrap requires Python 3, ha!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;rust&quot;&gt;Rust&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Try with Alpine package first, since it&amp;#39;s convenient, and easy to remove&lt;/li&gt;
&lt;li&gt;Raspberry Pi B Alpine Linux triple: arm-unknown-linux-musleabihf&lt;/li&gt;
&lt;li&gt;Attempt to cross-compile failed with &amp;quot;linker `cc` not found&amp;quot; (and suggestions from the web didn&amp;#39;t help)&lt;/li&gt;
&lt;li&gt;Cross-compiler setup from rustup was Visual Studio-levels of huge (1.5 GB)&lt;/li&gt;
&lt;li&gt;Finally found &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;the trick&lt;/a&gt; for linking during cross-compilation: point Cargo to &amp;quot;rust-lld&amp;quot; (which is installed with the toolchain)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;tcl&quot;&gt;Tcl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Couldn&amp;#39;t figure out how to make a TclKit...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;zig&quot;&gt;Zig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;No build for armv6l, but old build for armv6kz&lt;/li&gt;
&lt;li&gt;Crashes on C compile--also very slow to compile&lt;/li&gt;
&lt;li&gt;Hello world didn&amp;#39;t work--also kind of slow to compile&lt;/li&gt;
&lt;li&gt;Might try bootstrapping from my desktop, but probably too immature at the moment&lt;/li&gt;
&lt;li&gt;Cross compile to Raspberry Pi B with Alpine Linux: &lt;code&gt;zig build -Dtarget=arm-linux-musleabihf -Dcpu=arm1176jzf_s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cross-compiling C code &lt;a href=&quot;https://github.com/ziglang/zig/issues/4875&quot;&gt;doesn&amp;#39;t appear to be possible at the moment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
</feed>
