<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2022-03-08T04:02:24.275Z</updated>

<entry>
<title>Getting started with machine learning</title>
<id>https://log.schemescape.com/posts/machine-learning/getting-started.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/machine-learning/getting-started.html"/>
<updated>2022-03-07T00:00:00.000Z</updated>
<summary type="text">For personal enrichment, I&apos;m playing around with machine learning.</summary>
<content type="html">&lt;p&gt;One of the reasons I decided to give &lt;a href=&quot;https://log.schemescape.com/posts/machine-learning/../programming-languages/python.html&quot;&gt;Python&lt;/a&gt; one last try is that Python is popular for machine learning, and machine learning is a topic I&amp;#39;m interested in.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;Why am I interested in machine learning?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;#39;s an area of computer science that has advanced significantly since I studied CS in school&lt;/li&gt;
&lt;li&gt;It has many unique practical applications (speech recognition, language translation, machine vision, generative art)&lt;/li&gt;
&lt;li&gt;I recently acquired a GPU that (as far as I know) is capable of accelerating machine learning pipelines&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;first-steps&quot;&gt;First steps&lt;/h1&gt;
&lt;p&gt;As an introduction, I&amp;#39;m following MIT&amp;#39;s &lt;a href=&quot;https://openlearninglibrary.mit.edu/courses/course-v1:MITx+6.036+1T2019/about&quot;&gt;Introduction to Machine Learning (2020)&lt;/a&gt; class. It&amp;#39;s in Python and builds on &lt;a href=&quot;https://numpy.org/&quot;&gt;NumPy&lt;/a&gt;. The first 4 weeks focus on linear classifiers for binary classification.&lt;/p&gt;
&lt;p&gt;Although my math is rusty, my biggest struggle is actually with the NumPy API. Here is my list of grievances:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NumPy implicitly &amp;quot;broadcasts&amp;quot; arrays into compatible shapes&lt;ul&gt;
&lt;li&gt;I assume this is for convenience, but all it&amp;#39;s done for me is silently hide bugs in my code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NumPy sometimes silently removes dimensions&lt;ul&gt;
&lt;li&gt;Again, this is probably for convenience, but all it&amp;#39;s done is trip me up -- I really wish &lt;code&gt;keepdims&lt;/code&gt; defaulted to &lt;code&gt;True&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The API has a lot of cruft (e.g. a &lt;code&gt;matrix&lt;/code&gt; class that is no longer recommended for matrix computation)&lt;/li&gt;
&lt;li&gt;The documentation is frustratingly vague, and sometimes circular (e.g. &amp;quot;&lt;code&gt;*&lt;/code&gt; returns &lt;code&gt;self * value&lt;/code&gt;&amp;quot;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;experimentation&quot;&gt;Experimentation&lt;/h1&gt;
&lt;h2 id=&quot;using-a-sample-data-set&quot;&gt;Using a sample data set&lt;/h2&gt;
&lt;p&gt;To get a better handle on NumPy, I&amp;#39;d like to actually attempt to create a linear classifier from scratch. A quick search led me to a &lt;a href=&quot;https://jamesmccaffrey.wordpress.com/2018/03/14/datasets-for-binary-classification/&quot;&gt;page with links to data sets for binary classification problems&lt;/a&gt;. I&amp;#39;m using &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/banknote+authentication&quot;&gt;UCI Machine Learning Repository&amp;#39;s &amp;quot;banknote authentication&amp;quot; data set&lt;/a&gt; because the data format is simple (4 predictor variables and a 0 or 1 for the classification).&lt;/p&gt;
&lt;p&gt;To my surprise, simple algorithms (e.g. selecting random parameters) were able to correctly classify over 95% of examples. For what it&amp;#39;s worth, my code is posted &lt;a href=&quot;https://github.com/jaredkrinke/ml/tree/main/binary-classification&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;solving-a-problem-from-scratch&quot;&gt;Solving a problem from scratch&lt;/h2&gt;
&lt;p&gt;I&amp;#39;d like to try solving a real world problem from scratch, but I don&amp;#39;t really have a problem in mind that lends itself to binary classification. For what it&amp;#39;s worth, here are some Kaggle data sets that might eventually inspire me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/vivovinco/nba-player-stats&quot;&gt;NBA players&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/hacker-news/hacker-news&quot;&gt;Hacker News data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/deepcontractor/musical-instrument-chord-classification&quot;&gt;Chord classification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/rounakbanik/the-movies-dataset&quot;&gt;Movie data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kaggle.com/stackoverflow/stackoverflow&quot;&gt;Stack Overflow data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>First impressions of Python</title>
<id>https://log.schemescape.com/posts/programming-languages/python.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python.html"/>
<updated>2022-02-21T00:00:00.000Z</updated>
<summary type="text">Next on my list of programming languages to investigate is Python.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;a previous article&lt;/a&gt;, I enumerated a bunch of popular programming languages and tried to quickly determine which ones seemed like they&amp;#39;d still be useful in another decade.&lt;/p&gt;
&lt;p&gt;Now, I&amp;#39;m drilling more deeply into Python.&lt;/p&gt;
&lt;h1 id=&quot;setting-up-a-python-development-environment&quot;&gt;Setting up a Python development environment&lt;/h1&gt;
&lt;p&gt;Ah, my old nemesis: Python. I&amp;#39;ve never had a good experience setting up a Python environment. Additionally, the Python 2 to 3 migration (which included unnecessary things like &lt;a href=&quot;https://www.python.org/dev/peps/pep-0238/&quot;&gt;changing the semantics of the division operator&lt;/a&gt;) had so many breaking changes that people are &lt;em&gt;still&lt;/em&gt; using Python 2 (even though it is no longer supported).&lt;/p&gt;
&lt;p&gt;Yet Python is consistently one of the most popular programming languages. What am I missing?&lt;/p&gt;
&lt;p&gt;While setting up Python, I noticed that typing &amp;quot;python&amp;quot; into my Windows command prompt launches the Microsoft Store app (compliments of &lt;code&gt;%LocalAppData%\Microsoft\WindowsApps\python.exe&lt;/code&gt;). I&amp;#39;ll give the installer a try since it&amp;#39;s a surprisingly reasonable ~100 MB download. Apparently, Microsoft decided to &lt;a href=&quot;https://devblogs.microsoft.com/python/python-in-the-windows-10-may-2019-update/&quot;&gt;insert this Python shim into Windows itself&lt;/a&gt; just to make it easier for people to find Python. Interesting.&lt;/p&gt;
&lt;h1 id=&quot;going-through-the-tutorial&quot;&gt;Going through the tutorial&lt;/h1&gt;
&lt;p&gt;While going through &lt;a href=&quot;https://docs.python.org/3/tutorial/&quot;&gt;Python&amp;#39;s official tutorial&lt;/a&gt;, I&amp;#39;m already seeing things I don&amp;#39;t like:&lt;/p&gt;
&lt;p&gt;Syntax gripes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are &lt;code&gt;else&lt;/code&gt; blocks on &lt;em&gt;loops&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pass&lt;/code&gt; is needed to denote empty blocks&lt;/li&gt;
&lt;li&gt;There are abbreviations that are easy to forget, such as &lt;code&gt;elif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt; are overused in Python&amp;#39;s syntax&lt;/li&gt;
&lt;li&gt;The syntax for both tuples and sets tries to be pretty, but just ends up creating weird edge cases, such as &lt;code&gt;item,&lt;/code&gt; (requiring a trailing comma) for a single-item tuple and &lt;code&gt;{}&lt;/code&gt; being an empty dictionary and not an empty set&lt;/li&gt;
&lt;li&gt;&amp;quot;f-strings&amp;quot; can&amp;#39;t be arbitrarily nested (i.e. you can&amp;#39;t use quotation marks inside an f-string that is delimited by quotation marks)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Module woes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The module loading system seems needlessly complicated (&lt;code&gt;__init__.py&lt;/code&gt;, &lt;code&gt;__all__&lt;/code&gt;, &lt;code&gt;import *&lt;/code&gt;, etc.)&lt;ul&gt;
&lt;li&gt;It even &lt;em&gt;prepends&lt;/em&gt; the main module&amp;#39;s path to the search path, so local modules are loaded in preference to standard library modules of the same name (pro tip: never create a file named &lt;code&gt;random.py&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The default global scope has too many members&lt;/li&gt;
&lt;li&gt;Virtual environments are &lt;em&gt;definitely&lt;/em&gt; not my preferred solution to managing conflicting dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scoping complaints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variables introduced in a &lt;code&gt;for&lt;/code&gt; loop go into the enclosing scope (making it easy to accidentally change variables in the enclosing scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;global&lt;/code&gt; seems dangerous&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;overall-first-impressions&quot;&gt;Overall first impressions&lt;/h1&gt;
&lt;p&gt;Here are my impressions after going through the Python tutorial and playing with Python for a few days:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t like the syntax, but I also don&amp;#39;t hate it as much as I expected to&lt;/li&gt;
&lt;li&gt;Python definitely shows its age, and it has a lot of compatibility-related warts that are unpleasant&lt;/li&gt;
&lt;li&gt;There are some handy syntactical conveniences (e.g. list comprehensions)&lt;/li&gt;
&lt;li&gt;I am strongly in favor of its &amp;quot;batteries included&amp;quot; approach that yields a robust standard library (it even has SQLite out of the box!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ultimately, Python&amp;#39;s biggest advantage is its popularity.&lt;/p&gt;
&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;
&lt;p&gt;Now that I&amp;#39;ve read up on Python and written some basic scripts (mostly to solve &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt; problems), I&amp;#39;m going to play around with machine learning using Python and NumPy.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Testing out C# in 2022</title>
<id>https://log.schemescape.com/posts/programming-languages/c-sharp.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/c-sharp.html"/>
<updated>2022-02-13T00:00:00.000Z</updated>
<summary type="text">In my quest to find a future-proof programming language, I&apos;m investigating C#.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;a previous article&lt;/a&gt;, I enumerated a bunch of popular programming languages and tried to quickly determine which ones seemed like they&amp;#39;d still be useful in another decade.&lt;/p&gt;
&lt;p&gt;Now, I&amp;#39;m drilling into the most promising candidates. First up is C#.&lt;/p&gt;
&lt;h1 id=&quot;setting-up-a-c-development-environment&quot;&gt;Setting up a C# development environment&lt;/h1&gt;
&lt;p&gt;To my surprise, the &lt;a href=&quot;https://github.com/dotnet/roslyn&quot;&gt;C# compiler&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime&quot;&gt;.NET runtime&lt;/a&gt; are both now open source (MIT license). Even more surprising, you can now apparently &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/iot/deployment&quot;&gt;deploy self-contained .NET executables to a Raspberry Pi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C# is a great language and the .NET standard library is probably the most thoughtfully crafted standard library I&amp;#39;ve ever used. So is my search over? Is C# the answer?&lt;/p&gt;
&lt;p&gt;First, I need to setup a C# development environment. After selecting the .NET runtime and SDK in the Visual Studio installer, I am appalled to see that it requires &lt;em&gt;5 GB&lt;/em&gt; of disk space! There&amp;#39;s probably a bunch of extraneous junk I don&amp;#39;t need, but for comparison: Visual Studio Code is ~300 MB and Deno&amp;#39;s TypeScript runtime is ~60 MB.&lt;/p&gt;
&lt;p&gt;Even after installing all that software, I tried opening a C# project that I created with the &lt;code&gt;dotnet new&lt;/code&gt; command line interface and it told me I needed to install 3.5 GB of software. I think this might be because ASP.NET Core wants to use an older version of .NET. Regardless, as far as I can tell, this is in addition to the 5 GB I already installed, so we&amp;#39;re up to something like 8.5 GB just to run a &amp;quot;hello world&amp;quot; web server.&lt;/p&gt;
&lt;p&gt;Fighting my instinct to run away from such a massive disk footprint, I went ahead and installed everything. At least if I test out C# and find it&amp;#39;s not a good fit for me, I&amp;#39;ll be able to easily recover a large amount of disk space without hesitation.&lt;/p&gt;
&lt;h1 id=&quot;putting-c-and-net-through-its-paces-or-not&quot;&gt;Putting C# and .NET through its paces (or not)&lt;/h1&gt;
&lt;p&gt;As an initial test, I&amp;#39;d like to build a self-contained &amp;quot;hello world&amp;quot; web server, running on Windows (32-bit and 64-bit), Linux (x64 Debian and Alpine), and a Raspberry Pi.&lt;/p&gt;
&lt;p&gt;Unfortunately, even with multiple .NET frameworks and SDKs installed and running Visual Studio, I was not able to successfully build a self-contained executable (it seemed to think I was using .NET Core, which I don&amp;#39;t think I ever installed). After uninstalling the .NET 5.0 SDK, it seems that .NET 4.7.2 was also uninstalled, along with the .NET command line interface (&lt;code&gt;dotnet&lt;/code&gt;). Reloading my test project prompted me to retarget to a previous .NET version, but then the project wouldn&amp;#39;t build at all (even &amp;quot;framework-dependent&amp;quot;). Keep in mind this was a trivial &amp;quot;hello world&amp;quot; &lt;em&gt;command line&lt;/em&gt; app, as in just &lt;code&gt;Console.WriteLine(&amp;quot;Hello, world!&amp;quot;)&lt;/code&gt; inside a class&amp;#39;s &lt;code&gt;Main&lt;/code&gt; function).&lt;/p&gt;
&lt;p&gt;Even worse, after throwing up my hands in frustration, I went to uninstall all the .NET and C# components (to start over from scratch) and now Visual Studio&amp;#39;s installer is claiming some of the components are required for C++ development, so I guess I&amp;#39;m never getting all that disk space back unless I want to break my C++ development environment.&lt;/p&gt;
&lt;h1 id=&quot;thats-unfortunate&quot;&gt;That&amp;#39;s unfortunate...&lt;/h1&gt;
&lt;p&gt;Despite my concerns around C# being closed source, I found that a lot of the C# tooling is actually open source now. Unfortunately, it still seems to be inextricably tied to Visual Studio and its massive, opaque installation process.&lt;/p&gt;
&lt;p&gt;I feel a bit bad about giving up so quickly, but my experience with C# thus far has been the polar opposite of &amp;quot;convenient&amp;quot;. I want a programming language that is future-proof, convenient, and comfortable. C# is comfortable. I don&amp;#39;t know if it&amp;#39;s future-proof (or portable). But it is most definitely &lt;em&gt;not&lt;/em&gt; convenient.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Future-proof programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages.html"/>
<updated>2022-02-11T00:00:00.000Z</updated>
<summary type="text">My projects are currently on hold while I suffer from programming language analysis paralysis.</summary>
<content type="html">&lt;p&gt;After some rapid progress on projects such as &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../releases/md2blog-1.1.1.html&quot;&gt;md2blog&lt;/a&gt;, everything has come to a screeching halt while I struggle with making future-proof technology choices. This post is specifically about programming languages.&lt;/p&gt;
&lt;h1 id=&quot;why-future-proof&quot;&gt;Why future-proof?&lt;/h1&gt;
&lt;p&gt;I want code that I write to continue being useful to me in the future. Specifically, I want to be able to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run my code&lt;/li&gt;
&lt;li&gt;Recompile my code (in case I end up on a new platform)&lt;/li&gt;
&lt;li&gt;Reuse my code in other projects&lt;/li&gt;
&lt;li&gt;Do all of the above with a minimum of hassle (and no multi-gigabyte downloads!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this is why I&amp;#39;m stuck on trying to find a comfortable, future-proof programming language.&lt;/p&gt;
&lt;h1 id=&quot;indicators&quot;&gt;Indicators&lt;/h1&gt;
&lt;p&gt;Here are some ideas on what indicates that a programming language will persist well into the future:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Availability of &lt;em&gt;open source&lt;/em&gt; compilers and tooling (ideally multiple implementations that are mutually compatible)&lt;/li&gt;
&lt;li&gt;Support for many platforms&lt;/li&gt;
&lt;li&gt;Broad usage (both in open source projects and industry)&lt;/li&gt;
&lt;li&gt;Actively maintained standard library&lt;/li&gt;
&lt;li&gt;No breaking changes (ideally)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, I&amp;#39;d also like the programming language to be convenient and comfortable, so I&amp;#39;ll add to my wishlist:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No multi-gigabyte downloads just to get started&lt;/li&gt;
&lt;li&gt;Not tied to a single platform/environment/tool set&lt;/li&gt;
&lt;li&gt;Small and simple (in case I want to build my own tools)&lt;/li&gt;
&lt;li&gt;Easily cross-compiled&lt;/li&gt;
&lt;li&gt;Simple and transparent build process&lt;/li&gt;
&lt;li&gt;Readily available libraries (either with source available or from reputable contributors)&lt;/li&gt;
&lt;li&gt;Ergonomic editing&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;observations&quot;&gt;Observations&lt;/h1&gt;
&lt;p&gt;According to &lt;a href=&quot;https://insights.stackoverflow.com/survey/2021#technology-most-popular-technologies&quot;&gt;Stack Overflow&lt;/a&gt;, the most popular programming languages are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Clojure&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Zig (not actually on the list)&lt;/li&gt;
&lt;li&gt;Lua (also not on the list)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now it&amp;#39;s time to ruthlessly eliminate popular programming languages.&lt;/p&gt;
&lt;p&gt;Some languages are mostly tied to a particular platform, so they get cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java and Perl I have experience with, and frankly, they&amp;#39;re too cumbersome, so I won&amp;#39;t investigate them further.&lt;/p&gt;
&lt;h1 id=&quot;second-round&quot;&gt;Second round&lt;/h1&gt;
&lt;p&gt;After some initial pruning, here is the list with my initial thoughts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript/TypeScript&lt;/strong&gt;: lots of implementations and modern JavaScript is nice, but comes with a ton of baggage; TypeScript brings some sanity to the language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;: setting up a Python environment is a recurring nightmare of mine, but it&amp;#39;s so popular that I probably need to give it another shot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt;: a great language and standard library, but how much of it is open source? Is it portable? Can I run .NET on a Raspberry Pi?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;: terribly complex, but modern C++ is surprisingly convenient; the build systems are generally awful, though&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: probably the most portable and future-proof language ever created, but not very ergonomic&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go&lt;/strong&gt;: &amp;quot;goroutines&amp;quot; seem great and I&amp;#39;ve heard the tooling is nice, but a garbage-collected language with C-like verbosity sounds like the worst of both worlds to me&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: new and popular, with an appealing memory model, but there&amp;#39;s really only one implementation and &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;my first experience setting Rust up on Windows was terrible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ruby&lt;/strong&gt;: just as annoying to setup as Python, but less popular&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Haskell&lt;/strong&gt;: it&amp;#39;s been a while since I used a purely functional programming language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lisp/Clojure&lt;/strong&gt;: I love the simplicity of Lisp (namely Scheme), but I have doubts about it being convenient and portable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zig&lt;/strong&gt;: probably too new and with too many breaking changes, but I like the idea of a more sane alternative to C, and the Zig compiler is very convenient&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;: I used to love Lua, but TypeScript just seems so much more popular and productive these days (also: I hate 1-based arrays)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given that this list is already too long, I&amp;#39;m going to eliminate a few options without proper due diligence (either based on prior experience or based on the belief that similar but superior options exist elsewhere on this list). Apologies to the following languages that have been cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Lua&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;third-round&quot;&gt;Third round&lt;/h1&gt;
&lt;p&gt;For the next round, I&amp;#39;ll do more research and hopefully play around with the languages I&amp;#39;m unfamiliar with.&lt;/p&gt;
&lt;p&gt;Some initial thoughts on the languages I&amp;#39;m familiar with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript: comfortable and convenient, but memory usage and (lack of) parallelism are concerns&lt;/li&gt;
&lt;li&gt;C#: can this run on a Raspberry Pi? How much of the standard library is closed source?&lt;/li&gt;
&lt;li&gt;C++: is there C++ environment that is quick and easy to setup?&lt;/li&gt;
&lt;li&gt;C: a frontrunner, despite its numerous problems&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here are the languages I need to investigate further:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Lisp/Clojure&lt;/li&gt;
&lt;li&gt;Zig&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all for now&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s as far as I&amp;#39;ve gotten. My next steps are to see if C# is viable, determine if there&amp;#39;s a convenient C++ environment, give Python yet another try, and then play around with Go, Rust, Clojure (or other Lisps), and Zig.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Frameworks for porting web apps to the desktop</title>
<id>https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html"/>
<updated>2022-01-13T00:00:00.000Z</updated>
<summary type="text">This is my initial research into converting a web app to a desktop app.</summary>
<content type="html">&lt;p&gt;I have a browser-based application that I&amp;#39;d like to transform into a &amp;quot;normal&amp;quot; desktop application.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;My situation is fairly unique, but here&amp;#39;s my motivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My app is already web-based (using HTML, CSS, TypeScript, with a corresponding HTTP API that&amp;#39;s deployed to &lt;a href=&quot;https://functions.netlify.com/&quot;&gt;Netlify Functions&lt;/a&gt;), and I don&amp;#39;t want to rewrite any of my code&lt;/li&gt;
&lt;li&gt;I&amp;#39;m planning to use a distribution service that&amp;#39;s based on plain old desktop executables (this is probably an unusual requirement)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some more typical reasons for porting from web to desktop might be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wanting to take advantage of libraries, devices, or system APIs that aren&amp;#39;t available in the browser&lt;/li&gt;
&lt;li&gt;Wanting to integrate with native code that (probably due to performance) won&amp;#39;t be ported to WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;why-not&quot;&gt;Why not?&lt;/h1&gt;
&lt;p&gt;Some downsides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Electron (the most popular desktop framework for web technologies) produces large binaries (100+ MB) that use a lot of memory (due to bundling an entire browser engine within each application, presumably to ensure consistency across devices)&lt;ul&gt;
&lt;li&gt;This also means that copyright notices for a huge number of open source libraries Chromium uses must be included&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These frameworks typically have their own unique build processes, which adds additional complexity as compared to building a desktop app &amp;quot;the normal way&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;My research turned up the following relevant frameworks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;Electron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nwjs.io/&quot;&gt;NW.js&lt;/a&gt; (formerly node-webkit)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tauri-apps/tauri&quot;&gt;Tauri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs&quot;&gt;Neutralinojs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here is my uneducated, subjective comparison (all of these frameworks currently support Windows, Linux, and macOS, with Tauri planning to eventually support iOS and Android):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Framework&lt;/th&gt;
&lt;th&gt;Engine&lt;/th&gt;
&lt;th&gt;Maturity&lt;/th&gt;
&lt;th&gt;License&lt;/th&gt;
&lt;th&gt;Examples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Electron&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;Stable&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;VS Code, Slack, Discord&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NW.js&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tauri&lt;/td&gt;
&lt;td&gt;Chromium (Windows)&lt;br/&gt;WebKit (Linux/macOS)&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;Apache&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Neutralinojs&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs/blob/main/LICENSE&quot;&gt;Many&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I&amp;#39;m ignoring native code interop because it&amp;#39;s not relevant to me, but I believe NW.js uses Node and Tauri uses Rust.&lt;/p&gt;
&lt;h1 id=&quot;my-plan&quot;&gt;My plan&lt;/h1&gt;
&lt;p&gt;For my purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I only &lt;em&gt;need&lt;/em&gt; to support Windows (at least initially)&lt;/li&gt;
&lt;li&gt;I may not need desktop integration or native code&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to produce a minimal binary package (i.e. I don&amp;#39;t want to bundle an entire browser runtime if I don&amp;#39;t have to)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on that last requirement, Tauri (or maybe Neutralinojs) seemed like the best match, but I had concerns about reliability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tauri is built on &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt;, which is installed separately from the operating system (so not all Windows computers will have it installed)&lt;/li&gt;
&lt;li&gt;Tauri&amp;#39;s bundler produces installers on Windows that apparently &lt;a href=&quot;https://github.com/tauri-apps/tauri/issues/2452&quot;&gt;don&amp;#39;t clearly communicate this requirement&lt;/a&gt;, possibly leading to broken installs&lt;/li&gt;
&lt;li&gt;This also means that installation inherits the WebView2 runtime&amp;#39;s need for elevated privileges (avoidable by distributing the runtime as well, but that&amp;#39;s basically Electron at that point)&lt;/li&gt;
&lt;li&gt;Obviously, if I want to later expand to Linux and/or macOS (where Tauri uses WebKit) I might run into incompatibilities (although I haven&amp;#39;t heard of any with the web version of my app)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taken as a whole (and given that WebView2 is relatively new), unless I have some way to ensure the WebView2 runtime will be present, I will likely end up using Electron, despite my reservations around download size and efficiency. At least in my case, there are some mitigating factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This isn&amp;#39;t an app I expect users to have open all the time (so memory usage is less of a concern)&lt;/li&gt;
&lt;li&gt;There is a simple fallback for anyone who wants to avoid a large download: just use the web version!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This isn&amp;#39;t the answer I had hoped for, but I&amp;#39;m trying to be pragmatic. Hopefully in the future WebView2 will be installed by default and I can switch to something more lightweight like Tauri.&lt;/p&gt;
</content>
</entry>
</feed>
