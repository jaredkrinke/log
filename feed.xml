<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-04-08T02:48:19.154Z</updated>

<entry>
<title>Speeding up md2blog, part 3</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-3.html"/>
<updated>2023-04-07T00:00:00.000Z</updated>
<summary type="text">I made a rookie mistake while trying to optimize my workflow for building this site.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;part 2&lt;/a&gt;, I added support for incremental builds of this site, based on GNU Make.&lt;/p&gt;
&lt;h1 id=&quot;original-thought-process&quot;&gt;Original thought process&lt;/h1&gt;
&lt;p&gt;My reasoning for investigating incremental builds seemed sound:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rebuilding the entire site &lt;em&gt;every time&lt;/em&gt; was obviously unnecessary&lt;/li&gt;
&lt;li&gt;Based on some measurements, syntax highlighting and processing Markdown were the most time-consuming operations (in that order), by far&lt;/li&gt;
&lt;li&gt;Thus, it made sense to avoid re-running these steps for pages that didn&amp;#39;t require updates&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I went ahead with my experiment fully aware that GNU Make probably wasn&amp;#39;t well-suited to the project (because it creates a new process for each task and Deno, while reasonable, has significant startup overhead). I&amp;#39;m still happy I used Make because this issue has straight-forward mitigations: don&amp;#39;t spin up new processes (e.g. rely on a server) or move the dependency graph into md2blog&amp;#39;s main process.&lt;/p&gt;
&lt;h1 id=&quot;but&quot;&gt;But...&lt;/h1&gt;
&lt;p&gt;... I made a rookie mistake. Rather than carefully scrutinizing my workflow, I just charged ahead with optimizing the obvious bottleneck. In the end, I was able to easily get the incremental build down to 3 seconds (N.B. on a 12 year-old netbook). This meant that I could author a new post and view the results on my (slow) computer fairly quickly, to enable fast iteration.&lt;/p&gt;
&lt;p&gt;So what&amp;#39;s the problem?&lt;/p&gt;
&lt;p&gt;The problem is that I measured a full clean build in isolation, but my actual workflow when using md2blog is to run md2blog as a server that watches the file system and automatically triggers rebuilds, and &lt;em&gt;those&lt;/em&gt; subsequent (full) rebuilds are not only about 50% faster (down in the 6 second range), they are also ripe for &lt;em&gt;even simpler&lt;/em&gt; optimizations.&lt;/p&gt;
&lt;h1 id=&quot;a-new-approach&quot;&gt;A new approach&lt;/h1&gt;
&lt;p&gt;Given that rebuilds in my &amp;quot;edit and test&amp;quot; (hot-reloading server) workflow all run in the same process and most of the work is redundant (rebuilding pages that haven&amp;#39;t changed), and that the most expensive operation (by far) is adding syntax highlighting, one trivial optimization would be to simply &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoize&lt;/a&gt; the syntax highlighting function.&lt;/p&gt;
&lt;p&gt;For memory efficiency, I initially planned to hash input strings and use that as the key to look up results in a cache. This ended up being trickier than I expected because the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest&quot;&gt;&lt;code&gt;crypto.subtle.digest&lt;/code&gt;&lt;/a&gt; function provides its result asynchronously and &lt;a href=&quot;https://marked.js.org/using_advanced#highlight&quot;&gt;Marked&amp;#39;s highlight callback&lt;/a&gt; is synchronous. In the end, I decided this was premature optimization anyway--I&amp;#39;m already going to be caching the entire output in memory, so caching the entire input as well is just a linear increase in memory usage--there&amp;#39;s no need to complicate things.&lt;/p&gt;
&lt;p&gt;After writing about 10 lines of trivial code, I had a working cache, and rebuilds were under 3 seconds--faster than my previous convoluted incremental approach. Most of the remaining time was simply validating that internal links are not broken (a step I haven&amp;#39;t implemented in my Makefile yet).&lt;/p&gt;
&lt;p&gt;Lesson learned: always measure and optimize the &lt;em&gt;actual&lt;/em&gt; scenario--not an artifical (or easier to measure) one!&lt;/p&gt;
&lt;h1 id=&quot;further-optimizations&quot;&gt;Further optimizations&lt;/h1&gt;
&lt;p&gt;With this one trivial optimization, I got an acceptably fast workflow, even on a 12 year-old netbook. But there were still two obvious avenues for improvement (that didn&amp;#39;t involve switching languages or runtimes):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Move internal link-checking off the critical path of my workflow (either by deferring it or skipping it entirely--broken links will be caught when I do a full &amp;quot;official&amp;quot; build, prior to uploading the site)&lt;/li&gt;
&lt;li&gt;Implement real incremental builds, at least for internal rebuilds (done properly, this could even avoid a significant chunk of link-checking work)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After moving link-checking off the critical path (#1 above), hot rebuilds now complete in under a second (with link-checking completing a second or two later), so I&amp;#39;m no longer feeling terribly motivated to rearchitect everything around an accurate dependency graph (#2), at least not until I either add enough content to make things feels sluggish once again or I downgrade to an even slower computer.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Minimal dev environment, part 4</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-4.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-4.html"/>
<updated>2023-04-06T00:00:00.000Z</updated>
<summary type="text">My minimal development environment was too minimal, so I upgraded to a faster computer.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html&quot;&gt;part 3&lt;/a&gt;, I tried out a minimal development environment (based on Alpine Linux) on a Raspberry Pi 1 B. This update is essentially the conclusion of my Raspberry Pi experiment.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s a summary of what I&amp;#39;ve learned so far:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I love Alpine Linux--it honestly feels like the only sane way to manage a Linux distribution--because it&amp;#39;s fast, light, and (mostly) only contains the tools you ask for&lt;/li&gt;
&lt;li&gt;The Raspberry Pi 1 B is &lt;em&gt;very&lt;/em&gt; slow--I was willing to accept that my JavaScript/Deno-based static site generator might be slow (I never really optimized it), but paging through code in Vim (in the terminal) is something I &lt;em&gt;need&lt;/em&gt; to be fast, and my Pi-based setup failed at this&lt;/li&gt;
&lt;li&gt;Browsing the modern web in a terminal is unpleasant&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;enter-the-gui&quot;&gt;Enter the GUI&lt;/h1&gt;
&lt;p&gt;To address the last point, I decided to see if I could get a lightweight GUI environment running on the Pi. I hadn&amp;#39;t run a Linux desktop in over a decade, but I previously used &lt;a href=&quot;http://fluxbox.org/&quot;&gt;Fluxbox&lt;/a&gt; and later &lt;a href=&quot;https://www.gnome.org/&quot;&gt;GNOME&lt;/a&gt;, so I&amp;#39;m not completely lost. The latter is a full desktop environment, and fairly heavy, so I decided to give Fluxbox a shot first (after reading up on how to run rootless X.org).&lt;/p&gt;
&lt;p&gt;Getting X.org up and running with Fluxbox wasn&amp;#39;t too difficult, and then I was able to use the &lt;a href=&quot;https://www.dillo.org/&quot;&gt;Dillo browser&lt;/a&gt; to improve my web browsing experience. Unfortunately, everything GUI-related was painfully slow, especially moving windows around. Just in case I was missing some sort of hardware acceleration or something, I tested out the official Raspberry Pi OS. It was unbearably slow as well (and the build of Chromium appeared to be for ARMv7, which my Pi doesn&amp;#39;t support).&lt;/p&gt;
&lt;h1 id=&quot;goodbye-pi&quot;&gt;Goodbye, Pi&lt;/h1&gt;
&lt;p&gt;To be honest, it&amp;#39;s impressive how much you can do with a 10+ year-old, less than $50 (originally) single-board computer (running at 3.5 Watts). I could run Linux, edit and compile C code, browse the web in a terminal, read RSS feeds, and even run Node/NPM. It seems perfect for running a low-traffic server at home (something I &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../services/cheap-hosting.html&quot;&gt;don&amp;#39;t need to do at the moment&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;But the bottom line is that I want something faster.&lt;/p&gt;
&lt;p&gt;There are newer Raspberry Pi models that should be &lt;em&gt;much&lt;/em&gt; faster than my almost-original--and I&amp;#39;d like to try one out someday--but for now I&amp;#39;m proceeding with hardware that I already own. &lt;/p&gt;
&lt;h1 id=&quot;hello-netbook&quot;&gt;Hello, netbook&lt;/h1&gt;
&lt;p&gt;Specifically, I&amp;#39;m upgrading to a 12 year-old Dell netbook (Inspiron Mini 1018) with a 1.66 GHz Intel Atom (N455) processor and 1 GB of RAM.&lt;/p&gt;
&lt;h2 id=&quot;linux-on-a-laptop-is-pretty-great&quot;&gt;Linux on a laptop... is pretty great!&lt;/h2&gt;
&lt;p&gt;As an aside, I&amp;#39;m compelled to comment on how much the laptop experience on Linux has improved since I last gave up (in the mid-00s). The sub-200 MB Alpine Linux installer &lt;em&gt;just worked&lt;/em&gt;, even for Wi-Fi! Additionally, I discovered that, even though the netbook shipped with 32-bit Windows, its processor is actually 64-bit, so now I&amp;#39;m running an architecture that is &lt;em&gt;still relevant&lt;/em&gt;. This is intriguing to me because Deno only supports 64-bit processors, and I assumed that the old hardware I had laying around couldn&amp;#39;t run Deno.&lt;/p&gt;
&lt;p&gt;Having said that, at one point I decided to see if Debian would work better than Alpine. The Debian installer worked great (it automatically supported wireless networking on my netbook), but after installation wireless stopped working. After a few hours of researching and trying to fix the problem, I reverted back to Alpine.&lt;/p&gt;
&lt;p&gt;For the record, only &amp;quot;suspend&amp;quot; works on this laptop (hibernate is indistinguishable from powering off). I also have to manually adjust the terminal resolution using &lt;code&gt;fbset&lt;/code&gt; (after enabling Linux &amp;quot;Kernel Mode Setting&amp;quot;, a.k.a. KMS). Not a seamless experience, but still acceptable.&lt;/p&gt;
&lt;h1 id=&quot;performance&quot;&gt;Performance&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s a quick performance comparison of building this site using &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt;, on various JavaScript runtimes, between my Raspberry Pi 1 B and my Dell Inspiron Mini 1018:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Build time by device&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;&lt;a href=&quot;https://github.com/jaredkrinke/leano&quot;&gt;leano&lt;/a&gt;&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Node&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Deno&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Raspberry Pi&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;4 minutes&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;2 minutes&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;not possible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Netbook&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;1 minute&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;20 seconds&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I had to resort to using &lt;a href=&quot;https://github.com/NixOS/nix&quot;&gt;Nix&lt;/a&gt; to get Deno running because Deno depends on &lt;a href=&quot;https://www.gnu.org/software/libc/&quot;&gt;glibc&lt;/a&gt; and doesn&amp;#39;t support &lt;a href=&quot;https://musl.libc.org/&quot;&gt;musl&lt;/a&gt; (the C standard library implementation that Alpine Linux uses).&lt;/p&gt;
&lt;p&gt;Overall, this is a 4 - 6x performance improvement (on a machine that coincidentally cost 4 - 6 times as much as the Pi 1 B, originally).&lt;/p&gt;
&lt;h2 id=&quot;battery-life&quot;&gt;Battery life&lt;/h2&gt;
&lt;p&gt;My old setup chained me to my desk, but now I can take my laptop wherever. I don&amp;#39;t really remember what the battery life was like originally (or on Windows), but I&amp;#39;m able to get 4 - 6 hours of intensive use. That is plenty for me at the moment, although it certainly doesn&amp;#39;t seem like &amp;quot;good&amp;quot; battery life. I&amp;#39;ve also noticed that the (rotational) hard drive seems to spin up and down consistently every 5 seconds, even when I&amp;#39;m not doing anything. I&amp;#39;m not sure if it&amp;#39;s a hardware, driver, or Linux problem, but I&amp;#39;m just trying to ignore it for now. &lt;/p&gt;
&lt;h2 id=&quot;power-consumption&quot;&gt;Power consumption&lt;/h2&gt;
&lt;p&gt;One area where the Raspberry Pi excelled was power consumption. At max capacity, I measured it at around 3.5 Watts.&lt;/p&gt;
&lt;p&gt;My netbook is much less efficient, but overall not too bad. At full load, it seems to peak around 15 - 20 Watts. In standby, it consumes rougly 4 Watts, which is pretty similar to the Raspberry Pi (considering that I never powered down the Pi).&lt;/p&gt;
&lt;h1 id=&quot;to-be-continued&quot;&gt;To be continued...&lt;/h1&gt;
&lt;p&gt;Now that I&amp;#39;ve got a tolerably fast computer, I can get some &lt;em&gt;real&lt;/em&gt; work done. In the next post, I&amp;#39;m planning to cover the software side of things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding a console &amp;quot;taskbar&amp;quot; to GNU Screen&lt;/li&gt;
&lt;li&gt;Attempting to use a language server with a text editor&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog, part 2</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html"/>
<updated>2023-04-02T00:00:00.000Z</updated>
<summary type="text">Using GNU Make to enable incremental builds of this site.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html&quot;&gt;part 1&lt;/a&gt;, I brainstormed some ideas to speed up rebuilds of my static site (because I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html&quot;&gt;playing around with using old/slow computers&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In this update, I&amp;#39;m going to share a potentially misguided (but functional!) approach to supporting incremental builds using &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;GNU Make&lt;/a&gt;. The code is &lt;a href=&quot;https://github.com/jaredkrinke/make-blog&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;My static site generator, &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html&quot;&gt;md2blog&lt;/a&gt;, is written in TypeScript, simply because I&amp;#39;m used to the language and it&amp;#39;s popular. On my desktop computer, rebuilding this site is trivially fast. But once I switched to a Raspberry Pi 1 B (and now a 12 year-old netbook), the overhead of JavaScript became more noticeable. On my netbook, I&amp;#39;ve been able to get the full rebuild time of this site (only full rebuilds are supported in md2blog) down to about 12 seconds. This is tolerable, but obviously still inefficient. If I&amp;#39;m only adding or modifying a single post, why should I rebuild the entire site?&lt;/p&gt;
&lt;p&gt;Incremental builds should be possible by caching some intermediate state. Originally, I&amp;#39;d hoped to implement a generic solution in TypeScript, but part way through I realized that I was essentially reimplementing Make. So why not just use Make?&lt;/p&gt;
&lt;h1 id=&quot;md2blogs-build-process&quot;&gt;md2blog&amp;#39;s build process&lt;/h1&gt;
&lt;p&gt;md2blog is designed to be simple, but complete. This means that the build process is straight-forward:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clean up the output directory (delete everything)&lt;/li&gt;
&lt;li&gt;Read (and validate) site-wide metadata from &lt;code&gt;site.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Read (and validate) front matter from all posts (and remove drafts, if requested)&lt;/li&gt;
&lt;li&gt;Implicitly tag posts with their parent directory name (in addition to any explicitly-entered keywords)&lt;/li&gt;
&lt;li&gt;Generate an index of tags to posts&lt;/li&gt;
&lt;li&gt;Generate some necessary files (error page, stylesheet)&lt;/li&gt;
&lt;li&gt;Process Markdown (adding syntax highlighting and rewriting relative &lt;code&gt;*.md&lt;/code&gt; links, as needed)&lt;/li&gt;
&lt;li&gt;Generate an Atom feed of recent posts&lt;/li&gt;
&lt;li&gt;Generate an archive and tag index pages&lt;/li&gt;
&lt;li&gt;Validate all internal links&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After writing down that list, I&amp;#39;m realizing there are a lot of steps, but they&amp;#39;re mostly just to support implicit tags and various index pages. Regardless, it&amp;#39;s relatively straight-forward.&lt;/p&gt;
&lt;h1 id=&quot;using-gnu-make&quot;&gt;Using GNU Make&lt;/h1&gt;
&lt;p&gt;Like a good little developer, I&amp;#39;ve shied away from using GNU Make-specific functionality, and have just used the limited subset of Make that is widely supported. But for this project, I ended up needing to dig deep into GNU Make&amp;#39;s functionality to model md2blog&amp;#39;s build process correctly.&lt;/p&gt;
&lt;p&gt;Specifically, there were a few aspects of md2blog&amp;#39;s build process that were tricky to implement using GNU Make:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Enumerating posts and their implicit directory structure&lt;/li&gt;
&lt;li&gt;Cleaning up extraneous files in the &lt;code&gt;out&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;Aggregating all posts into a single archive&lt;/li&gt;
&lt;li&gt;Discovering and handling tags that don&amp;#39;t correspond to any directory (i.e. keywords)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;enumerating-and-cleaning-files&quot;&gt;Enumerating and cleaning files&lt;/h2&gt;
&lt;p&gt;In this case, I wanted to avoid listing all posts explicitly in my &lt;code&gt;Makefile&lt;/code&gt;--I just wanted it to discover all of the files in the file system, a la &amp;quot;classic&amp;quot; md2blog. GNU Make supports enumerating files by letting you delegate that job to the &lt;code&gt;find&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# Use &amp;quot;find&amp;quot; to enumerate all directories and files under &amp;quot;content/&amp;quot; (excluding &amp;quot;content/&amp;quot; itself)&lt;/span&gt;
INPUT_FILES := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; find content -follow -type f -not -name &amp;#x27;.*&amp;#x27;)&lt;/span&gt;
INPUT_DIRECTORIES := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out content,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; find content -follow -type d)&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in the above snippet I also enumerate directories. This is so that I can recreate the same directory structure in the output directory. I also exclude files beginning with a dot (e.g. swap files).&lt;/p&gt;
&lt;p&gt;How do I &amp;quot;clean&amp;quot; up any extraneous files &lt;em&gt;before&lt;/em&gt; anything builds? The only reliable solution I could come up with was to sneakily run a command while expanding an usused &lt;em&gt;simply expanded&lt;/em&gt; (&lt;code&gt;:=&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;) variable (note: it must be simply expanded to ensure it is expanded first, and only once):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;INPUT_FILES_POSTS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt; content/posts/%.md,&lt;span class=&quot;hljs-variable&quot;&gt;$(INPUT_FILES)&lt;/span&gt;)&lt;/span&gt;
INTERMEDIATE_FILES_POST_METADATA := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;patsubst&lt;/span&gt; content/posts/%.md,cache/posts/%.metadata.json,&lt;span class=&quot;hljs-variable&quot;&gt;$(INPUT_FILES_POSTS)&lt;/span&gt;)&lt;/span&gt;
...
INTERMEDIATE_FILES_EXTRANEOUS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES)&lt;/span&gt;,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; mkdir -p cache &amp;amp;&amp;amp; find cache -type f)&lt;/span&gt;)
...
TIDY_RESULT := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; rm -f &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES_EXTRANEOUS)&lt;/span&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feels like a hack, since it relies on a side-effect of a &lt;code&gt;$(shell ...)&lt;/code&gt; expansion, but it&amp;#39;s the best solution I could come up with.&lt;/p&gt;
&lt;h2 id=&quot;aggregating-posts&quot;&gt;Aggregating posts&lt;/h2&gt;
&lt;p&gt;Aggregating a bunch of posts into a single index sounds like a trivial problem, and it really should be. But since GNU Make relies on command lines, I&amp;#39;m paranoid that any solution which relies on passing paths to &lt;em&gt;every&lt;/em&gt; post via the command line will run into the dreaded command line length limit (which varies significantly in the wild, and isn&amp;#39;t always documented properly).&lt;/p&gt;
&lt;p&gt;The only solution I could come up with was to pass the large list via the file system. This could either be done using a file that lists the paths, or it could be implicit by searching a directory tree (assuming that the tree has been purged of extraneous files--as I do above).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;cache/posts/index.json: &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_FILES_POST_METADATA)&lt;/span&gt; | &lt;span class=&quot;hljs-variable&quot;&gt;$(INTERMEDIATE_DIRECTORIES)&lt;/span&gt;&lt;/span&gt;
    deno run --allow-read=cache --allow-write=cache index.ts cache/posts &lt;span class=&quot;hljs-variable&quot;&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the order-only prerequisite for &lt;code&gt;$(INTERMEDIATE_DIRECTORIES)&lt;/code&gt; that ensures the directory structure is already in place before the script runs.&lt;/p&gt;
&lt;h3 id=&quot;aside-on-aigpt&quot;&gt;Aside on AI/GPT&lt;/h3&gt;
&lt;p&gt;Given that I was somewhat stumped by this problem, I decided to try asking Bing&amp;#39;s fancy new GPT-based AI chat thingy. Its response was pretty underwhelming. Its first suggestion was to switch from GNU Make to... GNU Make. The second suggestion was to use VPATHs--but that&amp;#39;s a solution to a different problem. And its last suggestion was just clearly copy-pasted--without proper context!--from GNU Make&amp;#39;s documentation.&lt;/p&gt;
&lt;p&gt;Overall, the answer pointed to documentation I had already consulted (so it &lt;em&gt;did&lt;/em&gt; find information I had already noted as potentially relevant), but the answer was mostly &amp;quot;just don&amp;#39;t do that, duh!&amp;quot;. Color me not impressed.&lt;/p&gt;
&lt;h2 id=&quot;discovering-tags-that-dont-exist-as-directories&quot;&gt;Discovering tags that don&amp;#39;t exist as directories&lt;/h2&gt;
&lt;p&gt;My current solution to discovering tags that don&amp;#39;t also exist as directories runs a script that enumerates tags programmatically and then outputs &lt;em&gt;all&lt;/em&gt; index pages. This requires also managing the creation and non-cleanup-ification of those directories. Sadly, my current solution has a bug (it doesn&amp;#39;t programmatically clean up extraneous tag indexes), but the scenario (deleting a unique keyword) is rare enough that I haven&amp;#39;t bothered to fix the bug yet.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s where I had to hack in a pattern to avoid treating programmatically-discovered tags&amp;#39; index pages as extraneous (for the purposes of cleaning up the output directory):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Makefile&quot;&gt;OUTPUT_FILES_EXTRANEOUS := &lt;span class=&quot;hljs-variable&quot;&gt;$(&lt;span class=&quot;hljs-built_in&quot;&gt;filter&lt;/span&gt;-out &lt;span class=&quot;hljs-variable&quot;&gt;$(OUTPUT_FILES)&lt;/span&gt; out/posts/%/index.html,$(&lt;span class=&quot;hljs-built_in&quot;&gt;shell&lt;/span&gt; mkdir -p out &amp;amp;&amp;amp; find out -type f)&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;performance&quot;&gt;Performance&lt;/h1&gt;
&lt;p&gt;So was this all worth it? The answer is: kind of. Here&amp;#39;s a table with the results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Scenario&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;Elapsed time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;classic&amp;quot; md2blog&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;12 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Full rebuild using &amp;quot;make&amp;quot;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;90 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;Incremental build using &amp;quot;make&amp;quot;&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3 seconds&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;I haven&amp;#39;t heavily optimized the incremental build process, but as it stands currently, an incremental build using Make is 4x faster, but a full rebuild using Make is 8x slower. If I could get the &amp;quot;full rebuild&amp;quot; time down to a reasonable level, I&amp;#39;d be very happy.&lt;/p&gt;
&lt;h2 id=&quot;bottlenecks&quot;&gt;Bottlenecks&lt;/h2&gt;
&lt;p&gt;The biggest issue with leveraging Make in this case is that it spins up a separate process for each build command, but I&amp;#39;m using a JavaScript runtime that has a significant startup cost. I&amp;#39;m not sure exactly how Deno works internally, but setting up a relatively heavy JavaScript environment for processing markdown and adding syntax highlighting, just for a single file, seems wasteful and slow (even when running in parallel--something that GNU Make enables).&lt;/p&gt;
&lt;h2 id=&quot;potential-improvements&quot;&gt;Potential improvements&lt;/h2&gt;
&lt;p&gt;There&amp;#39;s a silver lining, however. Because Make decomposes each step into a separate command line, I could theoretically replace the underlying tool of the slowest commands with a more efficient implementation (without touching anything else). In my case, the slowest processes are syntax highlighting and processing markdown (in that order). I&amp;#39;m tempted to try using native code implementations of these two steps to see how much startup/process creation overhead that avoids.&lt;/p&gt;
&lt;p&gt;Another solution might be to run a persistent JavaScript server and use a trivial tool to communicate with it. For example, running an HTTP server with Deno and using &lt;code&gt;wget&lt;/code&gt; in my command lines to send it processing jobs. I&amp;#39;m not sure if GNU Make has any support for such a server process, but I suspect I could hack something together by launching a server process into the background and just having it spin itself down after some number of seconds of inactivity.&lt;/p&gt;
&lt;h1 id=&quot;this-post-brought-to-you-by-make-blog&quot;&gt;This post brought to you by &lt;strong&gt;make-blog&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;A 9 second improvement for incremental builds doesn&amp;#39;t sound terribly noticeable, but just in the process of authoring this post I&amp;#39;m already finding it useful. Now I can tweak a few words or a bit of formatting and view the result (almost) immediately, even on my super slow twelve year-old netbook.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll most likely continue using &amp;quot;old&amp;quot; md2blog for officially updating the site prior to publishing (just because I&amp;#39;m paranoid), but I&amp;#39;m still satisfied with my improved local workflow.&lt;/p&gt;
&lt;p&gt;In case anyone&amp;#39;s curious, here is the code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jaredkrinke/make-blog&quot;&gt;make-blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Reflecting on my first release on Steam, SIC-1</title>
<id>https://log.schemescape.com/posts/game-development/sic-1-retrospective.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1-retrospective.html"/>
<updated>2023-03-25T00:00:00.000Z</updated>
<summary type="text">This is a retrospective on my first game I&apos;ve released on Steam, along with some thoughts about the future.</summary>
<content type="html">&lt;p&gt;It&amp;#39;s been almost four months since I released &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html&quot;&gt;SIC-1&lt;/a&gt; (a single-instruction programming game) for free on Steam (and re-released it &lt;a href=&quot;https://jaredkrinke.itch.io/sic-1&quot;&gt;on itch.io&lt;/a&gt;). This is an update on how the release went, and my plans for the future.&lt;/p&gt;
&lt;h1 id=&quot;financial-summary&quot;&gt;Financial summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Revenue: $0&lt;/li&gt;
&lt;li&gt;Expenses: $134.07&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIC-1 can be played by anyone for free (with no ads), so it&amp;#39;s earned a grand total of $0 in revenue. Expenses include a $100 Steam direct fee, and roughly $34 for a year of (completely optional) web hosting.&lt;/p&gt;
&lt;h2 id=&quot;do-i-regret-releasing-sic-1-for-free&quot;&gt;Do I regret releasing SIC-1 for free?&lt;/h2&gt;
&lt;p&gt;I released SIC-1 for free because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Free games attract more players, and I wanted as many players as possible to fill up the charts/leaderboards&lt;/li&gt;
&lt;li&gt;I strongly doubted I would ever earn enough money from SIC-1 to make a meaningful financial difference in my life&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the absolute best case scenario, let&amp;#39;s assume that all 1,800 players on Steam bought the game for my hypothetical full price of $10. Taking out Steam&amp;#39;s 30% fee and another 15% for taxes, that would be a little under $11,000 in my theoretical pocket. An extra $11k actually sounds pretty great! Realistically, however, &lt;a href=&quot;https://vginsights.com/insights/article/infographic-indie-game-revenues-on-steam&quot;&gt;most indie games make less than $4,000 (lifetime)&lt;/a&gt;, and SIC-1 probably would have ended up even lower (on a couple hundred sales, at less than $4 net profit per sale).&lt;/p&gt;
&lt;p&gt;Additionally, if I had wanted to charge for the game on Steam, I would have had to either start charging for the previously free game on itch.io or take that version down entirely. That would feel like a betrayal of existing players. On the flip side, if I had charged for the game, I would have felt like I couldn&amp;#39;t eventually make the game free (or open source) because that might annoy my biggest fans (the ones who actually gave me money). A freemium model might have resolved these problems, but I didn&amp;#39;t want to fragment the player base over a small amount of money.&lt;/p&gt;
&lt;p&gt;In the end, earning some extra money would have been nice from a motivational standpoint, but I think I made the right decision to release the game for free.&lt;/p&gt;
&lt;h1 id=&quot;statistics&quot;&gt;Statistics&lt;/h1&gt;
&lt;h2 id=&quot;steamitchio-statistics&quot;&gt;Steam+itch.io statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;3,500 people started in the in-game tutorial&lt;/li&gt;
&lt;li&gt;1,700 completed the first puzzle&lt;/li&gt;
&lt;li&gt;500 completed the most difficult arithmetic task&lt;/li&gt;
&lt;li&gt;230 completed the first sequence task&lt;/li&gt;
&lt;li&gt;50 completed (correctly) the entire set of sequence puzzles&lt;/li&gt;
&lt;li&gt;30 completed the original set of 30 puzzles&lt;/li&gt;
&lt;li&gt;11 have completed the (new) final puzzle&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;steam-specific-statistics&quot;&gt;Steam-specific statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;13,000 free licenses granted&lt;/li&gt;
&lt;li&gt;1,800 lifetime unique users&lt;/li&gt;
&lt;li&gt;20 positive reviews&lt;/li&gt;
&lt;li&gt;Peak concurrent players: 10&lt;/li&gt;
&lt;li&gt;Daily active users peaked at 65 in January and trended down to 10 as of late March&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;statistics-summary&quot;&gt;Statistics summary&lt;/h2&gt;
&lt;p&gt;I made SIC-1 for fun. I knew that the market for programming games was probably pretty small. But I guess I didn&amp;#39;t quite realize &lt;em&gt;how small&lt;/em&gt; that market actually is. Even &lt;a href=&quot;https://www.zachtronics.com/last-call-bbs/&quot;&gt;Last Call BBS&lt;/a&gt;, the most recent (and final) game from &lt;a href=&quot;https://www.zachtronics.com/&quot;&gt;Zachtronics&lt;/a&gt; only has roughly 700 positive reviews (and approximately 22k sales).&lt;/p&gt;
&lt;p&gt;SIC-1 was able to reach 20 positive reviews in four months (with no negative reviews) and &lt;a href=&quot;https://vginsights.com/game/2124440&quot;&gt;Video Game Insights estimates that SIC-1 is in the top 45% for positive reviews and units &amp;quot;sold&amp;quot;&lt;/a&gt;. Given the niche audience and punishing nature of single-instruction programming, that actually sounds pretty good!&lt;/p&gt;
&lt;p&gt;Unfortunately, I didn&amp;#39;t really do any market research before diving into the Steam release for SIC-1, so I&amp;#39;d been hoping for a small single digit multiple of all the numbers above. Oh well, next time I&amp;#39;ll mentally set the bar lower.&lt;/p&gt;
&lt;h1 id=&quot;marketing&quot;&gt;Marketing&lt;/h1&gt;
&lt;p&gt;As SIC-1&amp;#39;s Steam debut approached, I cobbled together a long list of potential marketing activities. For example, sharing the game on sites that are popular with programmers, esolang enthusiasts, and zachlike players. As &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html#steam-release&quot;&gt;noted in the previous post&lt;/a&gt;, none of my marketing activities were terribly fruitful, but I was at least heartened to eventually see &lt;em&gt;someone else&lt;/em&gt; organically share my game on the unofficial Zachtronics Discord server (someone even streamed it on Twitch!). Regardless, until late December 2022, just relying on Steam was my best marketing activity (and, spoiler alert, not much has changed).&lt;/p&gt;
&lt;h2 id=&quot;december-2022-traffic-spike&quot;&gt;December 2022 traffic spike&lt;/h2&gt;
&lt;p&gt;After the first few disappointing weeks on Steam, I seriously started to consider shelving the entire project. But one day I saw a large spike in traffic coming from (of all places) GitHub. It took a little bit of searching to find out that &lt;a href=&quot;https://github.com/jaredkrinke/sic1&quot;&gt;SIC-1&amp;#39;s GitHub repository&lt;/a&gt; had been shared on Twitter... by someone will millions of followers!&lt;/p&gt;
&lt;p&gt;Specifically, &lt;a href=&quot;https://twitter.com/notch/status/1604998134354137099&quot;&gt;the original creator of Minecraft, Notch, shared my game&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Zachlike subleq &amp;quot;game&amp;quot; ... I&amp;#39;m going to lose a lot of braincells to this one ... ie, highly recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given that Notch had 3.5 million followers, I thought this might be my big break, and I did get quite a few new players at the time, but the total impact was probably only in the (very) low hundreds of new players. Regardless, it was fairly surreal to see a billionaire live-tweeting about playing my game (during the winter holiday season, no less).&lt;/p&gt;
&lt;h2 id=&quot;positive-rating-on-steam&quot;&gt;&amp;quot;Positive&amp;quot; rating on Steam&lt;/h2&gt;
&lt;p&gt;But it turns out the best marketing for SIC-1 was, again, just to let Steam provide some visibility. Once SIC-1 hit 10 reviews, it got a &amp;quot;Positive&amp;quot; rating and a very large spike in traffic (over 5,000 visitors in one day). The spike has been receding, but I&amp;#39;m still seeing over 100 unique visitors to the Steam page per day.&lt;/p&gt;
&lt;h2 id=&quot;marketing-summary&quot;&gt;Marketing summary&lt;/h2&gt;
&lt;p&gt;All things considered, I should probably be content with where SIC-1 ended up, given the small audience and my apparent lack of marketing prowess, but I can&amp;#39;t shake the feeling that the game didn&amp;#39;t attract as many players as I&amp;#39;d hoped.&lt;/p&gt;
&lt;h1 id=&quot;overall&quot;&gt;Overall&lt;/h1&gt;
&lt;p&gt;Obviously, I learned a lot producing and launching a small (but complete) game on Steam, not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How Steam works behind the scenes&lt;/li&gt;
&lt;li&gt;How to make a trailer for a game&lt;/li&gt;
&lt;li&gt;How to create Yamaha DX7 music (without owning any synthesizers or spending any money)&lt;/li&gt;
&lt;li&gt;How to write a narrative for a game&lt;/li&gt;
&lt;li&gt;How to run asynchronous operations with WebView2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of the list above, creating original music was definitely the most enjoyable activity, so it&amp;#39;s good that SIC-1 provided motivation to learn more about that process.&lt;/p&gt;
&lt;p&gt;Releasing a game on Steam was a bucket list item for me, and I&amp;#39;m glad I did it. It remains to be seen if I&amp;#39;ll make any more games in the future.&lt;/p&gt;
&lt;h1 id=&quot;the-future&quot;&gt;The future&lt;/h1&gt;
&lt;p&gt;Speaking of the future, SIC-1 is mostly complete. I&amp;#39;d like to add an interactive tutorial and support for custom puzzles, but given the lower player count I&amp;#39;m not convinced that would be a good use of my (limited) free time.&lt;/p&gt;
&lt;p&gt;Here are the biggest remaining open questions for me&lt;/p&gt;
&lt;h2 id=&quot;should-i-open-source-sic-1&quot;&gt;Should I open-source SIC-1?&lt;/h2&gt;
&lt;p&gt;Currently the game is free and source is available, but it&amp;#39;s not &lt;a href=&quot;https://opensource.org/osd/&quot;&gt;Open Source&lt;/a&gt; because I don&amp;#39;t allow redistribution/resale/modifications. I love open source software, but there are two reasons I&amp;#39;m hesitant to release my game as open source:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t want someone else to turn around and sell my game (that I released for free)&lt;/li&gt;
&lt;li&gt;I&amp;#39;m proud of the music and characters/narrative, and I don&amp;#39;t want other people to be able to profit off of them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An obvious solution would be to release everything except the narrative and music as open source, but I&amp;#39;m not sure that&amp;#39;s worth the effort.&lt;/p&gt;
&lt;h2 id=&quot;should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;Should I port the Steam version of the game to Linux?&lt;/h2&gt;
&lt;p&gt;I feel bad for only supporting Windows for the Steam release. My original reasoning was:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The web version already works on Linux/macOS/whatever&lt;/li&gt;
&lt;li&gt;By using WebView2 (instead of Electron), I could keep the download size reasonable (less than 30 MB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In retrospect, I should have just used Electron from the beginning. Not only would it have been easier to implement, but then I could have easily supported Steam on Linux (and maybe even macOS), allowing those players to sync save data across devices and compare achievement statistics. The only downside is that the download would be roughly 5 times as large (which &lt;em&gt;does&lt;/em&gt; seem excessive for a mostly text-based game).&lt;/p&gt;
&lt;p&gt;But once again, I&amp;#39;m just not sure that the game is popular enough to warrant porting to Linux. It might please a handful of people (and make me feel better), but I should probably focus on more impactful projects.&lt;/p&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all, for now&lt;/h1&gt;
&lt;p&gt;Thus concludes my brain dump. Feel free to send questions or comments to &lt;a href=&quot;mailto:log@schemescape.com&quot;&gt;log@schemescape.com&lt;/a&gt;. If you enjoyed the game, I&amp;#39;d love to hear from you!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html"/>
<updated>2023-03-07T00:00:00.000Z</updated>
<summary type="text">md2blog is fast on my desktop, but slow on my Raspberry Pi. Here are my plans to improve rebuild performance.</summary>
<content type="html">&lt;p&gt;I&amp;#39;ve been happily using &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html&quot;&gt;md2blog&lt;/a&gt; to generate this site for over a year now, but I recently ran into a problem: it&amp;#39;s not as fast as it could be.&lt;/p&gt;
&lt;p&gt;On my desktop computer, this is no big deal because a clean build only takes a couple of seconds and a live rebuild takes less than 2 seconds. But on my &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html&quot;&gt;minimal development environment I&amp;#39;ve been playing with&lt;/a&gt; (which runs on a Raspberry Pi 1, model B), even after some basic optimization, it still takes 2 minutes to build the site from scratch! I haven&amp;#39;t bothered to attempt a &amp;quot;live&amp;quot; rebuild.&lt;/p&gt;
&lt;p&gt;One reason for this is the fact that md2blog always rebuilds the entire site, regardless of whether or not anything changed. This was a design decision I made solely to simplify the implementation, with the understanding that my site was small enough and my computer fast enough that it wouldn&amp;#39;t matter. Now, my computer is slow.&lt;/p&gt;
&lt;h1 id=&quot;solutions-to-explore&quot;&gt;Solutions to explore&lt;/h1&gt;
&lt;p&gt;Here are some ideas I had for improving performance on low-end devices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hugo&lt;/strong&gt;: Give up on JavaScript/Deno/&lt;a href=&quot;https://github.com/jaredkrinke/goldsmith&quot;&gt;Goldsmith&lt;/a&gt; and port everything to &lt;a href=&quot;https://gohugo.io/&quot;&gt;Hugo&lt;/a&gt; (which is implemented in Go and therefore compiled to native code, so probably faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: Give up on JavaScript and rewrite md2blog (and possibly Goldsmith) in Rust (also compiles to native code, but without a garbage collector, so maybe even faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caching&lt;/strong&gt;: Refactor Goldsmith so that it avoids rebuilding items whose source files haven&amp;#39;t changed&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hugo&quot;&gt;Hugo&lt;/h2&gt;
&lt;p&gt;Hugo is a popular static site generator. I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/hugo.html&quot;&gt;tried it out&lt;/a&gt; when I was first creating this site, but I hated the template language and the learning curve for creating new themes was fairly steep. Despite my complaints, I admire Hugo&amp;#39;s portability and speed, so I&amp;#39;m willing to give it another shot, so this option remains on the table.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I looked into Hugo more, and it doesn&amp;#39;t support deriving taxonomies from file system metadata (namely: parent directory), so I&amp;#39;d have to make some compromises (either to my workflow or the site design) if I wanted to switch to Hugo. Still on the table (just less attractive).&lt;/p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;/h2&gt;
&lt;p&gt;I&amp;#39;d like to learn Rust because it&amp;#39;s unique as a &lt;em&gt;safe&lt;/em&gt; systems language, and redesigning/reimplementing Goldsmith+md2blog in Rust would be a great way to learn the language. Using a compiled language would enable parallel builds (although my Raspberry Pi 1 only has a single CPU core), and I suspect that native Markdown/syntax highlighting libraries would speed things up.&lt;/p&gt;
&lt;p&gt;This would be a large project, but educational enough that I&amp;#39;m open to it.&lt;/p&gt;
&lt;h2 id=&quot;caching&quot;&gt;Caching&lt;/h2&gt;
&lt;p&gt;It&amp;#39;s hard to estimate the impact of caching intermediate objects and outputs, but done correctly this would at least reduce the number of files written out from roughly 100, down to just a handful.&lt;/p&gt;
&lt;p&gt;This option also has the attractive quality that it doesn&amp;#39;t require reimplementing everything in a new language or framework, so it&amp;#39;s probably the shortest path to performance improvements without functional regressions.&lt;/p&gt;
&lt;p&gt;For now, I&amp;#39;m planning to investigate caching first since it&amp;#39;s the easiest and safest option.&lt;/p&gt;
&lt;h1 id=&quot;adding-caching-to-goldsmith&quot;&gt;Adding caching to Goldsmith&lt;/h1&gt;
&lt;p&gt;I never got around to documenting Goldsmith (the base upon which md2blog is built), but it&amp;#39;s essentially &amp;quot;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt; for Deno, with very few dependencies&amp;quot;. Unfortunately, Metalsmith&amp;#39;s data model (which Goldsmith copies) doesn&amp;#39;t trivially lend itself to caching.&lt;/p&gt;
&lt;h2 id=&quot;goldsmiths-data-model-vs-caching&quot;&gt;Goldsmith&amp;#39;s data model vs. caching&lt;/h2&gt;
&lt;p&gt;Goldsmith&amp;#39;s data model is essentially one giant mutable map of filenames to metadata and content. A sequence of plugins manipulate this map, in order to transform input files to output files (adding/modifying metadata along the way). At the end of the plugin chain, files are written out to disk.&lt;/p&gt;
&lt;p&gt;The problem with this approach is that output files never specify their dependencies. Looking at it from the other direction, if I modify this post&amp;#39;s Markdown file, the only change to Goldsmith&amp;#39;s initial data model is the content of this Markdown file. The problem is that this one input file could impact numerous output files: the post itself, the Atom feed, any category/keyword index pages (especially if keywords are added or removed), the home page, and, of course, the archive page.&lt;/p&gt;
&lt;h2 id=&quot;caching-requirements&quot;&gt;Caching requirements&lt;/h2&gt;
&lt;p&gt;In order to rebuild the minimal set of files when a change is detected, I need an accurate dependency graph. There are a couple of pitfalls:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The pipeline itself can change&lt;/strong&gt; (in general for Goldsmith, and in configuration for md2blog)&lt;/li&gt;
&lt;li&gt;Plugins always consume the entire data model (plugins internally may filter the set of files, but that&amp;#39;s an implementation detail)&lt;/li&gt;
&lt;li&gt;Plugins can add/delete files at will (there isn&amp;#39;t even a &amp;quot;rename&amp;quot; operation--it just shows up as two independent operations: add and delete)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;brainstorming-dependency-graph-approaches&quot;&gt;Brainstorming dependency graph approaches&lt;/h2&gt;
&lt;p&gt;Obviously, I could just mandate that Goldsmith plugins have to accurately enumerate their dependencies when adding or modifying entires in the collection data model. For md2blog, with its fixed pipeline, this should be feasible, but potentially error-prone.&lt;/p&gt;
&lt;p&gt;Another approach would be to automatically gather dependency information for each output by providing the data model wrapped in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;proxy object&lt;/a&gt;. The trick is scoping the proxy object to a single output, and I don&amp;#39;t see a way to accomplish this without changing the plugin contract. One approach might be to create a new class of plugins that &lt;em&gt;only&lt;/em&gt; transform/rename files individually. &lt;strong&gt;This would also open the door to parallel processing of these &amp;quot;per-file&amp;quot; plugins&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Having the dependency graph computed automatically is preferable, so I&amp;#39;ll try that first.&lt;/p&gt;
&lt;h2 id=&quot;from-dependencies-to-caching&quot;&gt;From dependencies to caching&lt;/h2&gt;
&lt;p&gt;Creating the dependency graph is necessary, but not sufficient. I&amp;#39;ll need to also cache the intermediate results from plugins, along with the timestamps of input files so that I can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check to see which files have changed&lt;/li&gt;
&lt;li&gt;Restart the build pipeline from the deepest point that hasn&amp;#39;t changed&lt;/li&gt;
&lt;li&gt;Add back in unmodified data model entries&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Other than ad-hoc tests, it will probably be a good idea to &lt;strong&gt;run both the new cache-aware pipeline and the old rebuild-the-world approach to ensure there aren&amp;#39;t any differences&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll also, of course, need to &lt;strong&gt;ensure that the additional overhead from caching isn&amp;#39;t so large as to negate any of the benefits&lt;/strong&gt;, at least on my personal site (I&amp;#39;m not the only md2blog use in the entire world, but there are very few, and I suspect most won&amp;#39;t ever find the updated version).&lt;/p&gt;
&lt;h1 id=&quot;stay-tuned&quot;&gt;Stay tuned&lt;/h1&gt;
&lt;p&gt;I have no idea how long this project will take or whether I&amp;#39;ll abandon it, but if I make progress, I&amp;#39;ll be sure to post an update (and link it from here--hopefully the rebuild picks up the change!).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I prototyped &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds-2.html&quot;&gt;incremental builds using GNU Make&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
</feed>
