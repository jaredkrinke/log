<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Mon, 27 Sep 2021 19:10:43 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[A trivial WebAssembly example]]></title><description><![CDATA[<p>In the last post, I provided an <a href="../overview/">overview of WebAssembly</a>. In this post, I&#39;m going to build and run a complete (but trivial) WebAssembly module in C using <a href="https://llvm.org/">LLVM</a> and <a href="https://clang.llvm.org/">Clang</a>.</p>
<p>All of the code is here: <a href="https://github.com/jaredkrinke/webassembly-trivial-example">webassembly-trivial-example</a>.</p>
<h1 id="aside">Aside</h1>
<p>It looks like someone else was frustrated with Emscripten in the past, so they wrote a post about <a href="http://schellcode.github.io/webassembly-without-emscripten">WebAssembly without Emscripten</a>. Their guide was helpful, but I&#39;m not sure if it&#39;s up to date. I also found their Makefiles to be excessively complex.</p>
<h1 id="setup">Setup</h1>
<p>First, download and install LLVM (I used <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">LLVM 12.0.1</a>) from the LLVM GitHub releases page (note: 180 MB download that expands to <em>1.8 GB</em> installed). The programs I&#39;m actually planning to use are <code>clang</code> and <code>wasm-ld</code>.</p>
<p>I also wanted to inspect the output WebAssembly, so I needed the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>, which was a much more reasonable ~2 MB download (note: the Windows version is a gzipped tarball instead of a zip file). I&#39;m going to use <code>wasm2wat</code> for disassembly.</p>
<h2 id="some-notes-on-c">Some notes on C</h2>
<p>C compilation is usually done as follows:</p>
<ol>
<li>Run the preprocessor (<code>cpp</code>) to expand macros and includes (often on many source files)</li>
<li>Compile the preprocessed code into object files</li>
<li>Link everything into a final binary</li>
</ol>
<p>A decent overview of the most common command line arguments for a <em>different</em> compiler is <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/">here</a>. Many of the options are identical for most C compilers.</p>
<h1 id="implementing-a-trivial-function">Implementing a trivial function</h1>
<p>I&#39;m going to start with a very simple example (just to reduce the number of things that could go wrong).</p>
<h2 id="source-code">Source code</h2>
<p>File name: &quot;add.c&quot;:</p>
<pre><code>int add(int a, int b) {
    return a + b;
}</code></pre><h2 id="compiling-the-code">Compiling the code</h2>
<p>First, I&#39;m just going to compile (but not link) the code, to see what happens.</p>
<pre><code>clang -target wasm32 -Os -c add.c</code></pre><ul>
<li><code>-target wasm32</code> tells Clang to tell LLVM to produce 32-bit WebAssembly output (note: as of today, <a href="https://github.com/WebAssembly/proposals">64-bit memory support is in progress</a>)</li>
<li><code>-Os</code> tells Clang to optimize for size (I did this in hopes of getting simpler, more readable code)</li>
<li><code>-c</code> tells Clang to compile, but not link</li>
<li><code>add.c</code> is the source file</li>
</ul>
<p>Since I&#39;m compiling and not linking, this command generates an object file named &quot;add.o&quot;.</p>
<h2 id="disassembling-the-object-file">Disassembling the object file</h2>
<p>Run the disassembler:</p>
<pre><code>wasm2wat add.o</code></pre><p>And it produces the following surprisingly readable output:</p>
<pre><code>(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import &quot;env&quot; &quot;__linear_memory&quot; (memory (;0;) 0))
  (func $add (type 0) (param i32 i32) (result i32)
    local.get 1
    local.get 0
    i32.add))</code></pre><p>MDN has a great <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">explanation of the Web Assembly text format</a> (&quot;.wat&quot; files). The syntax is based on <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> (similar to <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>). Note that inline comments are delimited by semicolons (e.g. <code>; comment goes here ;</code>), as noted in <a href="https://github.com/WebAssembly/spec/blob/master/interpreter/README.md#s-expression-syntax">this more detailed look at Web Assembly text format syntax.</a>.</p>
<p>Breaking down the first two lines:</p>
<ul>
<li><code>module</code> is the root and encloses the entire module</li>
<li><code>type</code> denotes a type that can be later referenced<ul>
<li><code>(;0;)</code> is an empty list (<code>;0;</code> is just a comment) for the name of the type</li>
<li><code>func</code> denotes a function type<ul>
<li><code>param</code> denotes a list of function arguments</li>
<li><code>i32</code> is a <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> 32-bit integer<ul>
<li>Note: there is no corresponding &quot;unsigned&quot; type--instructions themselves indicate the expected sign of operands, as needed (e.g. for division)</li>
</ul>
</li>
<li><code>result</code> is a list of result values (<a href="https://github.com/WebAssembly/multi-value">support for multiple result values</a> was added in April of 2020)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So far, we have a module and an unnamed type (which can be referenced by index 0) for a function taking two 32-bit integers and returning one 32-bit integer. Moving on:</p>
<ul>
<li><code>import</code> is used to indicate data that is passed into the module from the host<ul>
<li><code>&quot;env&quot; &quot;__linear_memory&quot;</code> indicates the import is from the &quot;env&quot; module and the item being imported is &quot;__linear_memory&quot; (these are arbitrary strings that must match the instantiation code in the host)</li>
<li><code>(memory (;0;) 0)</code> specifies an unnamed memory, which must have an initial size of at least zero 64 KB pages<ul>
<li>I believe this could have been omitted from the output in this trivial example</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The host code would need to pass in a (zero-sized) memory buffer named <code>env.__linear_memory</code>. On to the actual code:</p>
<ul>
<li><code>func</code> defines a function<ul>
<li><code>$add</code> is the name of the function (names are prefixed with <code>$</code>)</li>
<li><code>(type 0)</code> refers to the type zero, defined previously: (i32, i32) =&gt; (i32)</li>
<li>The function type/signature/prototype is then specified -- I&#39;m not sure why the type needs to be duplicated here</li>
<li>The function body follows as a series of instructions (here&#39;s the <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">full list of WebAssembly instructions</a>)</li>
</ul>
</li>
</ul>
<p>Looking at the function body, note that local values are referenced by a zero-based index that starts with the function arguments and then continues on to any local variables:</p>
<ul>
<li><code>local.get 1</code> gets the second argument and pushes it onto the stack</li>
<li><code>local.get 0</code> gets the first argument and pushes it onto the stack</li>
<li><code>i32.add</code> pops the two arguments off and pushes their sum onto the stack<ul>
<li>The return value is just the last argument left on the stack, so no additional instructions are required</li>
</ul>
</li>
</ul>
<p>It looks like the C code compiled correctly and the output WAT seems reasonable. So far, so good.</p>
<h2 id="linking">Linking</h2>
<p>Note that my original Clang command specified <code>-c</code>, so it only compiled the code and never ran the linker. Let&#39;s go all the way this time:</p>
<pre><code>clang -target wasm32 -Os -nostdlib -Wl,--no-entry add.c -o add.wasm</code></pre><p>I removed <code>-c</code> and added some new arguments:</p>
<ul>
<li><code>-nostdlib</code> indicates that the C standard library should not be used (it&#39;s not needed in this case, and I don&#39;t have it available anyway)</li>
<li><code>-Wl,--no-entry</code> tells the linker that there is no entry point (i.e. no <code>main()</code> or <code>_start()</code> function)</li>
<li><code>-o add.wasm</code> tells the linker to write the output to &quot;add.wasm&quot; (instead of the default &quot;a.out&quot; file)</li>
</ul>
<p>Disassembling &quot;add.wasm&quot; yields the following:</p>
<pre><code>(module
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (export &quot;memory&quot; (memory 0)))</code></pre><p>My code disappeared! Of course, this isn&#39;t surprising because my code has no entry point and doesn&#39;t export anything.</p>
<h3 id="memory-and-a-stack">Memory and a stack</h3>
<p>Interestingly, this most recent disassembly shows some other changes:</p>
<ul>
<li>A block of linear memory that starts at 2 pages long is declared</li>
<li>There is a stack pointer that is initialized to 1 KB into the second page of memory</li>
<li>This memory is exported from the module</li>
<li>The seemingly unnecessary memory <em>import</em> (<code>env.__linear_memory</code>) is no longer present</li>
</ul>
<p>I have some questions about this arrangement:</p>
<ul>
<li>Why is the memory exported? Can the host code read or even modify the stack? (Spoiler: yes)</li>
<li>Does this stack solely exist to support C semantics (e.g. taking the address of a variable on the stack)? (Probably)<ul>
<li>Note that <a href="https://github.com/WebAssembly/design/blob/main/Nondeterminism.md">this WebAssembly note</a> indicates the VM&#39;s stack can&#39;t be accessed by a program (&quot;Note that this stack isn&#39;t located in the program-accessible linear memory&quot;)</li>
</ul>
</li>
</ul>
<h3 id="aside-a-webassembly-critique">Aside: a WebAssembly critique</h3>
<p>As an aside: while trying to find answers to some of my questions, I ran across an <a href="http://troubles.md/wasm-is-not-a-stack-machine/">incredibly insightful series of posts</a> that retrospectively critiques some of WebAssembly&#39;s design decisions.</p>
<h3 id="exports">Exports</h3>
<p>Back to my trivial experiment.</p>
<p>How do I tell Clang/LLVM that I want to export a function? Consulting the <a href="https://lld.llvm.org/WebAssembly.html">linker documentation</a>, it looks like I can export everything (not my preferred approach) or specify exports either on the command line or with attributes in the code. In code, the two options appear to be:</p>
<ul>
<li>Mark exports with <code>__attribute__((export_name(&quot;nameOfExport&quot;)))</code></li>
<li>Specify <code>-Wl,--export-dynamic</code> on the Clang command line and mark exports with <code>__attribute__ ((visibility (&quot;default&quot;)))</code></li>
</ul>
<p>I kind of wish there was an &quot;always export this symbol by name&quot; option that didn&#39;t require duplicating the name. C preprocessor to the rescue!</p>
<pre><code>#define WASM_EXPORT_AS(name) __attribute__((export_name(name)))
#define WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol

int WASM_EXPORT(add)(int a, int b) {
    return a + b;
}</code></pre><p>Output:</p>
<pre><code>(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func $add (type 0) (param i32 i32) (result i32)
    local.get 1
    local.get 0
    i32.add)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (export &quot;memory&quot; (memory 0))
  (export &quot;add&quot; (func $add)))</code></pre><p>This looks like what I want. I&#39;ve got my function and it&#39;s being exported (along with a memory region that I&#39;m not actually using in my code).</p>
<h2 id="using-the-module">Using the module</h2>
<p>Now that I&#39;ve got my finished module (<code>add.wasm</code>), I need to host it somewhere.</p>
<h3 id="using-the-module-in-node">Using the module in Node</h3>
<p>Here&#39;s an example of loading the module and calling <code>add</code> in Node:</p>
<pre><code>const fs = require(&#39;fs&#39;);
(async () =&gt; {
    const module = await WebAssembly.instantiate(await fs.promises.readFile(&quot;./add.wasm&quot;));
    const add = module.instance.exports.add;
    console.log(add(2, 2));
})();</code></pre><ul>
<li><code>await fs.promises.readFile(&quot;./add.wasm&quot;)</code> initiates a file read and resumes upon completion</li>
<li><code>const module = await WebAssembly.instantiate(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>add(2, 2)</code> returns 4, as expected</li>
</ul>
<h3 id="using-the-module-in-a-web-page">Using the module in a web page</h3>
<p>Here&#39;s a web page for my trivial example:</p>
<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;The value of 2 + 2 is &lt;span id=&quot;result&quot;&gt;?&lt;/span&gt;&lt;/p&gt;

        &lt;script&gt;
            (async () =&gt; {
                const module = await WebAssembly.instantiateStreaming(fetch(&quot;./add.wasm&quot;));
                const add = module.instance.exports.add;
                document.getElementById(&quot;result&quot;).innerText = add(2, 2);
            })();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Note that using <code>fetch</code> isn&#39;t supported from the file system, so I used <a href="https://github.com/http-party/http-server">a trivial HTTP server</a> for local testing.</p>
<ul>
<li><code>fetch(&quot;./add.wasm&quot;)</code> initiates a request to load the module by relative path</li>
<li><code>const module = await WebAssembly.instantiateStreaming(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>document.getElementById(&quot;result&quot;).innerText = add(2, 2);</code> updates the &quot;result&quot; span with the result of the call to <code>add</code></li>
</ul>
<p>To my surprise, everything worked on the first try.</p>
<p>I was also able to confirm that the module&#39;s memory was exported (<code>module.instance.exports.memory</code>) and could be read from within my browser&#39;s dev tools window. I&#39;m still not clear on why LLVM decided to export the memory by default.</p>
<h1 id="thats-it">That&#39;s it!</h1>
<p>The end result of all this was actually pretty simple. Here are some links for reference:</p>
<ul>
<li><a href="https://github.com/jaredkrinke/webassembly-trivial-example">GitHub repository with all the code and build commands</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-trivial-example/">Live demo of the module hosted in a web page</a> (using <code>WebAssembly.instantiate()</code> instead of <code>instantiateStreaming()</code> for compatibility with older browsers)</li>
</ul>
<p>Remembering how to use a C compiler on the command line, and deciphering LLVM&#39;s export semantics took a bit more time than I would have liked, but I learned a lot about WebAssembly in the process.</p>
<p>Next up, I&#39;ll see if I can get the C standard library working.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/trivial-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/trivial-example</guid><pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly overview]]></title><description><![CDATA[<h1 id="background">Background</h1>
<h1 id="emscripten">Emscripten</h1>
<p>I first heard of <a href="https://emscripten.org/">Emscripten</a> in the mid-2010s. At the time, you could compile C code to an optimizability-focused subset of JavaScript known as <a href="http://asmjs.org/">asm.js</a>. This meant that, given the source code to a native app and appropriate implementations of system APIs, you could run <em>formerly</em> native-only programs in the browser--convenient, if you don&#39;t want to install anything.</p>
<h2 id="enter-webassembly">Enter WebAssembly</h2>
<p>In the intervening years, <a href="https://webassembly.org/">WebAssembly</a> appeared. WebAssembly is a binary format for programs that run on a portable virtual machine. This VM can be hosted in your browser, but non-browser runtimes have also sprung up (e.g. <a href="https://wasmtime.dev/">wasmtime</a>).</p>
<p>WebAssembly, to me, seems like the <a href="https://en.wikipedia.org/wiki/Holy_Grail">Holy Grail</a> of compilation targets. I wouldn&#39;t be surprised if, thanks to browser support, WebAssembly is <em>the</em> most broadly supported binary program format. What other binary format works on my desktop, phone, <a href="https://www.raspberrypi.org/">Raspberry Pi</a>?</p>
<p>Note that WebAssembly runtimes seem to be standardizing on an in-development system interface named <a href="https://wasi.dev/">WASI</a>. You probably can&#39;t write a GUI app solely with WebAssembly and WASI today, but I&#39;m sure that day is coming (in the distant future).</p>
<h2 id="one-note-on-emscripten">One note on Emscripten</h2>
<p>If you just want to port native programs to the browser, Emscripten is an environment for doing that. It even converts <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> to <a href="https://www.khronos.org/webgl/">WebGL</a> and handles the <a href="https://www.libsdl.org/">SDL</a> API. Unfortunately, just <em>installing</em> Emscripten requires Python. For now, I refuse to setup bloated software just to <em>install</em> the software I actually want, so I&#39;m skipping Emscripten.</p>
<h1 id="webassembly-concepts">WebAssembly concepts</h1>
<p>Mozilla&#39;s documentation has a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts">great overview of WebAssembly concepts</a>. There&#39;s also an <a href="https://hacks.mozilla.org/2017/07/creating-a-webassembly-module-instance-with-javascript/">approachable series of WebAssembly articles</a> on Mozilla Hacks. I&#39;ll try to summarize:</p>
<ul>
<li><strong>Module</strong>: a compiled WebAssembly binary (declaring imports and exports)</li>
<li><strong>Instance</strong>: a module along with its state (memory, table, imports)</li>
<li><strong>Memory</strong>: a read/write, resizable buffer provided to the instance</li>
<li><strong>Table</strong>: array of references that aren&#39;t directly stored in WebAssembly-accessible memory (for security reasons)<ul>
<li>The example I&#39;ve seen for this is to be able to pass function pointers into C/C++ code</li>
</ul>
</li>
</ul>
<h1 id="webassembly-formats">WebAssembly formats</h1>
<p>WebAssembly defines two formats:</p>
<ul>
<li><strong>.wasm</strong>: Binary format</li>
<li><strong>.wat</strong>: Text format (assembly)</li>
</ul>
<p>The <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> contains tools for converting between these formats. Specifically, <code>wat2wasm</code> is analogous to a very simple assembler, and <code>wasm2wat</code> to a disassembler.</p>
<h1 id="webassembly-browser-interface">WebAssembly browser interface</h1>
<p>Within the browser, WebAssembly <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running">currently needs to be loaded using JavaScript</a> (it sounds like there are plans to support loading using script tags and import statements in the future). Sadly, as of today, the recommended way to load WebAssembly (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming()</a>) is <a href="https://caniuse.com/?search=instantiateStreaming">only supported by 75% of browsers</a>. The more broadly supported <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">WebAssembly.instantiate()</a> seems cumbersome. I&#39;m hopeful that WebAssembly&#39;s ergonomics will improve, but I suppose this is just the price you pay when using new technology.</p>
<h1 id="next-steps">Next steps</h1>
<p>Armed with the above information, I think I&#39;m ready to dive in and test out WebAssembly with a trivial example. I&#39;ll report my findings in a subsequent update.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/overview</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/overview</guid><pubDate>Sat, 25 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 2)]]></title><description><![CDATA[<p>In the <a href="../diagrams/">last post</a>, I looked at options for generating diagrams from text descriptions at build time for my static site. Here&#39;s my (failed) attempt at integrating <a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a> into my site.</p>
<h1 id="mermaid-is-browser-based">Mermaid is browser-based</h1>
<p>Mermaid is built on top of <a href="https://d3js.org/">D3.js</a>, which is designed to be used in the browser. It exposes a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API reminiscent of <a href="https://jquery.com/">jQuery</a>. It directly manipulates a DOM, which means you need a browser.</p>
<p>This is a problem for my scenario where I&#39;m building my site outside of any browser in Node.</p>
<p>Mermaid provides a command line interface where you can pass in the text describing a diagram and get SVG back out, but rather than doing something sensible, it uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> to spin up a headless Chromium browser DOM (enjoy that 200+ MB download!) that D3.js manipulates, and then gets everything back out. I guess this is fine for generating, say, a PNG image file, but for SVG it seems excessively wasteful. You shouldn&#39;t need a DOM or browser just to generate XML!</p>
<h1 id="sanity-check">Sanity check</h1>
<p>Just to make sure I&#39;m not missing something obvious, let&#39;s try building a Mermaid diagram in Node without doing anything special.</p>
<h2 id="module-woes">Module woes...</h2>
<p>The first problem I hit is that Mermaid 8.13.0 with D3.js 7.0.3 won&#39;t load in either a CommonJS or ES Module environment in Node 14.17.0. If, in CommonJS mode, I try to use <code>require(&quot;mermaid&quot;)</code>, Node rightly points out that D3.js is an ES Module. If, in an ES Module, I try to use <code>import &quot;mermaid&quot;;</code>, then Mermaid tries to use <code>require()</code> on D3.js, which obviously doesn&#39;t work. This seems like a bug in Webpack&#39;s &quot;universal module&quot; pattern.</p>
<h2 id="jsdom-to-the-rescue">jsdom to the rescue?</h2>
<p><a href="https://github.com/jsdom/jsdom">jsdom</a> provides a fake DOM implementation for use in Node. Sounds promising!</p>
<p>Unfortunately, Mermaid&#39;s dependencies require some SVG functionality that jsdom doesn&#39;t implement, e.g. <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox">SVGGraphicsElement.getBBox()</a>. Alright, now it&#39;s making more sense why Mermaid has this dependency on a browser--it&#39;s using the browser&#39;s SVG API to measure text, compute transformations, and so on. I&#39;m still not thrilled with this design, but I can see how one might need to measure text when generating diagrams (althoug embedding a full Chromium engine seems like overkill).</p>
<p>I did a bit of searching to see if anyone has implemented the SVG API for use in Node, but I couldn&#39;t find anything that looked promising. There was a library for the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">Canvas</a> API that can be used in Node, which probably solved many similar problems (related to CSS and measuring fonts), but implementing SVG just so I can generate diagrams without downloading Chrome is beyond the amount of effort I&#39;m willing to put into this endeavor.</p>
<h1 id="taking-a-step-back">Taking a step back</h1>
<p>It&#39;s looking like using Mermaid on the back end is probably going to require either a significant amount of effort or a willingness to settle for using Chromium behind the scenes.</p>
<p>Rather than start investigating the performance characteristics of mermaid-cli, I think I&#39;m going to take a step back and evaluate which of Mermaid, Graphviz, and <a href="https://github.com/microsoft/automatic-graph-layout">MSAGL</a> (which I just found) has syntax I find most comfortable (while still supporting the features I&#39;m interested in). Honestly, this should have been the first step, but I was hoping that one option would be clearly easier to integrate, at which point I&#39;d probably just make do with whatever syntax and features were available.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</guid><pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 1)]]></title><description><![CDATA[<h1 id="background">Background</h1>
<p>As described in a <a href="../overview/">previous post</a>, I&#39;d like to have a static site that requires no JavaScript whatsoever to view the site in full fidelity. I&#39;d also like to be able to embed diagrams into my posts, ideally by inserting a textual description of the diagram.</p>
<p>Given how huge the NPM ecosystem is, I thought this would be trivial to setup. I might have been wrong.</p>
<h1 id="diagramming-software">Diagramming software</h1>
<p>In the past, I&#39;ve used <a href="https://graphviz.org/">Graphviz</a> for generating diagrams, with some success. That was almost 15 years ago, so I assumed today there&#39;d be something newer and more Node-friendly that I could easily integrate into my workflow.</p>
<p>After scouring the web for an hour or so, I found a couple of patterns:</p>
<ul>
<li>There were several libraries that aggregate diagramming libraries under a unified API<ul>
<li>But the component libraries were written in a wide variety of languages (Python, C, etc.), so deployment would be a huge hassle (<a href="https://kroki.io/">Kroki</a> even went so far as to recommend <em>against</em> trying to deploy your own instance)</li>
</ul>
</li>
<li>Many of the libraries were written in Java (a language I&#39;d like to avoid, if possible)</li>
<li>Most of the libraries didn&#39;t have a convenient text-based input format</li>
<li>Most of the libraries were designed to run <em>on the client</em></li>
</ul>
<p>I definitely don&#39;t want to have to install multiple programming language environments, and it seems silly to have each client re-render the same diagram on every view. I also don&#39;t want to depend on a service that is currently free, but could potentially disappear overnight.</p>
<p>My research led me to two candidate tools:</p>
<ul>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a>: Markdown-inspired JavaScript-based tool</li>
<li><a href="https://graphviz.org/">Graphviz</a>: Super old (originally created by AT&amp;T!), C-based diagramming tool</li>
</ul>
<p>Neither of these is perfect for my environment. Will they work? Probably, but how inconvenient will it be?</p>
<h2 id="mermaid">Mermaid</h2>
<p>Mermaid is written in JavaScript, so I should just be able to install it via NPM, call an API, and be done, right? Actually, no.</p>
<p>Remember, I want to insert the source code of a diagram directly into my Markdown files, but then have that rendered to SVG at build time. <a href="https://mermaid-js.github.io/mermaid/#/n00b-gettingStarted">Mermaid&#39;s deployment model</a> is to have the client parse the source code from within the page, render an image, and insert it into the DOM.</p>
<p>Ok, so I can just run that same code in Node at build time, right? Then I can skip all the client-side JavaScript? Not according to <a href="https://github.com/mermaid-js/mermaid/issues/146">an issue in Mermaid&#39;s issue tracker</a>!</p>
<p>From reading that thread, it sounds like Mermaid interacts directly with the web page&#39;s DOM when rendering. Someone created a command line tool (<a href="https://github.com/mermaidjs/mermaid.cli">mermaid.cli</a>) that apparently uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a>&#39;s headless Chromium environment to supply a functioning DOM. Apparently, this is the normal workaround for using D3.js-based graphics on the back end. I find this implementation slightly appalling.</p>
<p>I&#39;m a little bit worried about the performance of building my site when each diagram has to spin up a new process which hosts a headless Chromium browser, just to spit out SVG. I suspect it will <em>work</em>, but it seems wasteful.</p>
<p>Let&#39;s see if I can find a better option.</p>
<h2 id="graphviz">Graphviz</h2>
<p>Graphviz is old and originated at AT&amp;T, so of course it is written in C. I love C, but compiling anything with dependencies beyond the standard library is a chore. Part of what attracted me to the Node ecosystem was that most everything is written in JavaScript and, since JavaScript compilers are so fast these days, performance is surprisingly adequate most of the time.</p>
<p>Anyway, so my first thought for integration is to just make sure Graphviz is installed and then spin up a process to render diagrams. I don&#39;t want to have to start a new process each time, but it&#39;s native code, so it&#39;s probably fast enough for my needs. Taking a dependency on a binary is highly unusual in Node land, however, so I&#39;d like to find some way to avoid doing that.</p>
<p>But wait, someone already solved this problem! <a href="https://github.com/JosephusPaye/node-graphviz">node-graphviz</a> is a theoretically Node-compatible version of Graphviz. According to the package, they compiled Graphviz to a <a href="https://webassembly.org/">Web Assembly</a> module, which can be hosted and run within Node.js. No C compiler needed (for users of the library, that is)!</p>
<p>Embedding Graphviz directly seems like a very promising solution, but I haven&#39;t vetted the library to ensure it works as advertised. The code certainly is not what I was expecting to see (it&#39;s enormous!), so I&#39;m a bit skeptical.</p>
<h1 id="mermaidcli-or-node-graphviz">mermaid.cli or node-graphviz?</h1>
<p>Unfortunately, neither of the two most promising solutions appears obviously better than the other.</p>
<p>Mermaid seems nice because it appears to be broadly used and, by virtue of being newer and web-focused, likely has better support for integrating into web pages (and supporting dark mode, etc.). But I&#39;m having a difficult time getting over the idea of it requiring direct access to a DOM. That just doesn&#39;t seem like a good fit for my &quot;local build&quot; scenario. I&#39;m afraid that, even if I use the command line tool or cook up some way to avoiding handing Mermaid a DOM, it will be fragile.</p>
<p>Graphviz doesn&#39;t seem to support as many diagram types, and I&#39;m a little bit worried to take on a Web Assembly dependency, but on the other hand I&#39;ve been meaning to learn more about Web Assembly anyway. This project might be a good way to learn what goes into integrating a Web Assembly module into Node.</p>
<h1 id="next-steps">Next steps</h1>
<p>Hopefully I don&#39;t regret this decision, but I think I&#39;m going to first try integrating Mermaid. If I hit any snags or if performance is abysmal, I&#39;ll see if node-graphviz is actually what I&#39;m looking for.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams</guid><pubDate>Thu, 23 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Finding the cheapest hosting for my hobby projects]]></title><description><![CDATA[<p>I like playing around with software, so I frequently have hobby projects in development or &quot;production&quot; (scare quotes because they&#39;re hobbies after all). Since I don&#39;t like wasting money, I&#39;m always on the lookout for cheap project hosting.</p>
<p>Here&#39;s how I went from cheap hosting to free hosting.</p>
<h1 id="background">Background</h1>
<p>Just for fun, I made a couple of computer games (best played on a desktop/laptop):</p>
<ul>
<li><a href="https://jaredkrinke.itch.io/sic-1">SIC-1</a>: A single-instruction (<a href="https://esolangs.org/wiki/Subleq">subleq</a>) programming game, with a global leader board</li>
<li><a href="https://jaredkrinke.itch.io/fbgp8">Falling Block Game</a>: Block-stacking game for <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a> with a global high scores list</li>
</ul>
<p>Both of these require services with a small amount of storage. Since there are no ads or monetization, I&#39;d like to run the services as cheaply as possible.</p>
<h1 id="first-attempt-120month">First attempt: $1.20/month</h1>
<p>I inherited a first generation <a href="https://www.raspberrypi.org/">Raspberry Pi</a> and already had a $10/year domain, so why not just host my site locally?</p>
<p>Because I was curious about Node, I decided to use the following very simple tech stack:</p>
<ul>
<li>Software<ul>
<li><a href="https://nodejs.org/en/">Node</a> JavaScript environment</li>
<li><a href="http://expressjs.com/">Express</a> web server framework</li>
<li><a href="https://sqlite.org/index.html">SQLite</a> (via <a href="https://www.npmjs.com/package/sqlite3">sqlite3</a>) in-process, single file-based database</li>
<li><a href="https://github.com/zapty/forever-service">forever-service</a> service monitoring</li>
<li><a href="https://letsencrypt.org/">Let&#39;s Encrypt</a> certificate service</li>
</ul>
</li>
<li>Hardware/connectivity<ul>
<li>Raspberry Pi (first generation), running <a href="https://www.raspbian.org/">Raspbian</a></li>
<li>My home Internet connection and router, with appropriate holes in the firewall</li>
<li>$10/year .com domain name</li>
</ul>
</li>
</ul>
<p>There was very little traffic, so the Raspberry Pi could service requests fine and my (cheapest tier) cable Internet was sufficient.</p>
<h2 id="cost">Cost</h2>
<p>The Raspberry Pi drew roughly 3 watts, so the electricity plus domain meant I was hosting a service for roughly $1.20 per month. Very affordable! Additionally, as long as I didn&#39;t have a lot of traffic, I could run multiple services without increasing the cost.</p>
<h2 id="concerns">Concerns</h2>
<p>I was a bit wary of poking a hole in my firewall and, within a few days, I decided that my concern was justified.</p>
<p>The log for my web server was almost immediately flooded by TCP scanning requests from <a href="https://github.com/robertdavidgraham/masscan">masscan</a>. I also saw 404 errors to common vulnerable paths (namely phpMyAdmin- and WordPress-related paths).</p>
<p>I know there are a lot of people who enjoy having their own &quot;<a href="https://haydenjames.io/home-lab-beginners-guide-hardware/">home lab</a>&quot;, and I&#39;m sure many of these people keep up on the latest security recommendations, but I was more interested in hosting a service than attracting unwanted attention to my home network&#39;s external IP address.</p>
<p>I would strongly advise against hosting any site this way, especially since it turns out to not even be the cheapest option!</p>
<h1 id="second-attempt-433month">Second attempt: $4.33/month</h1>
<p>Wait, my hosting cost went up!? Yes, and it was money well spent.</p>
<p>After getting slightly alarmed at all of the nefarious traffic flowing through my router, I was happy to pay for a virtual private server. This way it&#39;s at least not my own personal network that&#39;s at risk when something goes wrong.</p>
<p>I selected <a href="https://www.vultr.com/">Vultr</a> as the host because they <a href="https://www.vultr.com/products/cloud-compute/#pricing">offered a decent server for $2.50/month</a>... except that server is <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> only, and it turns out that much of the Internet is stuck in the address-constrained dark age of IPv4. So I had to pay a $1/month premium for an IPv4 address.</p>
<p>The tech stack was the same except for the host. Both the VPS&#39;s Internet connection and CPU were light years beyond what I had with my Raspberry Pi on &quot;cheap&quot; cable Internet.</p>
<h2 id="cost-1">Cost</h2>
<p>Adding in the domain name, my total cost was $4.33/month. A little more than I&#39;d like to spend on silly hobby projects, but this setup came with the peace of mind of not broadcasting my home IP address everywhere. Again, I could add more services to my server at no additional cost to me.</p>
<h2 id="concerns-1">Concerns</h2>
<p>Other than costing me roughly $50/year, this setup worked great. But it wasn&#39;t as robust as I&#39;d like:</p>
<ul>
<li>The database was a single file sitting on the server&#39;s drive, with no backup, so I could theoretically lose it due to hardware failure</li>
<li>Configuring the server was a manual process, so if there was a crash, I&#39;d have to spend time setting a new server up</li>
</ul>
<p>At the time, I wasn&#39;t aware, but there are solutions to both of these problems:</p>
<ul>
<li>Use <a href="https://litestream.io/">Litestream</a> to continuously backup the SQLite database to cloud storage</li>
<li>Use <a href="https://www.docker.com/">Docker</a> to package everything up, enabling rapid recreation of the server</li>
</ul>
<p>There are actually many other solutions, but these are two simple approaches I plan on testing out in the future.</p>
<h1 id="third-attempt-free">Third attempt: FREE!</h1>
<p>While chatting with a friend who does web development for a living, he told me that I could probably host my site for free. That magic phrase led to several follow-up questions from me, and a lot more information from him.</p>
<p>It turns out that many cloud providers have free tiers to try and hook you into their ecosystems, in hopes that you&#39;ll eventually become a paying customer. I&#39;m pretty sure all the major cloud providers have free tiers, and some of them are quite generous. My uninformed opinion is that it seems like the less popular the platform, the more generous the free tier.</p>
<p>The annoying part of all of this is that the best free offers vary substantially, so you&#39;ll likely end up having to use multiple different providers. In my case, the tech stack looks like this:</p>
<ul>
<li>Node JavaScript environment</li>
<li><a href="https://koajs.com/">Koa</a> web framework</li>
<li><a href="https://cloud.google.com/firestore/">Firestore</a> document database</li>
<li><a href="https://www.netlify.com/products/functions/">Netlify Functions</a> &quot;<a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless</a>&quot; end point<ul>
<li>Hosted on the (free) &quot;netlify.app&quot; domain</li>
</ul>
</li>
</ul>
<p>Since everything is in the cloud, I&#39;m also less concerned about hardware failure. I haven&#39;t thoroughly investigated whether I should backup my Firestore data or if their architecture seems robust enough for my needs.</p>
<h2 id="cost-2">Cost</h2>
<p>Zero cost, since I didn&#39;t need to use a custom domain. I didn&#39;t even have to provide a credit card.</p>
<h2 id="concerns-2">Concerns</h2>
<p>This setup is free, which is great, but when I last checked, both of the free offerings I&#39;m using were actually fairly expensive if you end up with enough traffic to need to start paying. You&#39;re also locked into their systems unless you want to start rewriting code.</p>
<p>I also found that Firestore wasn&#39;t a great fit for my needs, since it&#39;s a &quot;<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>&quot; document database that basically requires me to build and maintain my own aggregations. But I&#39;m not paying anything, so I shouldn&#39;t complain.</p>
<h1 id="what-about-the-future">What about the future?</h1>
<p>I succeeded in finding free hosting for my hobby projects. Great! But I&#39;m not perfectly happy being locked into specific vendors and libraries.</p>
<p>Cloud services are great, but I&#39;d really like something more portable, in case I ever create a project that ends up getting a significant amount of traffic. There may be better approaches, but I think I&#39;d like to use containers hosted on a VPS (with backup to commodity cloud storage), just for portability reasons.</p>
<p>I have heard that Oracle&#39;s cloud has a <a href="https://www.oracle.com/cloud/free/#always-free">free tier that even includes your own virtual private servers</a>, so I may look into that eventually. Planning to use Oracle is something I never thought I&#39;d be doing as a hobbyist, but these are interesting times.</p>
<p>The future might look like this:</p>
<ul>
<li>Node environment</li>
<li>Koa web framework</li>
<li>SQLite database<ul>
<li>Backed up to commodity store (e.g. <a href="https://www.backblaze.com/">Backblaze</a>) via Litestream</li>
</ul>
</li>
<li>Forever-service monitoring</li>
<li>Let&#39;s encrypt certificate</li>
<li>All in a Docker container</li>
<li>Hosed on Oracle&#39;s free compute VM</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/services/cheap-hosting</link><guid isPermaLink="true">https://log.schemescape.com/posts/services/cheap-hosting</guid><pubDate>Wed, 22 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>