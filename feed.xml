<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2022-02-21T22:16:17.067Z</updated>

<entry>
<title>First impressions of Python</title>
<id>https://log.schemescape.com/posts/programming-languages/python.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python.html"/>
<updated>2022-02-21T00:00:00.000Z</updated>
<summary type="text">Next on my list of programming languages to investigate is Python.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;a previous article&lt;/a&gt;, I enumerated a bunch of popular programming languages and tried to quickly determine which ones seemed like they&amp;#39;d still be useful in another decade.&lt;/p&gt;
&lt;p&gt;Now, I&amp;#39;m drilling more deeply into Python.&lt;/p&gt;
&lt;h1 id=&quot;setting-up-a-python-development-environment&quot;&gt;Setting up a Python development environment&lt;/h1&gt;
&lt;p&gt;Ah, my old nemesis: Python. I&amp;#39;ve never had a good experience setting up a Python environment. Additionally, the Python 2 to 3 migration (which included unnecessary things like &lt;a href=&quot;https://www.python.org/dev/peps/pep-0238/&quot;&gt;changing the semantics of the division operator&lt;/a&gt;) had so many breaking changes that people are &lt;em&gt;still&lt;/em&gt; using Python 2 (even though it is no longer supported).&lt;/p&gt;
&lt;p&gt;Yet Python is consistently one of the most popular programming languages. What am I missing?&lt;/p&gt;
&lt;p&gt;While setting up Python, I noticed that typing &amp;quot;python&amp;quot; into my Windows command prompt launches the Microsoft Store app (compliments of &lt;code&gt;%LocalAppData%\Microsoft\WindowsApps\python.exe&lt;/code&gt;). I&amp;#39;ll give the installer a try since it&amp;#39;s a surprisingly reasonable ~100 MB download. Apparently, Microsoft decided to &lt;a href=&quot;https://devblogs.microsoft.com/python/python-in-the-windows-10-may-2019-update/&quot;&gt;insert this Python shim into Windows itself&lt;/a&gt; just to make it easier for people to find Python. Interesting.&lt;/p&gt;
&lt;h1 id=&quot;going-through-the-tutorial&quot;&gt;Going through the tutorial&lt;/h1&gt;
&lt;p&gt;While going through &lt;a href=&quot;https://docs.python.org/3/tutorial/&quot;&gt;Python&amp;#39;s official tutorial&lt;/a&gt;, I&amp;#39;m already seeing things I don&amp;#39;t like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are &lt;code&gt;else&lt;/code&gt; blocks on &lt;em&gt;loops&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pass&lt;/code&gt; is needed to denote empty blocks&lt;/li&gt;
&lt;li&gt;There are abbreviations that are easy to forget, such as &lt;code&gt;elif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt; are overused in Python&amp;#39;s syntax&lt;/li&gt;
&lt;li&gt;The syntax for both tuples and sets tries to be pretty, but just ends up creating weird edge cases, such as &lt;code&gt;item,&lt;/code&gt; (requiring a trailing comma) for a single-item tuple and &lt;code&gt;{}&lt;/code&gt; being an empty dictionary and not an empty set&lt;/li&gt;
&lt;li&gt;&amp;quot;f-strings&amp;quot; can&amp;#39;t be arbitrarily nested (i.e. you can&amp;#39;t use quotation marks inside an f-string that is delimited by quotation marks)&lt;/li&gt;
&lt;li&gt;The module loading system seems needlessly complicated (&lt;code&gt;__init__.py&lt;/code&gt;, &lt;code&gt;__all__&lt;/code&gt;, &lt;code&gt;import *&lt;/code&gt;, etc.)&lt;/li&gt;
&lt;li&gt;The default global scope has too many members&lt;/li&gt;
&lt;li&gt;Variables introduced in a &lt;code&gt;for&lt;/code&gt; loop go into the enclosing scope (making it easy to accidentally change variables in the enclosing scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nonlocal&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; seem dangerous&lt;/li&gt;
&lt;li&gt;Virtual environments are &lt;em&gt;definitely&lt;/em&gt; not my preferred solution to managing conflicting dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;overall-first-impressions&quot;&gt;Overall first impressions&lt;/h1&gt;
&lt;p&gt;Here are my impressions after going through the Python tutorial and playing with Python for a few days:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t like the syntax, but I also don&amp;#39;t hate it as much as I expected to&lt;/li&gt;
&lt;li&gt;Python definitely shows its age, and it has a lot of compatibility-related warts that are unpleasant&lt;/li&gt;
&lt;li&gt;There are some handy syntactical conveniences (e.g. list comprehensions)&lt;/li&gt;
&lt;li&gt;I am strongly in favor of its &amp;quot;batteries included&amp;quot; approach that yields a robust standard library (it even has SQLite out of the box!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ultimately, Python&amp;#39;s biggest advantage is its popularity.&lt;/p&gt;
&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;
&lt;p&gt;Now that I&amp;#39;ve read up on Python and written some basic scripts (mostly to solve &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt; problems), it&amp;#39;s time to tackle a significant project that is suited to Python, e.g.:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Play around with machine learning (e.g. &lt;a href=&quot;https://magenta.tensorflow.org/music-transformer&quot;&gt;Music Transformer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Create a basic &amp;quot;shadow testing&amp;quot; web service (for comparing different implementations of a service)&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Testing out C# in 2022</title>
<id>https://log.schemescape.com/posts/programming-languages/c-sharp.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/c-sharp.html"/>
<updated>2022-02-13T00:00:00.000Z</updated>
<summary type="text">In my quest to find a future-proof programming language, I&apos;m investigating C#.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;a previous article&lt;/a&gt;, I enumerated a bunch of popular programming languages and tried to quickly determine which ones seemed like they&amp;#39;d still be useful in another decade.&lt;/p&gt;
&lt;p&gt;Now, I&amp;#39;m drilling into the most promising candidates. First up is C#.&lt;/p&gt;
&lt;h1 id=&quot;setting-up-a-c-development-environment&quot;&gt;Setting up a C# development environment&lt;/h1&gt;
&lt;p&gt;To my surprise, the &lt;a href=&quot;https://github.com/dotnet/roslyn&quot;&gt;C# compiler&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/runtime&quot;&gt;.NET runtime&lt;/a&gt; are both now open source (MIT license). Even more surprising, you can now apparently &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/iot/deployment&quot;&gt;deploy self-contained .NET executables to a Raspberry Pi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C# is a great language and the .NET standard library is probably the most thoughtfully crafted standard library I&amp;#39;ve ever used. So is my search over? Is C# the answer?&lt;/p&gt;
&lt;p&gt;First, I need to setup a C# development environment. After selecting the .NET runtime and SDK in the Visual Studio installer, I am appalled to see that it requires &lt;em&gt;5 GB&lt;/em&gt; of disk space! There&amp;#39;s probably a bunch of extraneous junk I don&amp;#39;t need, but for comparison: Visual Studio Code is ~300 MB and Deno&amp;#39;s TypeScript runtime is ~60 MB.&lt;/p&gt;
&lt;p&gt;Even after installing all that software, I tried opening a C# project that I created with the &lt;code&gt;dotnet new&lt;/code&gt; command line interface and it told me I needed to install 3.5 GB of software. I think this might be because ASP.NET Core wants to use an older version of .NET. Regardless, as far as I can tell, this is in addition to the 5 GB I already installed, so we&amp;#39;re up to something like 8.5 GB just to run a &amp;quot;hello world&amp;quot; web server.&lt;/p&gt;
&lt;p&gt;Fighting my instinct to run away from such a massive disk footprint, I went ahead and installed everything. At least if I test out C# and find it&amp;#39;s not a good fit for me, I&amp;#39;ll be able to easily recover a large amount of disk space without hesitation.&lt;/p&gt;
&lt;h1 id=&quot;putting-c-and-net-through-its-paces-or-not&quot;&gt;Putting C# and .NET through its paces (or not)&lt;/h1&gt;
&lt;p&gt;As an initial test, I&amp;#39;d like to build a self-contained &amp;quot;hello world&amp;quot; web server, running on Windows (32-bit and 64-bit), Linux (x64 Debian and Alpine), and a Raspberry Pi.&lt;/p&gt;
&lt;p&gt;Unfortunately, even with multiple .NET frameworks and SDKs installed and running Visual Studio, I was not able to successfully build a self-contained executable (it seemed to think I was using .NET Core, which I don&amp;#39;t think I ever installed). After uninstalling the .NET 5.0 SDK, it seems that .NET 4.7.2 was also uninstalled, along with the .NET command line interface (&lt;code&gt;dotnet&lt;/code&gt;). Reloading my test project prompted me to retarget to a previous .NET version, but then the project wouldn&amp;#39;t build at all (even &amp;quot;framework-dependent&amp;quot;). Keep in mind this was a trivial &amp;quot;hello world&amp;quot; &lt;em&gt;command line&lt;/em&gt; app, as in just &lt;code&gt;Console.WriteLine(&amp;quot;Hello, world!&amp;quot;)&lt;/code&gt; inside a class&amp;#39;s &lt;code&gt;Main&lt;/code&gt; function).&lt;/p&gt;
&lt;p&gt;Even worse, after throwing up my hands in frustration, I went to uninstall all the .NET and C# components (to start over from scratch) and now Visual Studio&amp;#39;s installer is claiming some of the components are required for C++ development, so I guess I&amp;#39;m never getting all that disk space back unless I want to break my C++ development environment.&lt;/p&gt;
&lt;h1 id=&quot;thats-unfortunate&quot;&gt;That&amp;#39;s unfortunate...&lt;/h1&gt;
&lt;p&gt;Despite my concerns around C# being closed source, I found that a lot of the C# tooling is actually open source now. Unfortunately, it still seems to be inextricably tied to Visual Studio and its massive, opaque installation process.&lt;/p&gt;
&lt;p&gt;I feel a bit bad about giving up so quickly, but my experience with C# thus far has been the polar opposite of &amp;quot;convenient&amp;quot;. I want a programming language that is future-proof, convenient, and comfortable. C# is comfortable. I don&amp;#39;t know if it&amp;#39;s future-proof (or portable). But it is most definitely &lt;em&gt;not&lt;/em&gt; convenient.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Future-proof programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages.html"/>
<updated>2022-02-11T00:00:00.000Z</updated>
<summary type="text">My projects are currently on hold while I suffer from programming language analysis paralysis.</summary>
<content type="html">&lt;p&gt;After some rapid progress on projects such as &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../releases/md2blog-1.1.1.html&quot;&gt;md2blog&lt;/a&gt;, everything has come to a screeching halt while I struggle with making future-proof technology choices. This post is specifically about programming languages.&lt;/p&gt;
&lt;h1 id=&quot;why-future-proof&quot;&gt;Why future-proof?&lt;/h1&gt;
&lt;p&gt;I want code that I write to continue being useful to me in the future. Specifically, I want to be able to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run my code&lt;/li&gt;
&lt;li&gt;Recompile my code (in case I end up on a new platform)&lt;/li&gt;
&lt;li&gt;Reuse my code in other projects&lt;/li&gt;
&lt;li&gt;Do all of the above with a minimum of hassle (and no multi-gigabyte downloads!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this is why I&amp;#39;m stuck on trying to find a comfortable, future-proof programming language.&lt;/p&gt;
&lt;h1 id=&quot;indicators&quot;&gt;Indicators&lt;/h1&gt;
&lt;p&gt;Here are some ideas on what indicates that a programming language will persist well into the future:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Availability of &lt;em&gt;open source&lt;/em&gt; compilers and tooling (ideally multiple implementations that are mutually compatible)&lt;/li&gt;
&lt;li&gt;Support for many platforms&lt;/li&gt;
&lt;li&gt;Broad usage (both in open source projects and industry)&lt;/li&gt;
&lt;li&gt;Actively maintained standard library&lt;/li&gt;
&lt;li&gt;No breaking changes (ideally)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, I&amp;#39;d also like the programming language to be convenient and comfortable, so I&amp;#39;ll add to my wishlist:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No multi-gigabyte downloads just to get started&lt;/li&gt;
&lt;li&gt;Not tied to a single platform/environment/tool set&lt;/li&gt;
&lt;li&gt;Small and simple (in case I want to build my own tools)&lt;/li&gt;
&lt;li&gt;Easily cross-compiled&lt;/li&gt;
&lt;li&gt;Simple and transparent build process&lt;/li&gt;
&lt;li&gt;Readily available libraries (either with source available or from reputable contributors)&lt;/li&gt;
&lt;li&gt;Ergonomic editing&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;observations&quot;&gt;Observations&lt;/h1&gt;
&lt;p&gt;According to &lt;a href=&quot;https://insights.stackoverflow.com/survey/2021#technology-most-popular-technologies&quot;&gt;Stack Overflow&lt;/a&gt;, the most popular programming languages are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Clojure&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Zig (not actually on the list)&lt;/li&gt;
&lt;li&gt;Lua (also not on the list)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now it&amp;#39;s time to ruthlessly eliminate popular programming languages.&lt;/p&gt;
&lt;p&gt;Some languages are mostly tied to a particular platform, so they get cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java and Perl I have experience with, and frankly, they&amp;#39;re too cumbersome, so I won&amp;#39;t investigate them further.&lt;/p&gt;
&lt;h1 id=&quot;second-round&quot;&gt;Second round&lt;/h1&gt;
&lt;p&gt;After some initial pruning, here is the list with my initial thoughts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript/TypeScript&lt;/strong&gt;: lots of implementations and modern JavaScript is nice, but comes with a ton of baggage; TypeScript brings some sanity to the language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;: setting up a Python environment is a recurring nightmare of mine, but it&amp;#39;s so popular that I probably need to give it another shot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt;: a great language and standard library, but how much of it is open source? Is it portable? Can I run .NET on a Raspberry Pi?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;: terribly complex, but modern C++ is surprisingly convenient; the build systems are generally awful, though&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: probably the most portable and future-proof language ever created, but not very ergonomic&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go&lt;/strong&gt;: &amp;quot;goroutines&amp;quot; seem great and I&amp;#39;ve heard the tooling is nice, but a garbage-collected language with C-like verbosity sounds like the worst of both worlds to me&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: new and popular, with an appealing memory model, but there&amp;#39;s really only one implementation and &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;my first experience setting Rust up on Windows was terrible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ruby&lt;/strong&gt;: just as annoying to setup as Python, but less popular&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Haskell&lt;/strong&gt;: it&amp;#39;s been a while since I used a purely functional programming language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lisp/Clojure&lt;/strong&gt;: I love the simplicity of Lisp (namely Scheme), but I have doubts about it being convenient and portable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zig&lt;/strong&gt;: probably too new and with too many breaking changes, but I like the idea of a more sane alternative to C, and the Zig compiler is very convenient&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;: I used to love Lua, but TypeScript just seems so much more popular and productive these days (also: I hate 1-based arrays)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given that this list is already too long, I&amp;#39;m going to eliminate a few options without proper due diligence (either based on prior experience or based on the belief that similar but superior options exist elsewhere on this list). Apologies to the following languages that have been cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Lua&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;third-round&quot;&gt;Third round&lt;/h1&gt;
&lt;p&gt;For the next round, I&amp;#39;ll do more research and hopefully play around with the languages I&amp;#39;m unfamiliar with.&lt;/p&gt;
&lt;p&gt;Some initial thoughts on the languages I&amp;#39;m familiar with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript: comfortable and convenient, but memory usage and (lack of) parallelism are concerns&lt;/li&gt;
&lt;li&gt;C#: can this run on a Raspberry Pi? How much of the standard library is closed source?&lt;/li&gt;
&lt;li&gt;C++: is there C++ environment that is quick and easy to setup?&lt;/li&gt;
&lt;li&gt;C: a frontrunner, despite its numerous problems&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here are the languages I need to investigate further:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Lisp/Clojure&lt;/li&gt;
&lt;li&gt;Zig&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all for now&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s as far as I&amp;#39;ve gotten. My next steps are to see if C# is viable, determine if there&amp;#39;s a convenient C++ environment, give Python yet another try, and then play around with Go, Rust, Clojure (or other Lisps), and Zig.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Frameworks for porting web apps to the desktop</title>
<id>https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html"/>
<updated>2022-01-13T00:00:00.000Z</updated>
<summary type="text">This is my initial research into converting a web app to a desktop app.</summary>
<content type="html">&lt;p&gt;I have a browser-based application that I&amp;#39;d like to transform into a &amp;quot;normal&amp;quot; desktop application.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;My situation is fairly unique, but here&amp;#39;s my motivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My app is already web-based (using HTML, CSS, TypeScript, with a corresponding HTTP API that&amp;#39;s deployed to &lt;a href=&quot;https://functions.netlify.com/&quot;&gt;Netlify Functions&lt;/a&gt;), and I don&amp;#39;t want to rewrite any of my code&lt;/li&gt;
&lt;li&gt;I&amp;#39;m planning to use a distribution service that&amp;#39;s based on plain old desktop executables (this is probably an unusual requirement)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some more typical reasons for porting from web to desktop might be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wanting to take advantage of libraries, devices, or system APIs that aren&amp;#39;t available in the browser&lt;/li&gt;
&lt;li&gt;Wanting to integrate with native code that (probably due to performance) won&amp;#39;t be ported to WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;why-not&quot;&gt;Why not?&lt;/h1&gt;
&lt;p&gt;Some downsides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Electron (the most popular desktop framework for web technologies) produces large binaries (100+ MB) that use a lot of memory (due to bundling an entire browser engine within each application, presumably to ensure consistency across devices)&lt;ul&gt;
&lt;li&gt;This also means that copyright notices for a huge number of open source libraries Chromium uses must be included&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These frameworks typically have their own unique build processes, which adds additional complexity as compared to building a desktop app &amp;quot;the normal way&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;My research turned up the following relevant frameworks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;Electron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nwjs.io/&quot;&gt;NW.js&lt;/a&gt; (formerly node-webkit)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tauri-apps/tauri&quot;&gt;Tauri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs&quot;&gt;Neutralinojs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here is my uneducated, subjective comparison (all of these frameworks currently support Windows, Linux, and macOS, with Tauri planning to eventually support iOS and Android):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Framework&lt;/th&gt;
&lt;th&gt;Engine&lt;/th&gt;
&lt;th&gt;Maturity&lt;/th&gt;
&lt;th&gt;License&lt;/th&gt;
&lt;th&gt;Examples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Electron&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;Stable&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;VS Code, Slack, Discord&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NW.js&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tauri&lt;/td&gt;
&lt;td&gt;Chromium (Windows)&lt;br/&gt;WebKit (Linux/macOS)&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;Apache&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Neutralinojs&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs/blob/main/LICENSE&quot;&gt;Many&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I&amp;#39;m ignoring native code interop because it&amp;#39;s not relevant to me, but I believe NW.js uses Node and Tauri uses Rust.&lt;/p&gt;
&lt;h1 id=&quot;my-plan&quot;&gt;My plan&lt;/h1&gt;
&lt;p&gt;For my purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I only &lt;em&gt;need&lt;/em&gt; to support Windows (at least initially)&lt;/li&gt;
&lt;li&gt;I may not need desktop integration or native code&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to produce a minimal binary package (i.e. I don&amp;#39;t want to bundle an entire browser runtime if I don&amp;#39;t have to)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on that last requirement, Tauri (or maybe Neutralinojs) seemed like the best match, but I had concerns about reliability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tauri is built on &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt;, which is installed separately from the operating system (so not all Windows computers will have it installed)&lt;/li&gt;
&lt;li&gt;Tauri&amp;#39;s bundler produces installers on Windows that apparently &lt;a href=&quot;https://github.com/tauri-apps/tauri/issues/2452&quot;&gt;don&amp;#39;t clearly communicate this requirement&lt;/a&gt;, possibly leading to broken installs&lt;/li&gt;
&lt;li&gt;This also means that installation inherits the WebView2 runtime&amp;#39;s need for elevated privileges (avoidable by distributing the runtime as well, but that&amp;#39;s basically Electron at that point)&lt;/li&gt;
&lt;li&gt;Obviously, if I want to later expand to Linux and/or macOS (where Tauri uses WebKit) I might run into incompatibilities (although I haven&amp;#39;t heard of any with the web version of my app)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taken as a whole (and given that WebView2 is relatively new), unless I have some way to ensure the WebView2 runtime will be present, I will likely end up using Electron, despite my reservations around download size and efficiency. At least in my case, there are some mitigating factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This isn&amp;#39;t an app I expect users to have open all the time (so memory usage is less of a concern)&lt;/li&gt;
&lt;li&gt;There is a simple fallback for anyone who wants to avoid a large download: just use the web version!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This isn&amp;#39;t the answer I had hoped for, but I&amp;#39;m trying to be pragmatic. Hopefully in the future WebView2 will be installed by default and I can switch to something more lightweight like Tauri.&lt;/p&gt;
</content>
</entry>
<entry>
<title>My first experience with Rust</title>
<id>https://log.schemescape.com/posts/programming-languages/rust-first-experience.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/rust-first-experience.html"/>
<updated>2022-01-06T00:00:00.000Z</updated>
<summary type="text">Rust is popular and I&apos;m interested in its memory safety features and build system. Here&apos;s my first experience with Rust.</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; is so popular these days that &amp;quot;written in Rust&amp;quot; is undoubtedly going to become a meme (if it hasn&amp;#39;t already). It&amp;#39;s time I give it a try!&lt;/p&gt;
&lt;h1 id=&quot;the-appeal-of-rust&quot;&gt;The appeal of Rust&lt;/h1&gt;
&lt;p&gt;I can understand the appeal of Rust. It&amp;#39;s a modern language (meaning it doesn&amp;#39;t have a ton of legacy cruft), it has a unique memory model that prevents certain classes of bugs, yet it still has manual memory management. This is a unique combination.&lt;/p&gt;
&lt;p&gt;Theoretically, this should allow Rust to be used all the way from memory-constrained embedded systems to high level apps.&lt;/p&gt;
&lt;h1 id=&quot;what-about-c&quot;&gt;What about C++?&lt;/h1&gt;
&lt;p&gt;Now, I&amp;#39;m not willing to jump to a new language and ecosystem just because it&amp;#39;s shiny and new. Rust&amp;#39;s memory model seems like an improvement over C++, but modern C++ has (in my experience) fewer memory bugs anyway, thanks to smart pointers and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;RAII&lt;/a&gt; pattern.&lt;/p&gt;
&lt;p&gt;But here are some other enticing features of Rust:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust has its own package manager, &lt;a href=&quot;https://doc.rust-lang.org/stable/cargo/&quot;&gt;Cargo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust has its own build system, which is also Cargo&lt;/li&gt;
&lt;li&gt;Rust&amp;#39;s compiler is built on LLVM, so it can trivially target WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If I had to pick the worst part of C++ development, I&amp;#39;d say it&amp;#39;s setting up a build system and dealing with dependencies. To me, Cargo is actually the biggest differentiator for Rust as compared to C++.&lt;/p&gt;
&lt;h1 id=&quot;installing-rust&quot;&gt;Installing Rust&lt;/h1&gt;
&lt;p&gt;It might be unreasonable, but I&amp;#39;d like my programming language of choice to have a development environment that is compact and simple to setup. Aside: this is one of the reasons I enjoy &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../web-development/one-month-with-deno.html&quot;&gt;Deno&lt;/a&gt;: it ships as a single (fairly small) binary.&lt;/p&gt;
&lt;p&gt;Following Rust&amp;#39;s &lt;a href=&quot;https://www.rust-lang.org/learn/get-started&quot;&gt;getting started instructions&lt;/a&gt;, I&amp;#39;m immediately discouraged:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It looks like youâ€™re running Windows. To start using Rust, download the installer, then run the program and follow the onscreen instructions. You may need to install the Visual Studio C++ Build tools when prompted to do so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I have to install a full C++ development environment just to use Rust? Ok, well I click the link and download ~35 MB. Not too bad until it becomes apparent that the download is &lt;em&gt;just the installer itself&lt;/em&gt;. I&amp;#39;m then presented with a huge list of options for things to install.&lt;/p&gt;
&lt;p&gt;The Rust installer indicates that I should install the Windows 10 SDK, so I select that and am horrified to see that it is 2.8 GB.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Based on the documentation I&amp;#39;ve seen so far, it looks like you have to install nearly 3 GB of C++ tools just to get a working Rust development environment on Windows.&lt;/p&gt;
&lt;p&gt;At this point, I&amp;#39;m speechless. I was willing to tolerate a ~500 MB download for a new programming language, but I&amp;#39;m already up to about six times that size without even getting to the Rust part.&lt;/p&gt;
&lt;p&gt;A quick web search indicates that this requirement is just to provide things like a linker, but I&amp;#39;m certain these tools are much less than 3 GB in size.&lt;/p&gt;
&lt;p&gt;I was also under the impression that Rust was fully open source, so requiring closed source tools to build on Windows seems bizarre (note: MinGW might fill in this gap, but that&amp;#39;s another huge download I&amp;#39;d like to avoid, if possible).&lt;/p&gt;
&lt;h1 id=&quot;setting-this-aside-for-now&quot;&gt;Setting this aside for now...&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s enough disappointment for one day. I&amp;#39;d still like to give Rust a go, but it looks like first I&amp;#39;m going to have to figure out how to get a working environment without installing gigabytes of unrelated tooling (especially since part of my motivation to try Rust was to avoid having to setup an entire C++ toolchain!).&lt;/p&gt;
</content>
</entry>
</feed>
