<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2022-02-11T16:41:35.325Z</updated>

<entry>
<title>Frameworks for porting web apps to the desktop</title>
<id>https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html"/>
<updated>2022-01-13T00:00:00.000Z</updated>
<summary type="text">This is my initial research into converting a web app to a desktop app.</summary>
<content type="html">&lt;p&gt;I have a browser-based application that I&amp;#39;d like to transform into a &amp;quot;normal&amp;quot; desktop application.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;My situation is fairly unique, but here&amp;#39;s my motivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My app is already web-based (using HTML, CSS, TypeScript, with a corresponding HTTP API that&amp;#39;s deployed to &lt;a href=&quot;https://functions.netlify.com/&quot;&gt;Netlify Functions&lt;/a&gt;), and I don&amp;#39;t want to rewrite any of my code&lt;/li&gt;
&lt;li&gt;I&amp;#39;m planning to use a distribution service that&amp;#39;s based on plain old desktop executables (this is probably an unusual requirement)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some more typical reasons for porting from web to desktop might be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wanting to take advantage of libraries, devices, or system APIs that aren&amp;#39;t available in the browser&lt;/li&gt;
&lt;li&gt;Wanting to integrate with native code that (probably due to performance) won&amp;#39;t be ported to WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;why-not&quot;&gt;Why not?&lt;/h1&gt;
&lt;p&gt;Some downsides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Electron (the most popular desktop framework for web technologies) produces large binaries (100+ MB) that use a lot of memory (due to bundling an entire browser engine within each application, presumably to ensure consistency across devices)&lt;ul&gt;
&lt;li&gt;This also means that copyright notices for a huge number of open source libraries Chromium uses must be included&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These frameworks typically have their own unique build processes, which adds additional complexity as compared to building a desktop app &amp;quot;the normal way&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;My research turned up the following relevant frameworks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;Electron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nwjs.io/&quot;&gt;NW.js&lt;/a&gt; (formerly node-webkit)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tauri-apps/tauri&quot;&gt;Tauri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs&quot;&gt;Neutralinojs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here is my uneducated, subjective comparison (all of these frameworks currently support Windows, Linux, and macOS, with Tauri planning to eventually support iOS and Android):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Framework&lt;/th&gt;
&lt;th&gt;Engine&lt;/th&gt;
&lt;th&gt;Maturity&lt;/th&gt;
&lt;th&gt;License&lt;/th&gt;
&lt;th&gt;Examples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Electron&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;Stable&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;VS Code, Slack, Discord&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NW.js&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tauri&lt;/td&gt;
&lt;td&gt;Chromium (Windows)&lt;br/&gt;WebKit (Linux/macOS)&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;Apache&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Neutralinojs&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs/blob/main/LICENSE&quot;&gt;Many&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I&amp;#39;m ignoring native code interop because it&amp;#39;s not relevant to me, but I believe NW.js uses Node and Tauri uses Rust.&lt;/p&gt;
&lt;h1 id=&quot;my-plan&quot;&gt;My plan&lt;/h1&gt;
&lt;p&gt;For my purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I only &lt;em&gt;need&lt;/em&gt; to support Windows (at least initially)&lt;/li&gt;
&lt;li&gt;I may not need desktop integration or native code&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to produce a minimal binary package (i.e. I don&amp;#39;t want to bundle an entire browser runtime if I don&amp;#39;t have to)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on that last requirement, Tauri (or maybe Neutralinojs) seemed like the best match, but I had concerns about reliability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tauri is built on &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt;, which is installed separately from the operating system (so not all Windows computers will have it installed)&lt;/li&gt;
&lt;li&gt;Tauri&amp;#39;s bundler produces installers on Windows that apparently &lt;a href=&quot;https://github.com/tauri-apps/tauri/issues/2452&quot;&gt;don&amp;#39;t clearly communicate this requirement&lt;/a&gt;, possibly leading to broken installs&lt;/li&gt;
&lt;li&gt;This also means that installation inherits the WebView2 runtime&amp;#39;s need for elevated privileges (avoidable by distributing the runtime as well, but that&amp;#39;s basically Electron at that point)&lt;/li&gt;
&lt;li&gt;Obviously, if I want to later expand to Linux and/or macOS (where Tauri uses WebKit) I might run into incompatibilities (although I haven&amp;#39;t heard of any with the web version of my app)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taken as a whole (and given that WebView2 is relatively new), unless I have some way to ensure the WebView2 runtime will be present, I will likely end up using Electron, despite my reservations around download size and efficiency. At least in my case, there are some mitigating factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This isn&amp;#39;t an app I expect users to have open all the time (so memory usage is less of a concern)&lt;/li&gt;
&lt;li&gt;There is a simple fallback for anyone who wants to avoid a large download: just use the web version!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This isn&amp;#39;t the answer I had hoped for, but I&amp;#39;m trying to be pragmatic. Hopefully in the future WebView2 will be installed by default and I can switch to something more lightweight like Tauri.&lt;/p&gt;
</content>
</entry>
<entry>
<title>My first experience with Rust</title>
<id>https://log.schemescape.com/posts/programming-languages/first-experience.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/first-experience.html"/>
<updated>2022-01-06T00:00:00.000Z</updated>
<summary type="text">Rust is popular and I&apos;m interested in its memory safety features and build system. Here&apos;s my first experience with Rust.</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; is so popular these days that &amp;quot;written in Rust&amp;quot; is undoubtedly going to become a meme (if it hasn&amp;#39;t already). It&amp;#39;s time I give it a try!&lt;/p&gt;
&lt;h1 id=&quot;the-appeal-of-rust&quot;&gt;The appeal of Rust&lt;/h1&gt;
&lt;p&gt;I can understand the appeal of Rust. It&amp;#39;s a modern language (meaning it doesn&amp;#39;t have a ton of legacy cruft), it has a unique memory model that prevents certain classes of bugs, yet it still has manual memory management. This is a unique combination.&lt;/p&gt;
&lt;p&gt;Theoretically, this should allow Rust to be used all the way from memory-constrained embedded systems to high level apps.&lt;/p&gt;
&lt;h1 id=&quot;what-about-c&quot;&gt;What about C++?&lt;/h1&gt;
&lt;p&gt;Now, I&amp;#39;m not willing to jump to a new language and ecosystem just because it&amp;#39;s shiny and new. Rust&amp;#39;s memory model seems like an improvement over C++, but modern C++ has (in my experience) fewer memory bugs anyway, thanks to smart pointers and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;RAII&lt;/a&gt; pattern.&lt;/p&gt;
&lt;p&gt;But here are some other enticing features of Rust:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust has its own package manager, &lt;a href=&quot;https://doc.rust-lang.org/stable/cargo/&quot;&gt;Cargo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust has its own build system, which is also Cargo&lt;/li&gt;
&lt;li&gt;Rust&amp;#39;s compiler is built on LLVM, so it can trivially target WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If I had to pick the worst part of C++ development, I&amp;#39;d say it&amp;#39;s setting up a build system and dealing with dependencies. To me, Cargo is actually the biggest differentiator for Rust as compared to C++.&lt;/p&gt;
&lt;h1 id=&quot;installing-rust&quot;&gt;Installing Rust&lt;/h1&gt;
&lt;p&gt;It might be unreasonable, but I&amp;#39;d like my programming language of choice to have a development environment that is compact and simple to setup. Aside: this is one of the reasons I enjoy &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../web-development/one-month-with-deno.html&quot;&gt;Deno&lt;/a&gt;: it ships as a single (fairly small) binary.&lt;/p&gt;
&lt;p&gt;Following Rust&amp;#39;s &lt;a href=&quot;https://www.rust-lang.org/learn/get-started&quot;&gt;getting started instructions&lt;/a&gt;, I&amp;#39;m immediately discouraged:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It looks like you’re running Windows. To start using Rust, download the installer, then run the program and follow the onscreen instructions. You may need to install the Visual Studio C++ Build tools when prompted to do so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I have to install a full C++ development environment just to use Rust? Ok, well I click the link and download ~35 MB. Not too bad until it becomes apparent that the download is &lt;em&gt;just the installer itself&lt;/em&gt;. I&amp;#39;m then presented with a huge list of options for things to install.&lt;/p&gt;
&lt;p&gt;The Rust installer indicates that I should install the Windows 10 SDK, so I select that and am horrified to see that it is 2.8 GB.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Based on the documentation I&amp;#39;ve seen so far, it looks like you have to install nearly 3 GB of C++ tools just to get a working Rust development environment on Windows.&lt;/p&gt;
&lt;p&gt;At this point, I&amp;#39;m speechless. I was willing to tolerate a ~500 MB download for a new programming language, but I&amp;#39;m already up to about six times that size without even getting to the Rust part.&lt;/p&gt;
&lt;p&gt;A quick web search indicates that this requirement is just to provide things like a linker, but I&amp;#39;m certain these tools are much less than 3 GB in size.&lt;/p&gt;
&lt;p&gt;I was also under the impression that Rust was fully open source, so requiring closed source tools to build on Windows seems bizarre (note: MinGW might fill in this gap, but that&amp;#39;s another huge download I&amp;#39;d like to avoid, if possible).&lt;/p&gt;
&lt;h1 id=&quot;setting-this-aside-for-now&quot;&gt;Setting this aside for now...&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s enough disappointment for one day. I&amp;#39;d still like to give Rust a go, but it looks like first I&amp;#39;m going to have to figure out how to get a working environment without installing gigabytes of unrelated tooling (especially since part of my motivation to try Rust was to avoid having to setup an entire C++ toolchain!).&lt;/p&gt;
</content>
</entry>
<entry>
<title>md2blog 1.1.1 released</title>
<id>https://log.schemescape.com/posts/releases/md2blog-1.1.1.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/releases/md2blog-1.1.1.html"/>
<updated>2021-12-27T00:00:00.000Z</updated>
<summary type="text">md2blog (the zero-config static site generator powering this site) has officially been released.</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt; is a zero-config static site generator for dev blogs (like this one), that was created out of frustration with existing (bloated) static site generators.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog web site&lt;/a&gt; lists the key features, but here&amp;#39;s an overview:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;md2blog enables you to create a dev blog from Markdown files without getting bogged down in extraneous details (like runtime environments, plugins, and themes)&lt;/li&gt;
&lt;li&gt;md2blog respects your readers by producing a simple (and small) web site that is still fully functional&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you&amp;#39;ve been disappointed with the complexity of setting up a simple dev blog using other static site generators, I encourage you to download md2blog&amp;#39;s &lt;em&gt;single self-contained binary&lt;/em&gt; and run through the &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/quick-start.html&quot;&gt;quick start&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>One month with Deno (part 2)</title>
<id>https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html"/>
<updated>2021-12-13T00:00:00.000Z</updated>
<summary type="text">I made the switch from Node to Deno recently. Here are the problems with Deno I&apos;ve encountered.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/web-development/one-month-with-deno.html&quot;&gt;part 1&lt;/a&gt;, I gushed over Deno&amp;#39;s benefits, including sand-boxing, native TypeScript support, a simple module registry, and more. Here&amp;#39;s part 2 (which paints a less rosy picture).&lt;/p&gt;
&lt;h1 id=&quot;problems-with-deno&quot;&gt;Problems with Deno&lt;/h1&gt;
&lt;p&gt;Using Deno has come with some significant challenges. Here are the top issues I&amp;#39;ve faced using Deno for the last month. The good news is that people are working on addressing most of these.&lt;/p&gt;
&lt;h2 id=&quot;existing-typescript-modules-dont-work&quot;&gt;Existing TypeScript modules don&amp;#39;t work&lt;/h2&gt;
&lt;p&gt;Wait, I thought Deno had native TypeScript support. What do you mean TypeScript modules don&amp;#39;t work?&lt;/p&gt;
&lt;p&gt;What I mean is that most TypeScript code that wasn&amp;#39;t written specifically for Deno will (generally) not run unmodified in Deno. This is an unfortunate situation because it means that leveraging existing libraries written in TypeScript is nontrivial. The problem arises from two incompatible stances:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deno imports modules by full name (or URL), with &lt;a href=&quot;https://deno.land/manual@v1.16.4/typescript/faqs&quot;&gt;no magical resolution&lt;/a&gt;, so file extensions (or special HTTP headers) are required&lt;/li&gt;
&lt;li&gt;TypeScript &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/27481&quot;&gt;doesn&amp;#39;t change import specifiers&lt;/a&gt;, so it insists (or rather it used to insist) that file extensions be omitted (so the runtime can find and load the resulting &lt;code&gt;.js&lt;/code&gt; files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regardless of which stance is more righteous, the fact is that existing TypeScript code doesn&amp;#39;t work in Deno unless you do work (e.g. adding &lt;code&gt;.ts&lt;/code&gt; to imports or creating an &lt;a href=&quot;https://deno.land/manual@v1.16.4/linking_to_external_code/import_maps&quot;&gt;import map&lt;/a&gt;). There isn&amp;#39;t even any agreement on the best way to work around this annoyance. The trend to Deno-ify TypeScript modules from NPM and publish them on deno.land/x is not encouraging.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s a bit sad because, other than this issue, Deno provides the best tooling for TypeScript I&amp;#39;ve encountered.&lt;/p&gt;
&lt;h2 id=&quot;node-packages-generally-require-third-party-code&quot;&gt;Node packages generally require third party code&lt;/h2&gt;
&lt;p&gt;Ok, so non-Deno TypeScript libraries are out, what about non-Node-specific JavaScript packages on NPM?&lt;/p&gt;
&lt;p&gt;First of all, Deno only supports ES modules (instead of CommonJS), so only packages that are shipped as modules could possibly work unmodified.&lt;/p&gt;
&lt;p&gt;Additionally, if you&amp;#39;re planning to publish a Deno module you don&amp;#39;t have the luxury of using Deno&amp;#39;s &lt;a href=&quot;https://deno.land/manual@v1.16.4/npm_nodejs/compatibility_mode&quot;&gt;Node compatibility mode&lt;/a&gt; or using import maps to support dependencies, so you&amp;#39;re stuck trying to bridge the gap between Deno&amp;#39;s &amp;quot;no magic&amp;quot; module resolution algorithm and Node&amp;#39;s &amp;quot;nothing &lt;em&gt;but&lt;/em&gt; magic&amp;quot; approach.&lt;/p&gt;
&lt;p&gt;Once again, I didn&amp;#39;t see a great option for handling this, especially if you want to leverage &lt;a href=&quot;https://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; declarations. The Deno documentation recommends using third party content delivery services, but I currently have no way to vet these CDNs.&lt;/p&gt;
&lt;p&gt;I won&amp;#39;t describe the approach I ended up using to work around this problem because it is, frankly, a terrible (and manual) hack.&lt;/p&gt;
&lt;h2 id=&quot;standard-library-licenses-arent-uniform&quot;&gt;Standard library licenses aren&amp;#39;t uniform&lt;/h2&gt;
&lt;p&gt;Deno has a standard library! Hooray! Now we can all use the code in whatever project we want as long as we include Deno&amp;#39;s copyright notice...&lt;/p&gt;
&lt;p&gt;...except that the library wasn&amp;#39;t entirely written by the Deno authors, so many of the modules have different copyright notices (e.g. &lt;a href=&quot;https://deno.land/std@0.117.0/encoding/yaml.ts&quot;&gt;std/encoding/yaml.ts&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;This means that you have to track down all of your dependencies and diligently duplicate their copyright notices in tools created with &lt;code&gt;deno compile&lt;/code&gt;. At least Deno restricts contributions to the permissive MIT, BSD, and Apache licenses!&lt;/p&gt;
&lt;h2 id=&quot;webassembly-isnt-seamless&quot;&gt;WebAssembly isn&amp;#39;t seamless&lt;/h2&gt;
&lt;p&gt;Deno currently loads WebAssembly using &lt;code&gt;fetch&lt;/code&gt; (just like in the browser). This sounds like a great idea except for the fact that it requires network and/or file system access. Unfortunately, this means that if you want to use WebAssembly in a library, you have two unappealing options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tell consumers that they need to pass &lt;code&gt;--allow-read&lt;/code&gt; or &lt;code&gt;--allow-net&lt;/code&gt; in when using your library (negating some of the security benefits of Deno)&lt;/li&gt;
&lt;li&gt;Or Base64-encode your module into an obnoxiously huge TypeScript file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deno used to support statically importing WebAssembly (without requiring additional privileges), but that support was removed on the assumption that a forthcoming web standard will eventually solve this problem. Last I read, this is still an open problem.&lt;/p&gt;
&lt;h2 id=&quot;bundling-only-emits-javascript&quot;&gt;Bundling only emits JavaScript&lt;/h2&gt;
&lt;p&gt;Deno &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/bundler&quot;&gt;comes with a simple bundler&lt;/a&gt;! Unfortunately, it only emits JavaScript, so you can&amp;#39;t use it for packaging a TypeScript module into a single file (because you&amp;#39;d lose all your type information).&lt;/p&gt;
&lt;p&gt;I have yet to find a bundler for TypeScript. I really hope I won&amp;#39;t have to write one myself!&lt;/p&gt;
&lt;h2 id=&quot;theres-no-standard-way-to-specify-long-command-lines&quot;&gt;There&amp;#39;s no standard way to specify long command lines&lt;/h2&gt;
&lt;p&gt;I applaud Deno for forcing users to provide permissions on the command line, but those command lines can get pretty long. Additionally, Deno seems to be allergic to configuration files, so instead of putting commands into a configuration file, we just have no standard, cross-platform way to specify how to run code.&lt;/p&gt;
&lt;h2 id=&quot;the-formatter-produces-ugly-code&quot;&gt;The formatter produces ugly code&lt;/h2&gt;
&lt;p&gt;I like the idea of Deno having a built-in formatter, but I don&amp;#39;t actually like the output. For example, the default is to use 2 spaces for indentation. I don&amp;#39;t know anyone (outside of Deno) who prefers 2 spaces over 4 spaces. I find it makes code harder to read. Additionally, the formatter inserts spaces and newlines in surprising places (again, making the code harder to read).&lt;/p&gt;
&lt;p&gt;I appreciate that automatic code formatting is a difficult problem and that style is usually personal preference, but this is the first formatter I&amp;#39;ve seen that I don&amp;#39;t like.&lt;/p&gt;
&lt;h2 id=&quot;bugs-bugs-bugs&quot;&gt;Bugs, bugs, bugs&lt;/h2&gt;
&lt;p&gt;Deno is a remarkable project and I really enjoy it, but I have encountered several critical bugs, just in my first month of use. My favorite two examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Correct&lt;/em&gt; code &lt;em&gt;failing&lt;/em&gt; type checking (due to a caching issue)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Incorrect&lt;/em&gt; code &lt;em&gt;successfully&lt;/em&gt; type checking (due to type checking being unexpectedly skipped)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;so-will-i-keep-using-deno&quot;&gt;So will I keep using Deno?&lt;/h1&gt;
&lt;p&gt;More than once, I&amp;#39;ve wondered if working around the limitations of Deno is costing me more time than I&amp;#39;m saving by using Deno. It very well might.&lt;/p&gt;
&lt;p&gt;In the end, however, I plan to continue using Deno because it provides the best TypeScript runtime I&amp;#39;ve seen, and its features (and most of its goals) align with my needs and preferences.&lt;/p&gt;
</content>
</entry>
<entry>
<title>One month with Deno (the good parts)</title>
<id>https://log.schemescape.com/posts/web-development/one-month-with-deno.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/one-month-with-deno.html"/>
<updated>2021-12-06T00:00:00.000Z</updated>
<summary type="text">I made the switch from Node to Deno recently. Here&apos;s what I&apos;ve liked after a month of using Deno.</summary>
<content type="html">&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;After &lt;a href=&quot;https://log.schemescape.com/posts/web-development/souring-on-npm.html&quot;&gt;souring on NPM&lt;/a&gt; (due to unnecessarily huge dependency trees and security concerns), I decided to give &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt; a try. Deno supports sand-boxing, TypeScript, and ES modules out of the box. Deno has a standard library, along with a simple and transparent module registry, and also comes with with handy tools for bundling and static analysis.&lt;/p&gt;
&lt;h1 id=&quot;what-ive-liked-about-deno&quot;&gt;What I&amp;#39;ve liked about Deno&lt;/h1&gt;
&lt;h2 id=&quot;sand-boxing&quot;&gt;Sand-boxing&lt;/h2&gt;
&lt;p&gt;Deno disallows file system access, network access, and other privileges by default. You can provide fine-grained permissions on the command line, e.g. &lt;code&gt;--allow-read=file.txt&lt;/code&gt; will let the script read &lt;code&gt;file.txt&lt;/code&gt; in the current directory.&lt;/p&gt;
&lt;p&gt;In an ideal world this wouldn&amp;#39;t be necessary, but given that hackers have been targeting package registries such as NPM, this is a step in the right direction. As an example, say that I want to find a quick tool to convert a file from one format to another. Here are some options for doing this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the past, you might just try to find a tool for this purpose, download it, and run it.&lt;ul&gt;
&lt;li&gt;Today, that would be a terrible idea because the tool runs as your user and could, in an extreme example, contain ransomware.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In the recent past, you might do essentially the same as above, just downloading from NPM and running in Node.&lt;ul&gt;
&lt;li&gt;Again, very risky.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Without Deno, you could run the tool in a container or VM (or restricted user).&lt;ul&gt;
&lt;li&gt;This can be safe, but inconvenient.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;With Deno, you might just run the tool with no extra privileges.&lt;ul&gt;
&lt;li&gt;If the tool just reads from standard input and writes to standard output, great!&lt;/li&gt;
&lt;li&gt;If the tool has malware that tries to write to the file system or access the network, Deno will block it.&lt;/li&gt;
&lt;li&gt;Of course, this isn&amp;#39;t 100% safe (&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)&quot;&gt;Spectre&lt;/a&gt; worked from inside the web browser&amp;#39;s sand box, after all), but it&amp;#39;s much better than nothing!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Full details on Deno&amp;#39;s permissions are &lt;a href=&quot;https://deno.land/manual@v1.16.4/getting_started/permissions&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;audited-standard-library&quot;&gt;Audited standard library&lt;/h2&gt;
&lt;p&gt;One of the reasons that NPM projects tend to have gigantic dependency trees is that JavaScript (unlike most popular programming languages of today) doesn&amp;#39;t really come with a standard library. This meant that common tasks such as parsing command line arguments are farmed out to dependencies, which then of course pull in whatever dependencies those authors felt like using, and so on until you have hundreds of dependencies (yes, that happened to me pretty quickly).&lt;/p&gt;
&lt;p&gt;Deno brings JavaScript (and TypeScript) into the modern era by &lt;a href=&quot;https://deno.land/std@0.117.0&quot;&gt;providing a standard library&lt;/a&gt; containing code that has been audited by the Deno authors. The library is not yet comprehensive and navigating the documentation is currently unpleasant, but having a set of trusted dependencies that will be maintained by the Deno authors is a relief after coming from the Node/NPM ecosystem.&lt;/p&gt;
&lt;h2 id=&quot;native-typescript-support&quot;&gt;Native TypeScript support&lt;/h2&gt;
&lt;p&gt;I like JavaScript for prototyping, but I like TypeScript and its tooling more. Honestly, if you know what you&amp;#39;re doing, the compiler should be your friend, helpfully pointing out when you&amp;#39;ve made a typo or not quite lined up types across a function or module boundary. The problem with TypeScript for me has always been setting up a development environment and build scripts.&lt;/p&gt;
&lt;p&gt;With Deno, you get the benefits of TypeScript without having to do any special setup. Just use the &lt;code&gt;.ts&lt;/code&gt; file extension, and Deno will automatically type-check, compile, and run your code. You can even publish your module as TypeScript and Deno scripts can consume it without doing anything special.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re interested in TypeScript, but struggled with Node and NPM (and &lt;code&gt;ts-node&lt;/code&gt;, etc.), give Deno a try!&lt;/p&gt;
&lt;h2 id=&quot;web-standard-apis&quot;&gt;Web standard APIs&lt;/h2&gt;
&lt;p&gt;One of the dreams of Node was to write &amp;quot;isomorphic&amp;quot; code that runs both in Node and the browser. Deno brings this one step closer to reality by embracing browser APIs (e.g. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;fetch&lt;/a&gt;). This is helpful because you can learn about the browser while writing code for Deno and vice versa.&lt;/p&gt;
&lt;h2 id=&quot;simple-transparent-module-registry&quot;&gt;Simple, transparent module registry&lt;/h2&gt;
&lt;p&gt;A major complaint I have with most package managers and package registries is that they don&amp;#39;t make it easy to see what is inside a package before downloading it. NPM is especially bad here because, by default, installing a package can run arbitrary scripts, so you might get malware just by trying to check and see if a package contains malware (this is your reminder to enable NPM&amp;#39;s &lt;a href=&quot;https://docs.npmjs.com/cli/v7/commands/npm-install#ignore-scripts&quot;&gt;ignore-scripts&lt;/a&gt; setting).&lt;/p&gt;
&lt;p&gt;Deno&amp;#39;s module registry is &lt;a href=&quot;https://deno.land/x/&quot;&gt;https://deno.land/x/&lt;/a&gt; and all it does is mirror code from GitHub when tags are pushed. This means that you can browse the &lt;em&gt;exact&lt;/em&gt; code you&amp;#39;ll be downloading prior to actually downloading anything. It also automatically generates documentation from JSDoc comments and helpfully displays the list of (static) external dependencies for a given file.&lt;/p&gt;
&lt;p&gt;I do have concerns about tying the module registry so intimately to GitHub, but for now I just like having a transparent registry that takes the guesswork out of auditing dependencies.&lt;/p&gt;
&lt;h2 id=&quot;bundlercompiler-script-installer&quot;&gt;Bundler/compiler, script installer&lt;/h2&gt;
&lt;p&gt;One theme with Deno is that it has a focus on the entire development experience. Sometimes this is called having &amp;quot;batteries included&amp;quot;. For example, one common problem with scripting languages is that sharing a tool usually requires also sharing the entire runtime environment. E.g. if I want to run a Python script, I need a Python environment (in Python&amp;#39;s case, this is probably even true if I already have Python installed, thanks to frequent breaking changes).&lt;/p&gt;
&lt;p&gt;Deno simplifies this by including a &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/compiler&quot;&gt;built in bundler and compiler&lt;/a&gt; that packages up a script, its dependencies, and the Deno runtime into a single (~30 MB) download. Obviously, this isn&amp;#39;t efficient if you&amp;#39;re using a lot of Deno tools, but it&amp;#39;s indispensible if you don&amp;#39;t care about Deno and just want to use one specific Deno-based tool.&lt;/p&gt;
&lt;p&gt;For a more efficient option, Deno also includes a &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/script_installer&quot;&gt;script installer&lt;/a&gt; that allows you to just download and install a specific script (and its dependencies), relying on the version of Deno you already have.&lt;/p&gt;
&lt;p&gt;Together, these mean that if someone wants to use your tool, they have two great options (both of which can be supported without third party tools/plugins):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Just download the self-contained executable and run it,&lt;/li&gt;
&lt;li&gt;Or just install your script with &lt;code&gt;deno install&lt;/code&gt; and run it&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;built-in-support-for-testing-and-code-coverage&quot;&gt;Built-in support for testing and code coverage&lt;/h2&gt;
&lt;p&gt;While &lt;a href=&quot;https://deno.land/manual@v1.16.4/testing&quot;&gt;Deno&amp;#39;s testing framework&lt;/a&gt; isn&amp;#39;t as mature or featureful as some of the Node testing frameworks (although &lt;a href=&quot;https://deno.land/manual@v1.16.4/testing#integration-with-testing-libraries&quot;&gt;integrations with other libraries exist&lt;/a&gt;), there is one advantage: there&amp;#39;s no install or setup required (no more fiddling with dependencies or test scripts!).&lt;/p&gt;
&lt;p&gt;For example, if I want to write some quick unit tests for &lt;code&gt;foo.ts&lt;/code&gt;, I can just create &lt;code&gt;foo.test.ts&lt;/code&gt;, write some tests (see the previous link for example code), and then run &lt;code&gt;deno test&lt;/code&gt;. It will find my test file, run the tests, and print out the results.&lt;/p&gt;
&lt;p&gt;I love it when tools just do what I want without any effort!&lt;/p&gt;
&lt;h1 id=&quot;but-its-not-all-good&quot;&gt;But it&amp;#39;s not all good...&lt;/h1&gt;
&lt;p&gt;Although I&amp;#39;ve found a lot to like about Deno, not everything has been great (or even good... or even acceptable). Stay tuned for part 2: the gripe session.&lt;/p&gt;
</content>
</entry>
</feed>
