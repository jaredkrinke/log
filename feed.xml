<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Fri, 24 Sep 2021 02:04:16 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Generating diagrams when building a static site (part 1)]]></title><description><![CDATA[<h1 id="background">Background</h1>
<p>As described in a <a href="../overview/">previous post</a>, I&#39;d like to have a static site that requires no JavaScript whatsoever to view the site in full fidelity. I&#39;d also like to be able to embed diagrams into my posts, ideally by inserting a textual description of the diagram.</p>
<p>Given how huge the NPM ecosystem is, I thought this would be trivial to setup. I might have been wrong.</p>
<h1 id="diagramming-software">Diagramming software</h1>
<p>In the past, I&#39;ve used <a href="https://graphviz.org/">Graphviz</a> for generating diagrams, with some success. That was almost 15 years ago, so I assumed today there&#39;d be something newer and more Node-friendly that I could easily integrate into my workflow.</p>
<p>After scouring the web for an hour or so, I found a couple of patterns:</p>
<ul>
<li>There were several libraries that aggregate diagramming libraries under a unified API<ul>
<li>But the component libraries were written in a wide variety of languages (Python, C, etc.), so deployment would be a huge hassle (<a href="https://kroki.io/">Kroki</a> even went so far as to recommend <em>against</em> trying to deploy your own instance)</li>
</ul>
</li>
<li>Many of the libraries were written in Java (a language I&#39;d like to avoid, if possible)</li>
<li>Most of the libraries didn&#39;t have a convenient text-based input format</li>
<li>Most of the libraries were designed to run <em>on the client</em></li>
</ul>
<p>I definitely don&#39;t want to have to install multiple programming language environments, and it seems silly to have each client re-render the same diagram on every view. I also don&#39;t want to depend on a service that is currently free, but could potentially disappear overnight.</p>
<p>My research led me to two candidate tools:</p>
<ul>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a>: Markdown-inspired JavaScript-based tool</li>
<li><a href="https://graphviz.org/">Graphviz</a>: Super old (originally created by AT&amp;T!), C-based diagramming tool</li>
</ul>
<p>Neither of these is perfect for my environment. Will they work? Probably, but how inconvenient will it be?</p>
<h2 id="mermaid">Mermaid</h2>
<p>Mermaid is written in JavaScript, so I should just be able to install it via NPM, call an API, and be done, right? Actually, no.</p>
<p>Remember, I want to insert the source code of a diagram directly into my Markdown files, but then have that rendered to SVG at build time. <a href="https://mermaid-js.github.io/mermaid/#/n00b-gettingStarted">Mermaid&#39;s deployment model</a> is to have the client parse the source code from within the page, render an image, and insert it into the DOM.</p>
<p>Ok, so I can just run that same code in Node at build time, right? Then I can skip all the client-side JavaScript? Not according to <a href="https://github.com/mermaid-js/mermaid/issues/146">an issue in Mermaid&#39;s issue tracker</a>!</p>
<p>From reading that thread, it sounds like Mermaid interacts directly with the web page&#39;s DOM when rendering. Someone created a command line tool (<a href="https://github.com/mermaidjs/mermaid.cli">mermaid.cli</a>) that apparently uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a>&#39;s headless Chromium environment to supply a functioning DOM. Apparently, this is the normal workaround for using D3.js-based graphics on the back end. I find this implementation slightly appalling.</p>
<p>I&#39;m a little bit worried about the performance of building my site when each diagram has to spin up a new process which hosts a headless Chromium browser, just to spit out SVG. I suspect it will <em>work</em>, but it seems wasteful.</p>
<p>Let&#39;s see if I can find a better option.</p>
<h2 id="graphviz">Graphviz</h2>
<p>Graphviz is old and originated at AT&amp;T, so of course it is written in C. I love C, but compiling anything with dependencies beyond the standard library is a chore. Part of what attracted me to the Node ecosystem was that most everything is written in JavaScript and, since JavaScript compilers are so fast these days, performance is surprisingly adequate most of the time.</p>
<p>Anyway, so my first thought for integration is to just make sure Graphviz is installed and then spin up a process to render diagrams. I don&#39;t want to have to start a new process each time, but it&#39;s native code, so it&#39;s probably fast enough for my needs. Taking a dependency on a binary is highly unusual in Node land, however, so I&#39;d like to find some way to avoid doing that.</p>
<p>But wait, someone already solved this problem! <a href="https://github.com/JosephusPaye/node-graphviz">node-graphviz</a> is a theoretically Node-compatible version of Graphviz. According to the package, they compiled Graphviz to a <a href="https://webassembly.org/">Web Assembly</a> module, which can be hosted and run within Node.js. No C compiler needed (for users of the library, that is)!</p>
<p>Embedding Graphviz directly seems like a very promising solution, but I haven&#39;t vetted the library to ensure it works as advertised. The code certainly is not what I was expecting to see (it&#39;s enormous!), so I&#39;m a bit skeptical.</p>
<h1 id="mermaidcli-or-node-graphviz">mermaid.cli or node-graphviz?</h1>
<p>Unfortunately, neither of the two most promising solutions appears obviously better than the other.</p>
<p>Mermaid seems nice because it appears to be broadly used and, by virtue of being newer and web-focused, likely has better support for integrating into web pages (and supporting dark mode, etc.). But I&#39;m having a difficult time getting over the idea of it requiring direct access to a DOM. That just doesn&#39;t seem like a good fit for my &quot;local build&quot; scenario. I&#39;m afraid that, even if I use the command line tool or cook up some way to avoiding handing Mermaid a DOM, it will be fragile.</p>
<p>Graphviz doesn&#39;t seem to support as many diagram types, and I&#39;m a little bit worried to take on a Web Assembly dependency, but on the other hand I&#39;ve been meaning to learn more about Web Assembly anyway. This project might be a good way to learn what goes into integrating a Web Assembly module into Node.</p>
<h1 id="next-steps">Next steps</h1>
<p>Hopefully I don&#39;t regret this decision, but I think I&#39;m going to first try integrating Mermaid. If I hit any snags or if performance is abysmal, I&#39;ll see if node-graphviz is actually what I&#39;m looking for.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams</guid><pubDate>Thu, 23 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Finding the cheapest hosting for my hobby projects]]></title><description><![CDATA[<p>I like playing around with software, so I frequently have hobby projects in development or &quot;production&quot; (scare quotes because they&#39;re hobbies after all). Since I don&#39;t like wasting money, I&#39;m always on the lookout for cheap project hosting.</p>
<p>Here&#39;s how I went from cheap hosting to free hosting.</p>
<h1 id="background">Background</h1>
<p>Just for fun, I made a couple of computer games (best played on a desktop/laptop):</p>
<ul>
<li><a href="https://jaredkrinke.itch.io/sic-1">SIC-1</a>: A single-instruction (<a href="https://esolangs.org/wiki/Subleq">subleq</a>) programming game, with a global leader board</li>
<li><a href="https://jaredkrinke.itch.io/fbgp8">Falling Block Game</a>: Block-stacking game for <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a> with a global high scores list</li>
</ul>
<p>Both of these require services with a small amount of storage. Since there are no ads or monetization, I&#39;d like to run the services as cheaply as possible.</p>
<h1 id="first-attempt-120month">First attempt: $1.20/month</h1>
<p>I inherited a first generation <a href="https://www.raspberrypi.org/">Raspberry Pi</a> and already had a $10/year domain, so why not just host my site locally?</p>
<p>Because I was curious about Node, I decided to use the following very simple tech stack:</p>
<ul>
<li>Software<ul>
<li><a href="https://nodejs.org/en/">Node</a> JavaScript environment</li>
<li><a href="http://expressjs.com/">Express</a> web server framework</li>
<li><a href="https://sqlite.org/index.html">SQLite</a> (via <a href="https://www.npmjs.com/package/sqlite3">sqlite3</a>) in-process, single file-based database</li>
<li><a href="https://github.com/zapty/forever-service">forever-service</a> service monitoring</li>
<li><a href="https://letsencrypt.org/">Let&#39;s Encrypt</a> certificate service</li>
</ul>
</li>
<li>Hardware/connectivity<ul>
<li>Raspberry Pi (first generation), running <a href="https://www.raspbian.org/">Raspbian</a></li>
<li>My home Internet connection and router, with appropriate holes in the firewall</li>
<li>$10/year .com domain name</li>
</ul>
</li>
</ul>
<p>There was very little traffic, so the Raspberry Pi could service requests fine and my (cheapest tier) cable Internet was sufficient.</p>
<h2 id="cost">Cost</h2>
<p>The Raspberry Pi drew roughly 3 watts, so the electricity plus domain meant I was hosting a service for roughly $1.20 per month. Very affordable! Additionally, as long as I didn&#39;t have a lot of traffic, I could run multiple services without increasing the cost.</p>
<h2 id="concerns">Concerns</h2>
<p>I was a bit wary of poking a hole in my firewall and, within a few days, I decided that my concern was justified.</p>
<p>The log for my web server was almost immediately flooded by TCP scanning requests from <a href="https://github.com/robertdavidgraham/masscan">masscan</a>. I also saw 404 errors to common vulnerable paths (namely phpMyAdmin- and WordPress-related paths).</p>
<p>I know there are a lot of people who enjoy having their own &quot;<a href="https://haydenjames.io/home-lab-beginners-guide-hardware/">home lab</a>&quot;, and I&#39;m sure many of these people keep up on the latest security recommendations, but I was more interested in hosting a service than attracting unwanted attention to my home network&#39;s external IP address.</p>
<p>I would strongly advise against hosting any site this way, especially since it turns out to not even be the cheapest option!</p>
<h1 id="second-attempt-433month">Second attempt: $4.33/month</h1>
<p>Wait, my hosting cost went up!? Yes, and it was money well spent.</p>
<p>After getting slightly alarmed at all of the nefarious traffic flowing through my router, I was happy to pay for a virtual private server. This way it&#39;s at least not my own personal network that&#39;s at risk when something goes wrong.</p>
<p>I selected <a href="https://www.vultr.com/">Vultr</a> as the host because they <a href="https://www.vultr.com/products/cloud-compute/#pricing">offered a decent server for $2.50/month</a>... except that server is <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> only, and it turns out that much of the Internet is stuck in the address-constrained dark age of IPv4. So I had to pay a $1/month premium for an IPv4 address.</p>
<p>The tech stack was the same except for the host. Both the VPS&#39;s Internet connection and CPU were light years beyond what I had with my Raspberry Pi on &quot;cheap&quot; cable Internet.</p>
<h2 id="cost-1">Cost</h2>
<p>Adding in the domain name, my total cost was $4.33/month. A little more than I&#39;d like to spend on silly hobby projects, but this setup came with the peace of mind of not broadcasting my home IP address everywhere. Again, I could add more services to my server at no additional cost to me.</p>
<h2 id="concerns-1">Concerns</h2>
<p>Other than costing me roughly $50/year, this setup worked great. But it wasn&#39;t as robust as I&#39;d like:</p>
<ul>
<li>The database was a single file sitting on the server&#39;s drive, with no backup, so I could theoretically lose it due to hardware failure</li>
<li>Configuring the server was a manual process, so if there was a crash, I&#39;d have to spend time setting a new server up</li>
</ul>
<p>At the time, I wasn&#39;t aware, but there are solutions to both of these problems:</p>
<ul>
<li>Use <a href="https://litestream.io/">Litestream</a> to continuously backup the SQLite database to cloud storage</li>
<li>Use <a href="https://www.docker.com/">Docker</a> to package everything up, enabling rapid recreation of the server</li>
</ul>
<p>There are actually many other solutions, but these are two simple approaches I plan on testing out in the future.</p>
<h1 id="third-attempt-free">Third attempt: FREE!</h1>
<p>While chatting with a friend who does web development for a living, he told me that I could probably host my site for free. That magic phrase led to several follow-up questions from me, and a lot more information from him.</p>
<p>It turns out that many cloud providers have free tiers to try and hook you into their ecosystems, in hopes that you&#39;ll eventually become a paying customer. I&#39;m pretty sure all the major cloud providers have free tiers, and some of them are quite generous. My uninformed opinion is that it seems like the less popular the platform, the more generous the free tier.</p>
<p>The annoying part of all of this is that the best free offers vary substantially, so you&#39;ll likely end up having to use multiple different providers. In my case, the tech stack looks like this:</p>
<ul>
<li>Node JavaScript environment</li>
<li><a href="https://koajs.com/">Koa</a> web framework</li>
<li><a href="https://cloud.google.com/firestore/">Firestore</a> document database</li>
<li><a href="https://www.netlify.com/products/functions/">Netlify Functions</a> &quot;<a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless</a>&quot; end point<ul>
<li>Hosted on the (free) &quot;netlify.app&quot; domain</li>
</ul>
</li>
</ul>
<p>Since everything is in the cloud, I&#39;m also less concerned about hardware failure. I haven&#39;t thoroughly investigated whether I should backup my Firestore data or if their architecture seems robust enough for my needs.</p>
<h2 id="cost-2">Cost</h2>
<p>Zero cost, since I didn&#39;t need to use a custom domain. I didn&#39;t even have to provide a credit card.</p>
<h2 id="concerns-2">Concerns</h2>
<p>This setup is free, which is great, but when I last checked, both of the free offerings I&#39;m using were actually fairly expensive if you end up with enough traffic to need to start paying. You&#39;re also locked into their systems unless you want to start rewriting code.</p>
<p>I also found that Firestore wasn&#39;t a great fit for my needs, since it&#39;s a &quot;<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>&quot; document database that basically requires me to build and maintain my own aggregations. But I&#39;m not paying anything, so I shouldn&#39;t complain.</p>
<h1 id="what-about-the-future">What about the future?</h1>
<p>I succeeded in finding free hosting for my hobby projects. Great! But I&#39;m not perfectly happy being locked into specific vendors and libraries.</p>
<p>Cloud services are great, but I&#39;d really like something more portable, in case I ever create a project that ends up getting a significant amount of traffic. There may be better approaches, but I think I&#39;d like to use containers hosted on a VPS (with backup to commodity cloud storage), just for portability reasons.</p>
<p>I have heard that Oracle&#39;s cloud has a <a href="https://www.oracle.com/cloud/free/#always-free">free tier that even includes your own virtual private servers</a>, so I may look into that eventually. Planning to use Oracle is something I never thought I&#39;d be doing as a hobbyist, but these are interesting times.</p>
<p>The future might look like this:</p>
<ul>
<li>Node environment</li>
<li>Koa web framework</li>
<li>SQLite database<ul>
<li>Backed up to commodity store (e.g. <a href="https://www.backblaze.com/">Backblaze</a>) via Litestream</li>
</ul>
</li>
<li>Forever-service monitoring</li>
<li>Let&#39;s encrypt certificate</li>
<li>All in a Docker container</li>
<li>Hosed on Oracle&#39;s free compute VM</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/services/cheap-hosting</link><guid isPermaLink="true">https://log.schemescape.com/posts/services/cheap-hosting</guid><pubDate>Wed, 22 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Embedding images directly into Markdown posts -- terrible idea?]]></title><description><![CDATA[<p>This might turn out to be a terrible idea, but in pursuit of self-contained Markdown-based blog posts, I&#39;m going to try embedding images (and, maybe later, other assets) directly into my Markdown posts.</p>
<h1 id="background">Background</h1>
<p>Most blogging platforms I&#39;ve looked at support inserting images into posts as follows:</p>
<ul>
<li>Images are uploaded to a specific location</li>
<li>Output HTML files reference the images (ideally using relative links)</li>
</ul>
<p>This is great if an image needs to be shared between posts, but that&#39;s not the typical use case. In the usual case, I see images used once in a single post.</p>
<p>As a <em>viewer</em> I like this setup because the images can be loaded lazily, I can open the image link in a new tab, etc.</p>
<h1 id="gripes">Gripes</h1>
<p>As an author, however, I have some complaints about this setup because posts and images become coupled:</p>
<ul>
<li>I have to add multiple files to build a particular post</li>
<li>If I want to remove a post, I have to also remove the images it contains</li>
<li>Probably not common, but if I want to duplicate a post elsewhere, I have to grab the images as well</li>
</ul>
<h1 id="my-previous-solution">My previous solution</h1>
<p>In the past, my solution to this problem was to build a directory for each post and the directory contained both the post content as well as any associated images and files.</p>
<p>This is, in my opinion, a pretty reasonable solution because now the entire post is contained in a single location. If my crazy new idea doesn&#39;t work, I&#39;ll probably revert to this tried and true solution.</p>
<h1 id="directly-embedding-images">Directly embedding images</h1>
<p>So here&#39;s my crazy idea: what if I embed images directly into their source Markdown files using <a href="https://en.wikipedia.org/wiki/Base64">Base64-encoded</a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URLs</a>?</p>
<p>Data URLs are only recommended for small files (ideally &lt; 1 KB), but my research indicates that this recommendation is based on:</p>
<ol>
<li>Separating essential HTML/text content from slightly less important image content</li>
<li>Some HTML/XML implementations arbitrarily limiting the size of an element and its attributes</li>
</ol>
<p>I happen to agree with #1, so when compiling my site I do plan to split out images into their own files. But #2 feels like a vestigial limitation from the days of allocating fixed size buffers on the stack in C code. That&#39;s not to say #2 won&#39;t cause me trouble--I just don&#39;t think it&#39;s a good enough reason on its own to discard my idea.</p>
<h2 id="prototype-encoder">Prototype encoder</h2>
<p>Here&#39;s the code for my prototype encoder (side note: I don&#39;t know why Node refused to accept the clearly documented &quot;base64url&quot; encoding):</p>
<pre><code>const path = require(&quot;path&quot;);
const fs = require(&quot;fs/promises&quot;);

// TODO: Use a more comprehensive library
const fileExtensionToMimeType = {
    &quot;.jpg&quot;: &quot;image/jpeg&quot;,
    &quot;.png&quot;: &quot;image/png&quot;,
};

(async () =&gt; {
    try
    {
        const filePath = process.argv[2];
        if (!filePath) throw &quot;No path specified!&quot;;

        const fileExtension = path.extname(filePath);
        const mimeType = fileExtensionToMimeType[fileExtension];
        if (!mimeType) throw `Could not determine MIME type for extension &quot;${fileExtension}&quot;!`;

        const buffer = await fs.readFile(filePath);
        const base64UrlEncoded = encodeURI(buffer.toString(&quot;base64&quot;));

        const dataUrl = `data:${mimeType};base64,${base64UrlEncoded}`;
        console.log(dataUrl);
    }
    catch (err) {
        console.error(`ERROR: ${err}`);
    }
})();</code></pre><h2 id="exhibit-a">Exhibit A</h2>
<p>Here&#39;s a very small (in terms of number of bytes) PNG file that&#39;s been directly embedded (this is the ~600 byte <a href="https://en.wikipedia.org/wiki/Favicon">Favicon</a> for my site):</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC" alt="Small embedded PNG file"></p>
<p>Here&#39;s what the Markdown input looks like, for reference:</p>
<pre><code>![Small embedded PNG file](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC)</code></pre><p>I also tested a much larger image file and it worked just as well, but I decided to omit that file from this post because I didn&#39;t want to bloat up this file (and repository) for no good reason.</p>
<h2 id="observations-in-vs-code">Observations in VS Code</h2>
<p>Well, the images render fine in Visual Studio Code&#39;s Markdown Preview window. Syntax highlighting in the Markdown file I&#39;m editing is ok, too. But there is one problem.</p>
<p>I&#39;ve been happily using word-wrapping when editing Markdown files and, unsurprisingly, these enormous strings make word-wrapping pretty much impossible to use. This could end up being fairly annoying. I&#39;ll let this issue marinate in the back of my mind for a bit.</p>
<h2 id="observations-in-githubs-markdown-viewer">Observations in GitHub&#39;s Markdown viewer</h2>
<p>To my surprise, the image did not display at all in GitHub&#39;s Markdown viewer--it just showed a &quot;broken image link&quot; icon. That&#39;s unfortunate because I&#39;d like my site to be as functional as possible when viewed directly on GitHub.</p>
<h2 id="observations-compiling-with-marked">Observations compiling with Marked</h2>
<p>The Markdown appears to have compiled fine using <a href="https://marked.js.org/">Marked</a> (via <a href="https://metalsmith.io/">Metalsmith</a>). It wasn&#39;t noticeably slow or anything either. Great!</p>
<h2 id="observations-viewing-the-resulting-html-in-chromium-based-edge">Observations viewing the resulting HTML in Chromium-based Edge</h2>
<p>Note: as I noted earlier, I&#39;m not normally planning on uploading my static site in this format, but out of sheer curiosity, would this work unmodified?</p>
<p>The images display just fine in my site on Chromium-based Edge. Good to know!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, while I like the idea of having completely self-contained Markdown files, the fact that the images don&#39;t work on GitHub&#39;s Markdown viewer and that the incredibly long text blobs effectively break word-wrapping in VS Code lead me to believe that this was a failed experiment. I don&#39;t think I&#39;ll pursue this method any further.</p>
<p>I&#39;m still happy that I gave it a shot. You never really know until you try!</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/embedded-images</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/embedded-images</guid><pubDate>Tue, 21 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Metalsmith for a simple dev blog]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> to see which is closest to <a href="../overview/">my ideal setup</a>. Next up is <a href="https://metalsmith.io/">Metalsmith</a>.</p>
<p>Spoiler: I really like Metalsmith&#39;s modular design, so much so that I&#39;m now using Metalsmith for this blog.</p>
<h1 id="metalsmith">Metalsmith</h1>
<p>Metalsmith is a Node-based static site generator with a modular architecture that relies on many small plugins (similar in style to <a href="https://gulpjs.com/">gulp</a>). Installation is done via NPM (but note that you&#39;ll likely need to track down and install many plugins).</p>
<h2 id="architecture">Architecture</h2>
<p>Metalsmith is configured using plain old JavaScript code and building the site is just a matter of running your script, which is especially nice for debugging issues. See their &quot;elevator pitch&quot; on the <a href="https://metalsmith.io/">Metalsmith home page</a> for an example. It&#39;s refreshingly simple and transparent, but you&#39;ll need to install plugins and write some code to get a test server with live reloading (unlike many other modern static site generators that support this out the box).</p>
<p>While vetting and adding plugins is tedious, I like the fact that Metalsmith doesn&#39;t install 500+ packages by default (... like Eleventy).</p>
<p>Thanks to <a href="https://github.com/jstransformers/jstransformer">jstransformer</a>, Metalsmith supports a wide variety of template languages. I&#39;m not a fan of <a href="https://liquidjs.com/">Liquid</a> or <a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>, but I&#39;m trying out <a href="https://handlebarsjs.com/">Handlebars</a> because I find it more intuitive and less verbose. So far, it seems easier to maintain than the plain JavaScript templates I used with <a href="../eleventy-2/">Eleventy</a>.</p>
<h2 id="themes">Themes?</h2>
<p>If you don&#39;t want to author your own HTML templates, Metalsmith honestly doesn&#39;t seem like a good choice. It&#39;s possible to construct a Metalsmith &quot;theme&quot; by combining plugins, configuration, and templates, but really what you&#39;re providing is an entire skeleton project (with a <code>package.json</code> file, build scripts, and so on). This means the result is less portable and more difficult to integrate (unless you&#39;re starting from scratch and don&#39;t have any opinions or constraints).</p>
<p>Other static site generators (e.g. Hugo) abstract out the concept of a theme (along with standard metadata that themes can leverage), so you don&#39;t have to mix code and configuration together with HTML templates and CSS styling. This seems better for people who don&#39;t want total control of every character in their final HTML output.</p>
<h2 id="setup">Setup</h2>
<p><a href="https://metalsmith.io/#introduction">Metalsmith&#39;s home page</a> has a sample script right at the top you can look at, but you&#39;ll end up with a bunch of <code>require(...)</code>s followed by something like this:</p>
<pre><code>Metalsmith(__dirname)
    .metadata({
        site: {
            title: &quot;Schemescape&quot;,
            url: &quot;https://log.schemescape.com/&quot;,
            description: &quot;Development log of a life-long coder&quot;,
        },
    })
    .source(&quot;./content&quot;)
    .destination(&quot;./out&quot;)
    .use(collections({
        posts: {
            pattern: &quot;posts/**/*.md&quot;,
            sortBy: &quot;date&quot;,
            reverse: true,
        }
    }))
    .use(markdown())
    .use(layouts({
        directory: &quot;templates&quot;,
        default: &quot;default.hbs&quot;,
    }))
    ...
    .build(err =&gt; { if (err) throw err; });</code></pre><p>If you just want to build a dev blog like everyone else, it does feel like a lot of boilerplate code, but I like that it forces you to consider and understand each step of the process. Some of the other static site generators were too proactive and did things I didn&#39;t expect or understand (or want). With Metalsmith, it only does exactly what you tell it.</p>
<p>But there&#39;s a dark side to Metalsmith&#39;s simple model, and that&#39;s that Metalsmith has to be taught to do even the most basic things. For example, I&#39;m building my site on Windows, which has the unfortunate property of using backslashes for path separators. Metalsmith doesn&#39;t seem to know or care about this detail, so I had to actually write code to switch to web-friendly forward slashes when creating links between files in different directories.</p>
<h3 id="plugins-plugins-plugins">Plugins, plugins, plugins</h3>
<p>Metalsmith&#39;s modular architecture with a very simple core library means you need plugins--a lot of plugins. Fortunately, most of the functionality I was interested in already existed in the form of published plugins (some official, some third party). Here are the ones I used:</p>
<table>
<thead>
<tr>
<th>Plugin (* = official)</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a>*</td>
<td>Translates Markdown to HTML (using <a href="https://marked.js.org/">Marked</a>)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-drafts">metalsmith-drafts</a>*</td>
<td>Excludes files marked &quot;draft: true&quot; in YAML front matter (yep, you need a plugin for this)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-collections">metalsmith-collections</a>*</td>
<td>Groups and sorts files by path (e.g. for listing blog posts)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-permalinks">metalsmith-permalinks</a>*</td>
<td>Creates a directory for each HTML file (so links only specify directories and not files)</td>
</tr>
<tr>
<td><a href="https://github.com/metalsmith/metalsmith-layouts">metalsmith-layouts</a>*</td>
<td>Adds support for templates using <a href="https://github.com/jstransformers">jstransformers</a></td>
</tr>
<tr>
<td><a href="https://github.com/jstransformers/jstransformer-handlebars">jstransformer-handlebars</a>*</td>
<td>Adds support for <a href="https://handlebarsjs.com/">Handlebars</a></td>
</tr>
<tr>
<td><a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a></td>
<td>Copies static assets (e.g. CSS and my &quot;CNAME&quot; file)</td>
</tr>
<tr>
<td><a href="https://github.com/radiovisual/metalsmith-rootpath">metalsmith-rootpath</a></td>
<td>Computes the path to root of each page (allowing you to use relative links to CSS, etc.)</td>
</tr>
<tr>
<td><a href="https://github.com/timdp/metalsmith-discover-partials">metalsmith-discover-partials</a></td>
<td>Registers <a href="https://handlebarsjs.com/guide/partials.html">Handlebar partials</a> (for reusing/nesting templates)</td>
</tr>
<tr>
<td><a href="https://github.com/hurrymaplelad/metalsmith-feed">metalsmith-feed</a></td>
<td>Creates an RSS feed from a collection</td>
</tr>
<tr>
<td><a href="https://github.com/davidxmoody/metalsmith-broken-link-checker">metalsmith-broken-link-checker</a></td>
<td>Validates relative links in the final site</td>
</tr>
<tr>
<td><a href="https://github.com/chiefy/metalsmith-express">metalsmith-express</a></td>
<td>Runs a test server for local testing (with live reloading)</td>
</tr>
<tr>
<td><a href="https://github.com/FWeinb/metalsmith-watch">metalsmith-watch</a></td>
<td>Triggers rebuilds when files are updated (needed for live reloading)</td>
</tr>
</tbody></table>
<p>Note that some of the plugins I installed had dependencies flagged by NPM as having vulnerabilities. I reviewed the notices and none seemed concerning for my use case (e.g. all of the input is code/content I wrote and I don&#39;t plan on targeting myself for a regular expression denial of service attack).</p>
<h3 id="missing-plugins">Missing plugins</h3>
<p>Despite all these great plugins, I did end up needing to add a little extra functionality. Theoretically, these could be packaged into plugins.</p>
<ul>
<li>Translate relative <code>*.md</code> links to point to the corresponding output directories</li>
<li>Compute relative link paths, with forward slashes only (Metalsmith only provides the source path by default)</li>
<li>A &quot;no-op&quot; plugin for conditional inclusion of plugins without breaking up the giant configuration chain</li>
</ul>
<h2 id="issues">Issues</h2>
<p>Here are a couple of snags I hit while integrating Metalsmith into my site.</p>
<h3 id="inflexible-directory-structure">Inflexible directory structure</h3>
<p>For how simple Metalsmith is, I figured it would allow for a flexible directory structure, but Metalsmith actually only allows a single source directory by default. This is a problem for my directory structure because I separated all of my content (Markdown files) from files needed to build the web site (scripts, templates, but also CSS). Fortunately, the <a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a> plugin handle this scenario:</p>
<pre><code>const assets = require(&quot;metalsmith-static&quot;);

Metalsmith
...
    .use(assets({
        src: &quot;static&quot;,
        dest: &quot;.&quot;,
    }))</code></pre><h3 id="destination-paths-arent-available">Destination paths aren&#39;t available</h3>
<p>Somewhere in Metalsmith&#39;s pipeline, it knows where a file is going to end up, but for some inexplicable reason, this information isn&#39;t available to templates or plugins. In my case, it&#39;s easy to infer the destination (although I had to deal with Windows&#39; annoying path-separating backslashes), so it wasn&#39;t a big deal, but this really isn&#39;t something I should have had to think about.</p>
<h3 id="plugin-ordering">Plugin ordering</h3>
<p>Since plugins enrich and mutate files and metadata along the way, the ordering of plugins matters. One annoying interaction was between the &quot;layouts&quot; (templating) and &quot;feed&quot; (RSS) plugins:</p>
<ul>
<li>&quot;Feed&quot; then &quot;layouts&quot;: the RSS feed gets wrapped in HTML (&quot;layouts&quot; is run on <em>every</em> file by default)</li>
<li>&quot;Layouts&quot; then &quot;feed&quot;: the RSS content for each post is now a full HTML page, because templates were already applied</li>
</ul>
<p>The fix in this case was to run &quot;layouts&quot; after &quot;feed&quot; but tell &quot;layouts&quot; to only process HTML files (and not &quot;feed.xml&quot;).</p>
<p>This all makes sense if you think about how Metalsmith plugins receive a set of files, manipulate them, and then pass them on to the next plugin, but other generators do a good job of insulating me from mistakes like this.</p>
<h3 id="handling-internal-links">Handling internal links</h3>
<p>I&#39;m still surprised that using relative links to Markdown files for internal linking between posts isn&#39;t well supported by the static site generators I&#39;ve tried so far (Metalsmith included). I ended up having to extend the <a href="https://marked.js.org/using_pro#renderer">Marked renderer</a> to enable internal links:</p>
<pre><code>const marked = require(&quot;marked&quot;);
...
// Translate relative Markdown links to point to corresponding HTML output files
const markdownRenderer = new marked.Renderer();
const baseLinkRenderer = markdownRenderer.link;
markdownRenderer.link = function (href, title, text) {
    return baseLinkRenderer.call(this,
        href.replace(/^([^/][^:]*)\.md(#[^#]+)?$/, &quot;../$1/$2&quot;),
        title,
        text);
};
...
Metalsmith
...
    .use(markdown({ renderer: markdownRenderer }))
    .use(permalinks())</code></pre><p><strong>Update</strong>: I realized I also want to be able to link to a heading <em>within</em> another post (examples: <a href="#architecture">link to Architecture heading in this post</a>; <a href="../comparison/#metalsmith">link to my initial impression of Metalsmith in a different post</a>). The code above has been updated to handle this case.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Overall, I really liked that Metalsmith just did exactly what I asked, even if I didn&#39;t initially know what, precisely, I wanted. I was able to find plugins for almost everything to get started (including local testing with live reloading). Importantly, I also feel like I fully understand what Metalsmith is doing, so I don&#39;t have to worry about later discovering that it was processing files multiple times (something that did happen with Eleventy).</p>
<p>Additionally, because Metalsmith is so simple to extend, I can actually foresee myself writing a plugin to, say, add inline diagrams that are automatically converted to SVG at build time (a feature that&#39;s part of my <a href="../overview/">my ideal workflow</a>).</p>
<p>One comment on Handlebars: this isn&#39;t a review of Handlebars, but I did find Handlebars to be a surprisingly agreeable template language. This is actually high praise coming from me, since I find most template languages to be hideous and verbose. Only annoyance is that the automatic indentation isn&#39;t always what you want (e.g. in the case of <code>&lt;pre&gt;</code> blocks).</p>
<p>Overall, I&#39;m very happy with Metalsmith, and it&#39;s likely that I will be using it moving forward. <strong>Update</strong>: I switched from Eleventy to Metalsmith.</p>
<p>For reference, all of my code is here:
<a href="https://github.com/jaredkrinke/log">https://github.com/jaredkrinke/log</a></p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith</guid><pubDate>Sat, 18 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[How to benchmark disk drives on Windows]]></title><description><![CDATA[<p>My computer (running Windows) has multiple drives in it and I was wondering which drive is actually the fastest. Fortunately, there&#39;s an app for that.</p>
<h1 id="background">Background</h1>
<p>In the past, I kept up to date on computer hardware (because, let&#39;s be honest, games), but I&#39;ve been lazy for the past decade or so.</p>
<p>I recently inherited some new parts and now I&#39;ve got 3 drives:</p>
<ol>
<li>Cheapo solid state drive I bought off Newegg a few years back</li>
<li>1 TB rotational drive I salvaged from a discarded Western Digital My Book</li>
<li>Fancy new non-volatile memory (NVMe) drive</li>
</ol>
<p>My limited understanding tells me that the NVMe drive should be the fastest and that the rotational drive should be incredibly slow in comparison.</p>
<h1 id="benchmarking-with-diskspd">Benchmarking with DiskSpd</h1>
<p>Enter <a href="https://github.com/Microsoft/diskspd/wiki">DiskSpd</a>, an official disk benchmarking tool from Microsoft. It&#39;s just an executable that you download and run (as administrator).</p>
<p>It has <a href="https://github.com/Microsoft/diskspd/wiki/Command-line-and-parameters">a lot of command line options</a>, but <a href="https://www.windowscentral.com/how-test-hard-drive-performance-diskspd-windows-10">a random article I found directed me to the most relevant ones</a>.</p>
<p>In my case, I&#39;m just interested in read performance, so I ran the following two commands (the first, <code>-s</code>, is for sequential reads and the second, <code>-r</code>, is for random reads):</p>
<pre><code>diskspd -d10 -c128M -t1 -o1 -Sh -w0 -s d:\tmp.dat
diskspd -d10 -c128M -t1 -o1 -Sh -w0 -r d:\tmp.dat</code></pre><p>These tests run:</p>
<ul>
<li>For 10 seconds</li>
<li>On a 128 MB test file (which DiskSpd leaves behind after it finishes)</li>
<li>On a single thread</li>
<li>With one operation outstanding</li>
<li>Without write caching (probably unnecessary for read tests)</li>
<li>0% of operations are writes</li>
<li>In sequential or random access, as indicated</li>
<li>On a file named d:\tmp.dat (I change the drive letter for each drive, obviously)</li>
</ul>
<h1 id="results">Results</h1>
<table>
<thead>
<tr>
<th>Drive</th>
<th align="right">Sequential (MB/s)</th>
<th align="right">Random (MB/s)</th>
</tr>
</thead>
<tbody><tr>
<td>SATA SSD</td>
<td align="right">190</td>
<td align="right">130</td>
</tr>
<tr>
<td>Rotational</td>
<td align="right">55</td>
<td align="right">8</td>
</tr>
<tr>
<td>NVMe</td>
<td align="right">550</td>
<td align="right">530</td>
</tr>
</tbody></table>
<p>As expected, the NVMe drive was the fastest and the rotational drive was the slowest (especially for random reads)... but the actual gaps are enormous!</p>
<p>I guess if I ever get to a point where I have a project that is big enough that disks become the bottleneck, I can just throw everything over onto the NVMe and enjoy a ~3x speedup. Good to know!</p>
]]></description><link>https://log.schemescape.com/posts/hardware/benchmarking-drives</link><guid isPermaLink="true">https://log.schemescape.com/posts/hardware/benchmarking-drives</guid><pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>