<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2021-12-19T02:42:18.210Z</updated>

<entry>
<title>One month with Deno (part 2)</title>
<id>https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html"/>
<updated>2021-12-13T00:00:00.000Z</updated>
<summary type="text">I made the switch from Node to Deno recently. Here are the problems with Deno I&apos;ve encountered.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/web-development/one-month-with-deno.html&quot;&gt;part 1&lt;/a&gt;, I gushed over Deno&amp;#39;s benefits, including sand-boxing, native TypeScript support, a simple module registry, and more. Here&amp;#39;s part 2 (which paints a less rosy picture).&lt;/p&gt;
&lt;h1 id=&quot;problems-with-deno&quot;&gt;Problems with Deno&lt;/h1&gt;
&lt;p&gt;Using Deno has come with some significant challenges. Here are the top issues I&amp;#39;ve faced using Deno for the last month. The good news is that people are working on addressing most of these.&lt;/p&gt;
&lt;h2 id=&quot;existing-typescript-modules-dont-work&quot;&gt;Existing TypeScript modules don&amp;#39;t work&lt;/h2&gt;
&lt;p&gt;Wait, I thought Deno had native TypeScript support. What do you mean TypeScript modules don&amp;#39;t work?&lt;/p&gt;
&lt;p&gt;What I mean is that most TypeScript code that wasn&amp;#39;t written specifically for Deno will (generally) not run unmodified in Deno. This is an unfortunate situation because it means that leveraging existing libraries written in TypeScript is nontrivial. The problem arises from two incompatible stances:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deno imports modules by full name (or URL), with &lt;a href=&quot;https://deno.land/manual@v1.16.4/typescript/faqs&quot;&gt;no magical resolution&lt;/a&gt;, so file extensions (or special HTTP headers) are required&lt;/li&gt;
&lt;li&gt;TypeScript &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/27481&quot;&gt;doesn&amp;#39;t change import specifiers&lt;/a&gt;, so it insists (or rather it used to insist) that file extensions be omitted (so the runtime can find and load the resulting &lt;code&gt;.js&lt;/code&gt; files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regardless of which stance is more righteous, the fact is that existing TypeScript code doesn&amp;#39;t work in Deno unless you do work (e.g. adding &lt;code&gt;.ts&lt;/code&gt; to imports or creating an &lt;a href=&quot;https://deno.land/manual@v1.16.4/linking_to_external_code/import_maps&quot;&gt;import map&lt;/a&gt;). There isn&amp;#39;t even any agreement on the best way to work around this annoyance. The trend to Deno-ify TypeScript modules from NPM and publish them on deno.land/x is not encouraging.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s a bit sad because, other than this issue, Deno provides the best tooling for TypeScript I&amp;#39;ve encountered.&lt;/p&gt;
&lt;h2 id=&quot;node-packages-generally-require-third-party-code&quot;&gt;Node packages generally require third party code&lt;/h2&gt;
&lt;p&gt;Ok, so non-Deno TypeScript libraries are out, what about non-Node-specific JavaScript packages on NPM?&lt;/p&gt;
&lt;p&gt;First of all, Deno only supports ES modules (instead of CommonJS), so only packages that are shipped as modules could possibly work unmodified.&lt;/p&gt;
&lt;p&gt;Additionally, if you&amp;#39;re planning to publish a Deno module you don&amp;#39;t have the luxury of using Deno&amp;#39;s &lt;a href=&quot;https://deno.land/manual@v1.16.4/npm_nodejs/compatibility_mode&quot;&gt;Node compatibility mode&lt;/a&gt; or using import maps to support dependencies, so you&amp;#39;re stuck trying to bridge the gap between Deno&amp;#39;s &amp;quot;no magic&amp;quot; module resolution algorithm and Node&amp;#39;s &amp;quot;nothing &lt;em&gt;but&lt;/em&gt; magic&amp;quot; approach.&lt;/p&gt;
&lt;p&gt;Once again, I didn&amp;#39;t see a great option for handling this, especially if you want to leverage &lt;a href=&quot;https://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; declarations. The Deno documentation recommends using third party content delivery services, but I currently have no way to vet these CDNs.&lt;/p&gt;
&lt;p&gt;I won&amp;#39;t describe the approach I ended up using to work around this problem because it is, frankly, a terrible (and manual) hack.&lt;/p&gt;
&lt;h2 id=&quot;standard-library-licenses-arent-uniform&quot;&gt;Standard library licenses aren&amp;#39;t uniform&lt;/h2&gt;
&lt;p&gt;Deno has a standard library! Hooray! Now we can all use the code in whatever project we want as long as we include Deno&amp;#39;s copyright notice...&lt;/p&gt;
&lt;p&gt;...except that the library wasn&amp;#39;t entirely written by the Deno authors, so many of the modules have different copyright notices (e.g. &lt;a href=&quot;https://deno.land/std@0.117.0/encoding/yaml.ts&quot;&gt;std/encoding/yaml.ts&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;This means that you have to track down all of your dependencies and diligently duplicate their copyright notices in tools created with &lt;code&gt;deno compile&lt;/code&gt;. At least Deno restricts contributions to the permissive MIT, BSD, and Apache licenses!&lt;/p&gt;
&lt;h2 id=&quot;webassembly-isnt-seamless&quot;&gt;WebAssembly isn&amp;#39;t seamless&lt;/h2&gt;
&lt;p&gt;Deno currently loads WebAssembly using &lt;code&gt;fetch&lt;/code&gt; (just like in the browser). This sounds like a great idea except for the fact that it requires network and/or file system access. Unfortunately, this means that if you want to use WebAssembly in a library, you have two unappealing options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tell consumers that they need to pass &lt;code&gt;--allow-read&lt;/code&gt; or &lt;code&gt;--allow-net&lt;/code&gt; in when using your library (negating some of the security benefits of Deno)&lt;/li&gt;
&lt;li&gt;Or Base64-encode your module into an obnoxiously huge TypeScript file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deno used to support statically importing WebAssembly (without requiring additional privileges), but that support was removed on the assumption that a forthcoming web standard will eventually solve this problem. Last I read, this is still an open problem.&lt;/p&gt;
&lt;h2 id=&quot;bundling-only-emits-javascript&quot;&gt;Bundling only emits JavaScript&lt;/h2&gt;
&lt;p&gt;Deno &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/bundler&quot;&gt;comes with a simple bundler&lt;/a&gt;! Unfortunately, it only emits JavaScript, so you can&amp;#39;t use it for packaging a TypeScript module into a single file (because you&amp;#39;d lose all your type information).&lt;/p&gt;
&lt;p&gt;I have yet to find a bundler for TypeScript. I really hope I won&amp;#39;t have to write one myself!&lt;/p&gt;
&lt;h2 id=&quot;theres-no-standard-way-to-specify-long-command-lines&quot;&gt;There&amp;#39;s no standard way to specify long command lines&lt;/h2&gt;
&lt;p&gt;I applaud Deno for forcing users to provide permissions on the command line, but those command lines can get pretty long. Additionally, Deno seems to be allergic to configuration files, so instead of putting commands into a configuration file, we just have no standard, cross-platform way to specify how to run code.&lt;/p&gt;
&lt;h2 id=&quot;the-formatter-produces-ugly-code&quot;&gt;The formatter produces ugly code&lt;/h2&gt;
&lt;p&gt;I like the idea of Deno having a built-in formatter, but I don&amp;#39;t actually like the output. For example, the default is to use 2 spaces for indentation. I don&amp;#39;t know anyone (outside of Deno) who prefers 2 spaces over 4 spaces. I find it makes code harder to read. Additionally, the formatter inserts spaces and newlines in surprising places (again, making the code harder to read).&lt;/p&gt;
&lt;p&gt;I appreciate that automatic code formatting is a difficult problem and that style is usually personal preference, but this is the first formatter I&amp;#39;ve seen that I don&amp;#39;t like.&lt;/p&gt;
&lt;h2 id=&quot;bugs-bugs-bugs&quot;&gt;Bugs, bugs, bugs&lt;/h2&gt;
&lt;p&gt;Deno is a remarkable project and I really enjoy it, but I have encountered several critical bugs, just in my first month of use. My favorite two examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Correct&lt;/em&gt; code &lt;em&gt;failing&lt;/em&gt; type checking (due to a caching issue)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Incorrect&lt;/em&gt; code &lt;em&gt;successfully&lt;/em&gt; type checking (due to type checking being unexpectedly skipped)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;so-will-i-keep-using-deno&quot;&gt;So will I keep using Deno?&lt;/h1&gt;
&lt;p&gt;More than once, I&amp;#39;ve wondered if working around the limitations of Deno is costing me more time than I&amp;#39;m saving by using Deno. It very well might.&lt;/p&gt;
&lt;p&gt;In the end, however, I plan to continue using Deno because it provides the best TypeScript runtime I&amp;#39;ve seen, and its features (and most of its goals) align with my needs and preferences.&lt;/p&gt;
</content>
</entry>
<entry>
<title>One month with Deno (the good parts)</title>
<id>https://log.schemescape.com/posts/web-development/one-month-with-deno.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/one-month-with-deno.html"/>
<updated>2021-12-06T00:00:00.000Z</updated>
<summary type="text">I made the switch from Node to Deno recently. Here&apos;s what I&apos;ve liked after a month of using Deno.</summary>
<content type="html">&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;After &lt;a href=&quot;https://log.schemescape.com/posts/web-development/souring-on-npm.html&quot;&gt;souring on NPM&lt;/a&gt; (due to unnecessarily huge dependency trees and security concerns), I decided to give &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt; a try. Deno supports sand-boxing, TypeScript, and ES modules out of the box. Deno has a standard library, along with a simple and transparent module registry, and also comes with with handy tools for bundling and static analysis.&lt;/p&gt;
&lt;h1 id=&quot;what-ive-liked-about-deno&quot;&gt;What I&amp;#39;ve liked about Deno&lt;/h1&gt;
&lt;h2 id=&quot;sand-boxing&quot;&gt;Sand-boxing&lt;/h2&gt;
&lt;p&gt;Deno disallows file system access, network access, and other privileges by default. You can provide fine-grained permissions on the command line, e.g. &lt;code&gt;--allow-read=file.txt&lt;/code&gt; will let the script read &lt;code&gt;file.txt&lt;/code&gt; in the current directory.&lt;/p&gt;
&lt;p&gt;In an ideal world this wouldn&amp;#39;t be necessary, but given that hackers have been targeting package registries such as NPM, this is a step in the right direction. As an example, say that I want to find a quick tool to convert a file from one format to another. Here are some options for doing this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the past, you might just try to find a tool for this purpose, download it, and run it.&lt;ul&gt;
&lt;li&gt;Today, that would be a terrible idea because the tool runs as your user and could, in an extreme example, contain ransomware.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In the recent past, you might do essentially the same as above, just downloading from NPM and running in Node.&lt;ul&gt;
&lt;li&gt;Again, very risky.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Without Deno, you could run the tool in a container or VM (or restricted user).&lt;ul&gt;
&lt;li&gt;This can be safe, but inconvenient.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;With Deno, you might just run the tool with no extra privileges.&lt;ul&gt;
&lt;li&gt;If the tool just reads from standard input and writes to standard output, great!&lt;/li&gt;
&lt;li&gt;If the tool has malware that tries to write to the file system or access the network, Deno will block it.&lt;/li&gt;
&lt;li&gt;Of course, this isn&amp;#39;t 100% safe (&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)&quot;&gt;Spectre&lt;/a&gt; worked from inside the web browser&amp;#39;s sand box, after all), but it&amp;#39;s much better than nothing!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Full details on Deno&amp;#39;s permissions are &lt;a href=&quot;https://deno.land/manual@v1.16.4/getting_started/permissions&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;audited-standard-library&quot;&gt;Audited standard library&lt;/h2&gt;
&lt;p&gt;One of the reasons that NPM projects tend to have gigantic dependency trees is that JavaScript (unlike most popular programming languages of today) doesn&amp;#39;t really come with a standard library. This meant that common tasks such as parsing command line arguments are farmed out to dependencies, which then of course pull in whatever dependencies those authors felt like using, and so on until you have hundreds of dependencies (yes, that happened to me pretty quickly).&lt;/p&gt;
&lt;p&gt;Deno brings JavaScript (and TypeScript) into the modern era by &lt;a href=&quot;https://deno.land/std@0.117.0&quot;&gt;providing a standard library&lt;/a&gt; containing code that has been audited by the Deno authors. The library is not yet comprehensive and navigating the documentation is currently unpleasant, but having a set of trusted dependencies that will be maintained by the Deno authors is a relief after coming from the Node/NPM ecosystem.&lt;/p&gt;
&lt;h2 id=&quot;native-typescript-support&quot;&gt;Native TypeScript support&lt;/h2&gt;
&lt;p&gt;I like JavaScript for prototyping, but I like TypeScript and its tooling more. Honestly, if you know what you&amp;#39;re doing, the compiler should be your friend, helpfully pointing out when you&amp;#39;ve made a typo or not quite lined up types across a function or module boundary. The problem with TypeScript for me has always been setting up a development environment and build scripts.&lt;/p&gt;
&lt;p&gt;With Deno, you get the benefits of TypeScript without having to do any special setup. Just use the &lt;code&gt;.ts&lt;/code&gt; file extension, and Deno will automatically type-check, compile, and run your code. You can even publish your module as TypeScript and Deno scripts can consume it without doing anything special.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re interested in TypeScript, but struggled with Node and NPM (and &lt;code&gt;ts-node&lt;/code&gt;, etc.), give Deno a try!&lt;/p&gt;
&lt;h2 id=&quot;web-standard-apis&quot;&gt;Web standard APIs&lt;/h2&gt;
&lt;p&gt;One of the dreams of Node was to write &amp;quot;isomorphic&amp;quot; code that runs both in Node and the browser. Deno brings this one step closer to reality by embracing browser APIs (e.g. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;fetch&lt;/a&gt;). This is helpful because you can learn about the browser while writing code for Deno and vice versa.&lt;/p&gt;
&lt;h2 id=&quot;simple-transparent-module-registry&quot;&gt;Simple, transparent module registry&lt;/h2&gt;
&lt;p&gt;A major complaint I have with most package managers and package registries is that they don&amp;#39;t make it easy to see what is inside a package before downloading it. NPM is especially bad here because, by default, installing a package can run arbitrary scripts, so you might get malware just by trying to check and see if a package contains malware (this is your reminder to enable NPM&amp;#39;s &lt;a href=&quot;https://docs.npmjs.com/cli/v7/commands/npm-install#ignore-scripts&quot;&gt;ignore-scripts&lt;/a&gt; setting).&lt;/p&gt;
&lt;p&gt;Deno&amp;#39;s module registry is &lt;a href=&quot;https://deno.land/x/&quot;&gt;https://deno.land/x/&lt;/a&gt; and all it does is mirror code from GitHub when tags are pushed. This means that you can browse the &lt;em&gt;exact&lt;/em&gt; code you&amp;#39;ll be downloading prior to actually downloading anything. It also automatically generates documentation from JSDoc comments and helpfully displays the list of (static) external dependencies for a given file.&lt;/p&gt;
&lt;p&gt;I do have concerns about tying the module registry so intimately to GitHub, but for now I just like having a transparent registry that takes the guesswork out of auditing dependencies.&lt;/p&gt;
&lt;h2 id=&quot;bundlercompiler-script-installer&quot;&gt;Bundler/compiler, script installer&lt;/h2&gt;
&lt;p&gt;One theme with Deno is that it has a focus on the entire development experience. Sometimes this is called having &amp;quot;batteries included&amp;quot;. For example, one common problem with scripting languages is that sharing a tool usually requires also sharing the entire runtime environment. E.g. if I want to run a Python script, I need a Python environment (in Python&amp;#39;s case, this is probably even true if I already have Python installed, thanks to frequent breaking changes).&lt;/p&gt;
&lt;p&gt;Deno simplifies this by including a &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/compiler&quot;&gt;built in bundler and compiler&lt;/a&gt; that packages up a script, its dependencies, and the Deno runtime into a single (~30 MB) download. Obviously, this isn&amp;#39;t efficient if you&amp;#39;re using a lot of Deno tools, but it&amp;#39;s indispensible if you don&amp;#39;t care about Deno and just want to use one specific Deno-based tool.&lt;/p&gt;
&lt;p&gt;For a more efficient option, Deno also includes a &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/script_installer&quot;&gt;script installer&lt;/a&gt; that allows you to just download and install a specific script (and its dependencies), relying on the version of Deno you already have.&lt;/p&gt;
&lt;p&gt;Together, these mean that if someone wants to use your tool, they have two great options (both of which can be supported without third party tools/plugins):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Just download the self-contained executable and run it,&lt;/li&gt;
&lt;li&gt;Or just install your script with &lt;code&gt;deno install&lt;/code&gt; and run it&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;built-in-support-for-testing-and-code-coverage&quot;&gt;Built-in support for testing and code coverage&lt;/h2&gt;
&lt;p&gt;While &lt;a href=&quot;https://deno.land/manual@v1.16.4/testing&quot;&gt;Deno&amp;#39;s testing framework&lt;/a&gt; isn&amp;#39;t as mature or featureful as some of the Node testing frameworks (although &lt;a href=&quot;https://deno.land/manual@v1.16.4/testing#integration-with-testing-libraries&quot;&gt;integrations with other libraries exist&lt;/a&gt;), there is one advantage: there&amp;#39;s no install or setup required (no more fiddling with dependencies or test scripts!).&lt;/p&gt;
&lt;p&gt;For example, if I want to write some quick unit tests for &lt;code&gt;foo.ts&lt;/code&gt;, I can just create &lt;code&gt;foo.test.ts&lt;/code&gt;, write some tests (see the previous link for example code), and then run &lt;code&gt;deno test&lt;/code&gt;. It will find my test file, run the tests, and print out the results.&lt;/p&gt;
&lt;p&gt;I love it when tools just do what I want without any effort!&lt;/p&gt;
&lt;h1 id=&quot;but-its-not-all-good&quot;&gt;But it&amp;#39;s not all good...&lt;/h1&gt;
&lt;p&gt;Although I&amp;#39;ve found a lot to like about Deno, not everything has been great (or even good... or even acceptable). Stay tuned for part 2: the gripe session.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Designing md2blog 2.0</title>
<id>https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html"/>
<updated>2021-11-10T00:00:00.000Z</updated>
<summary type="text">I hadn&apos;t even released anything yet and I&apos;ve already rewritten md2blog. Here&apos;s why.</summary>
<content type="html">&lt;p&gt;I really didn&amp;#39;t want to do this. I probably shouldn&amp;#39;t have done this. But I did it anyway.&lt;/p&gt;
&lt;p&gt;I created yet another static site generator.&lt;/p&gt;
&lt;h1 id=&quot;the-recent-past&quot;&gt;The recent past&lt;/h1&gt;
&lt;p&gt;After &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/comparison.html&quot;&gt;investigating a bunch of existing static site generators&lt;/a&gt;, I eventually settled on using &lt;a href=&quot;https://metalsmith.io/&quot;&gt;Metalsmith&lt;/a&gt; (and various plugins) to build my static dev blog. I even went so far as to clean up my code in hopes of releasing a zero-config static dev blog generator called &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-design.html&quot;&gt;md2blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But in the end, it just didn&amp;#39;t feel right to publish a tool on NPM with 18 direct dependencies and over 200 transitive dependencies (including &lt;em&gt;6 different file matching libraries&lt;/em&gt;). I&amp;#39;m &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../web-development/souring-on-npm.html&quot;&gt;personally concerned&lt;/a&gt; about the NPM ecosystem&amp;#39;s outrageous dependency trees, and their security implications (Dependency Hell 2.0?), so I decided that I shouldn&amp;#39;t be further contributing to the problem.&lt;/p&gt;
&lt;h1 id=&quot;enter-deno&quot;&gt;Enter Deno&lt;/h1&gt;
&lt;p&gt;Fortunately, as noted in &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../web-development/souring-on-npm.html&quot;&gt;my post about NPM&lt;/a&gt;, there&amp;#39;s a relatively new JavaScript (and TypeScript) runtime with a security focus: &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Deno doesn&amp;#39;t magically make it 100% safe to download and run JavaScript code from anywhere, but it at least tries to provide a secure environment by sand boxing JavaScript programs (similar to what is done in a web browser) and only allowing certain operations if permissions are explicitly granted on the command line, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;$ deno run --allow-read=content,out --allow-write=out main.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additionally, Deno provides a &lt;a href=&quot;https://deno.land/std&quot;&gt;standard library&lt;/a&gt; that has been audited by the Deno authors, so you no longer have to pull in modules from unknown contributors just for common tasks like, say, parsing YAML front matter.&lt;/p&gt;
&lt;p&gt;Deno also has a focus on the full developer experience and includes facilities for testing, static analysis, dependency analysis, stand-alone executables, and more. Again, this means that you don&amp;#39;t have to rely on tens or hundreds of NPM packages just to run some unit tests or publish a stand-alone tool. Oh, and Deno fully embraces &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;, so no more dealing with tedious error-first callback patterns!&lt;/p&gt;
&lt;h1 id=&quot;goodbye-metalsmith&quot;&gt;Goodbye, Metalsmith&lt;/h1&gt;
&lt;p&gt;While Deno has some &lt;a href=&quot;https://deno.land/manual@v1.16.0/npm_nodejs&quot;&gt;facilities for running Node/NPM modules&lt;/a&gt;, I decided that, in order to limit the number of dependencies I take on and to leverage async language features, I would essentially recreate Metalsmith for Deno. Fortunately, Metalsmith is so simple, my prototype was under 150 lines of code.&lt;/p&gt;
&lt;p&gt;For now, I&amp;#39;m calling this module Goldsmith. Here&amp;#39;s how Goldsmith differs from Metalsmith:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Built on Deno and TypeScript instead of Node and JavaScript&lt;ul&gt;
&lt;li&gt;As a result, permissions are limited to only the input and output directories, by default&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Native asynchronous API based on promises&lt;/li&gt;
&lt;li&gt;Will be released alongside a standard library of essential plugins&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;plugins-and-dependencies&quot;&gt;Plugins and dependencies&lt;/h1&gt;
&lt;p&gt;Given that &lt;em&gt;most&lt;/em&gt; of the Metalsmith plugins I was using were trivially simple, I decided that I&amp;#39;d just rewrite the ones I needed from scratch in TypeScript.&lt;/p&gt;
&lt;p&gt;Along the way, I made a few changes to further reduce the number of dependencies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standardized on regular expressions for file matching instead of using various glob libraries&lt;/li&gt;
&lt;li&gt;Replaced Handlebars with a trivially simple template language based on JavaScript&amp;#39;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates&quot;&gt;tagged template literals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Replaced my usage of &lt;a href=&quot;https://lesscss.org/&quot;&gt;Less&lt;/a&gt; with color conversion functions and &lt;code&gt;String.replaceAll()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;current-state-of-the-tool&quot;&gt;Current state of the tool&lt;/h1&gt;
&lt;p&gt;While none of the above libraries are fit for general consumption yet, the page you&amp;#39;re reading was generated with my rewritten Deno-based tool. Other than cleaning up the code, adding tests, and releasing everything, the only functionality that is currently missing is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Command line configuration arguments&lt;/li&gt;
&lt;li&gt;Test web server with automatic reloading&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first one should be easy, and I think the second one shouldn&amp;#39;t be too hard either (hopefully just a matter of injecting a script to connect to a WebSocket that pushes out reload requests based on &lt;a href=&quot;https://doc.deno.land/builtin/stable#Deno.watchFs&quot;&gt;Deno.watchFs()&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: Both of these are now implemented.&lt;/p&gt;
&lt;h1 id=&quot;a-parting-note&quot;&gt;A parting note&lt;/h1&gt;
&lt;p&gt;So there you have it. Depending on how you count, this is either the 4th or 5th static site generator I&amp;#39;ve built. I like to hope this will be my last.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog has been released&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Why I&apos;m starting to sour on Node and NPM</title>
<id>https://log.schemescape.com/posts/web-development/souring-on-npm.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/souring-on-npm.html"/>
<updated>2021-11-05T00:00:00.000Z</updated>
<summary type="text">Node made programming fun for me again, but security concerns might drive me away.</summary>
<content type="html">&lt;h1 id=&quot;node&quot;&gt;Node&lt;/h1&gt;
&lt;p&gt;When I first heard about &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node&lt;/a&gt; back in 2013, I thought it was a silly idea.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build a performant web server &lt;em&gt;based on JavaScript&lt;/em&gt;? Just use C++ instead of throwing all your performance gains at an interpreted language!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Of course, my initial reaction ignored some pertinent factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript is already used on clients (web browsers), so sharing code between client and server would be easier&lt;/li&gt;
&lt;li&gt;There are &lt;em&gt;a lot&lt;/em&gt; of JavaScript developers out there (because it&amp;#39;s basically the only native option for scripting on the web)&lt;/li&gt;
&lt;li&gt;JavaScript is actually surprisingly fast because the demand for fast web browsers is huge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After giving it a try, I found that Node, and the &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;NPM&lt;/a&gt; ecosystem, were pretty enjoyable to work with. And things only improved from there, not least because most of the annoying problems of JavaScript had already been solved in one way or another (NPM for managing dependencies, TypeScript for statically checking types, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; for asynchronous programming, etc.).&lt;/p&gt;
&lt;h1 id=&quot;fast-forward-to-today&quot;&gt;Fast-forward to today&lt;/h1&gt;
&lt;p&gt;Recently, I&amp;#39;ve been happily building my static site generator on top of &lt;a href=&quot;https://metalsmith.io/&quot;&gt;Metalsmith&lt;/a&gt;, although one thing always troubled me. Every time I saw a problem that needed solving, I checked NPM to see if someone had already solved that problem with an (MIT-licensed) package--usually someone had.&lt;/p&gt;
&lt;p&gt;But when I went to install that package, NPM would happily report that it had downloaded quite a few transitive dependencies from some large pool of contributors.&lt;/p&gt;
&lt;h2 id=&quot;example-yargs&quot;&gt;Example: yargs&lt;/h2&gt;
&lt;p&gt;For example, I wanted to parse command line arguments, and I had noticed that &lt;a href=&quot;https://www.npmjs.com/package/yargs&quot;&gt;yargs&lt;/a&gt; was a popular package, so I installed it. According to the previously-linked NPM page, it has 7 dependencies. That&amp;#39;s more than I&amp;#39;d like, but let&amp;#39;s give it a try:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;$ npm install yargs

+ yargs@17.2.1
added 16 packages from 10 contributors and audited 16 packages in 1.326s

2 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait, &lt;em&gt;sixteen&lt;/em&gt; packages? Apparently NPM only counts direct dependencies on package pages. What all got installed?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;$ npm ls
...
`-- yargs@17.2.1
  +-- cliui@7.0.4
  | +-- string-width@4.2.3 deduped
  | +-- strip-ansi@6.0.1
  | | `-- ansi-regex@5.0.1
  | `-- wrap-ansi@7.0.0
  |   +-- ansi-styles@4.3.0
  |   | `-- color-convert@2.0.1
  |   |   `-- color-name@1.1.4
  |   +-- string-width@4.2.3 deduped
  |   `-- strip-ansi@6.0.1 deduped
  +-- escalade@3.1.1
  +-- get-caller-file@2.0.5
  +-- require-directory@2.1.1
  +-- string-width@4.2.3
  | +-- emoji-regex@8.0.0
  | +-- is-fullwidth-code-point@3.0.0
  | `-- strip-ansi@6.0.1 deduped
  +-- y18n@5.0.8
  `-- yargs-parser@20.2.9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What&amp;#39;s &lt;code&gt;escalade&lt;/code&gt;? Why do I need &lt;code&gt;emoji-regex&lt;/code&gt; if I&amp;#39;m not planning on using emoji? What do the 18 missing characters in &lt;code&gt;y18n&lt;/code&gt; stand for?&lt;/p&gt;
&lt;p&gt;Well, I&amp;#39;d better get busy reviewing all that JavaScript code. How much code are we talking?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;$ find -name *.js|xargs wc -l
    10 ./node_modules/ansi-regex/index.js
   163 ./node_modules/ansi-styles/index.js
   287 ./node_modules/cliui/build/lib/index.js
    27 ./node_modules/cliui/build/lib/string-utils.js
   839 ./node_modules/color-convert/conversions.js
    81 ./node_modules/color-convert/index.js
    97 ./node_modules/color-convert/route.js
   152 ./node_modules/color-name/index.js
     6 ./node_modules/emoji-regex/es2015/index.js
     6 ./node_modules/emoji-regex/es2015/text.js
     6 ./node_modules/emoji-regex/index.js
     6 ./node_modules/emoji-regex/text.js
    22 ./node_modules/escalade/dist/index.js
    18 ./node_modules/escalade/sync/index.js
    21 ./node_modules/get-caller-file/index.js
    50 ./node_modules/is-fullwidth-code-point/index.js
    86 ./node_modules/require-directory/index.js
    47 ./node_modules/string-width/index.js
     4 ./node_modules/strip-ansi/index.js
   216 ./node_modules/wrap-ansi/index.js
     6 ./node_modules/y18n/build/lib/cjs.js
   174 ./node_modules/y18n/build/lib/index.js
    19 ./node_modules/y18n/build/lib/platform-shims/node.js
    62 ./node_modules/yargs/build/lib/argsert.js
   432 ./node_modules/yargs/build/lib/command.js
    48 ./node_modules/yargs/build/lib/completion-templates.js
   200 ./node_modules/yargs/build/lib/completion.js
    91 ./node_modules/yargs/build/lib/middleware.js
    32 ./node_modules/yargs/build/lib/parse-command.js
     9 ./node_modules/yargs/build/lib/typings/common-types.js
     1 ./node_modules/yargs/build/lib/typings/yargs-parser-types.js
   568 ./node_modules/yargs/build/lib/usage.js
    59 ./node_modules/yargs/build/lib/utils/apply-extends.js
     5 ./node_modules/yargs/build/lib/utils/is-promise.js
    34 ./node_modules/yargs/build/lib/utils/levenshtein.js
    17 ./node_modules/yargs/build/lib/utils/maybe-async-result.js
    10 ./node_modules/yargs/build/lib/utils/obj-filter.js
    17 ./node_modules/yargs/build/lib/utils/process-argv.js
    12 ./node_modules/yargs/build/lib/utils/set-blocking.js
    10 ./node_modules/yargs/build/lib/utils/which-module.js
   305 ./node_modules/yargs/build/lib/validation.js
  1483 ./node_modules/yargs/build/lib/yargs-factory.js
     7 ./node_modules/yargs/build/lib/yerror.js
    14 ./node_modules/yargs/helpers/index.js
    29 ./node_modules/yargs-parser/browser.js
    59 ./node_modules/yargs-parser/build/lib/index.js
    65 ./node_modules/yargs-parser/build/lib/string-utils.js
    40 ./node_modules/yargs-parser/build/lib/tokenize-arg-string.js
    12 ./node_modules/yargs-parser/build/lib/yargs-parser-types.js
  1037 ./node_modules/yargs-parser/build/lib/yargs-parser.js
  7001 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wow. &lt;strong&gt;Roughly 7,000 lines of code just for parsing arguments&lt;/strong&gt;. And it could be worse!&lt;/p&gt;
&lt;h2 id=&quot;malware&quot;&gt;Malware&lt;/h2&gt;
&lt;p&gt;As I read in &lt;a href=&quot;https://therecord.media/malware-found-in-coa-and-rc-two-npm-packages-with-23m-weekly-downloads/&quot;&gt;an article&lt;/a&gt; today (and similar articles in the recent past), NPM has the questionable default behavior of allowing packages to run arbitrary scripts at install time. Ideally, this would be for life cycle management operations such as building caches or compiling native code, but this is also an easy target for hackers to hijack a commonly-installed package&amp;#39;s maintainer&amp;#39;s account and push out an update with malware that is triggered on install.&lt;/p&gt;
&lt;p&gt;Obviously, there&amp;#39;s no perfect solution for NPM to stop such attacks, but right now the default behavior of NPM (no version specification required, running scripts on install, not making it easy to inspect the contents of a package before downloading) means that if you want to install a package that solves a problem, now you need to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vet the maintainers of the package &lt;em&gt;and all its dependencies&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Install the package with &lt;code&gt;--ignore-scripts&lt;/code&gt; to download the code&lt;/li&gt;
&lt;li&gt;Inspect the code of the package &lt;em&gt;and all dependencies&lt;/em&gt; for stowaway malware&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;package-lock.json&lt;/code&gt; in the project to keep versions identical&lt;ul&gt;
&lt;li&gt;And also pin that version when you use the same package elsewhere&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And, of course, this should ideally be done with each update to any of the packages, especially when security updates are made.&lt;/p&gt;
&lt;h1 id=&quot;now-what&quot;&gt;Now what?&lt;/h1&gt;
&lt;p&gt;At this point, you should be able to picture the joy of programming in 2021 rapidly fading from my face. What can be done about this?&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not holding out hope for NPM to make a breaking change that turns install scripts from &lt;em&gt;opt out&lt;/em&gt; to &lt;em&gt;opt in&lt;/em&gt; (not that this would solve the problem anyway, although I&amp;#39;d consider it a welcome concession to security). I&amp;#39;m also not expecting all the packages on NPM to start weeding out unnecessary dependencies just to make my life easier (although kudos to the author of Chokidar for &lt;a href=&quot;https://paulmillr.com/posts/chokidar-3-save-32tb-of-traffic/&quot;&gt;reducing that package&amp;#39;s dependencies down to just the essentials&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Honestly, I think the solution is probably going to be for me to move to a more security-focused ecosystem.&lt;/p&gt;
&lt;h2 id=&quot;deno&quot;&gt;Deno&lt;/h2&gt;
&lt;p&gt;An alternative (an arguably a successor) to Node is &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt; (initiated by the same person who created Node, Ryan Dahl). Deno appears to be aimed at all of the problems I&amp;#39;m running into with Node/NPM (copy-pasted from the Deno home page):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Secure by default. No file, network, or environment access, unless explicitly enabled.&lt;/li&gt;
&lt;li&gt;Supports TypeScript out of the box.&lt;/li&gt;
&lt;li&gt;Ships only a single executable file.&lt;/li&gt;
&lt;li&gt;Has built-in utilities like a dependency inspector (deno info) and a code formatter (deno fmt).&lt;/li&gt;
&lt;li&gt;Has a set of reviewed (audited) standard modules that are guaranteed to work with Deno: deno.land/std&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;m especially excited about how granular the &lt;a href=&quot;https://deno.land/manual@v1.15.3/getting_started/permissions&quot;&gt;permissions flags&lt;/a&gt; are, for example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;--allow-read=&amp;lt;allow-read&amp;gt;&lt;/code&gt; Allow file system read access. You can specify an optional, comma-separated list of directories or files to provide an allow-list of allowed file system access.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Deno also has support for &lt;a href=&quot;https://deno.land/manual@v1.15.3/tools/compiler&quot;&gt;building a self-contained executable&lt;/a&gt;, which would be handy for conveniently distributing binaries (although such binaries would have to be trusted by the people downloading them for now).&lt;/p&gt;
&lt;h1 id=&quot;what-does-this-mean-for-my-current-project&quot;&gt;What does this mean for my current project?&lt;/h1&gt;
&lt;p&gt;I was getting close to publishing my first sizable package to NPM, possibly even today, but now that I&amp;#39;ve stepped back and let the reality of its long list of dependencies sink in, I&amp;#39;m not sure if publishing my project is even a good idea. I originally picked up Node and Metalsmith to speed up the development process (with no plan to eventually release the tool), but along the way I thought it might be a useful thing to share.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll think it over a bit more and decide if I want to be a hypocrite and push out a package with 18 direct dependencies and (ahem) &lt;em&gt;200+ transitive dependencies&lt;/em&gt;, or if I should start over (or abandon the idea of releasing the tool entirely).&lt;/p&gt;
</content>
</entry>
<entry>
<title>NPM requires X11 on Debian. Wait, what?</title>
<id>https://log.schemescape.com/posts/linux/debian-npm-requires-x11.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/linux/debian-npm-requires-x11.html"/>
<updated>2021-11-04T00:00:00.000Z</updated>
<summary type="text">Here&apos;s a rant about that time I tried to install NPM on Debian.</summary>
<content type="html">&lt;h1 id=&quot;debian&quot;&gt;Debian&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.debian.org/&quot;&gt;Debian&lt;/a&gt; has been my preferred Linux distribution for a long time (longer than &lt;a href=&quot;https://ubuntu.com/&quot;&gt;Ubuntu&lt;/a&gt; has even existed).&lt;/p&gt;
&lt;p&gt;The main reason I like Debian is that its &lt;a href=&quot;https://manpages.debian.org/buster/apt/apt.8.en.html&quot;&gt;apt&lt;/a&gt; package manager has been the most reliable package manager I&amp;#39;ve ever dealt with, especially when it comes to removing and/or upgrading packages.&lt;/p&gt;
&lt;h1 id=&quot;npm&quot;&gt;NPM&lt;/h1&gt;
&lt;p&gt;Since I&amp;#39;ve been playing around with Node and NPM on Windows, I decided I should see if one of my tools works on Linux. Fortunately, I was on Debian 11, which ships with a not-&lt;em&gt;completely&lt;/em&gt;-out-of-date Node v12 runtime.&lt;/p&gt;
&lt;p&gt;Great, I&amp;#39;ll just run &lt;code&gt;sudo apt install nodejs npm&lt;/code&gt; and get started! I was immediately greeted with the following wall of packages:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-txt&quot;&gt;$ sudo apt install nodejs npm
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  at-spi2-core dbus-user-session dconf-gsettings-backend dconf-service glib-networking glib-networking-common glib-networking-services gsettings-desktop-schemas gyp javascript-common libatk-bridge2.0-0 libatspi2.0-0 libauthen-sasl-perl
  libc-ares2 libclone-perl libcolord2 libdata-dump-perl libdconf1 libdrm-amdgpu1 libdrm-common libdrm-intel1 libdrm-nouveau2 libdrm-radeon1 libdrm2 libencode-locale-perl libepoxy0 libfile-basedir-perl libfile-desktopentry-perl
  libfile-listing-perl libfile-mimeinfo-perl libfont-afm-perl libfontenc1 libgl1 libgl1-mesa-dri libglapi-mesa libglvnd0 libglx-mesa0 libglx0 libgtk-3-0 libgtk-3-bin libgtk-3-common libhtml-form-perl libhtml-format-perl
  libhtml-parser-perl libhtml-tagset-perl libhtml-tree-perl libhttp-cookies-perl libhttp-daemon-perl libhttp-date-perl libhttp-message-perl libhttp-negotiate-perl libice6 libio-html-perl libio-socket-ssl-perl libio-stringy-perl
  libipc-system-simple-perl libjs-highlight.js libjs-inherits libjs-is-typedarray libjs-psl libjs-typedarray-to-buffer libjson-glib-1.0-0 libjson-glib-1.0-common liblcms2-2 libllvm11 liblua5.3-0 liblwp-mediatypes-perl
  liblwp-protocol-https-perl libmailtools-perl libnet-dbus-perl libnet-http-perl libnet-smtp-ssl-perl libnet-ssleay-perl libnode-dev libnode72 libpciaccess0 libproxy1v5 librest-0.7-0 libsensors-config libsensors5 libsm6
  libsoup-gnome2.4-1 libsoup2.4-1 libssl-dev libtie-ixhash-perl libtimedate-perl libtry-tiny-perl liburi-perl libuv1 libuv1-dev libvte-2.91-0 libvte-2.91-common libvulkan1 libwayland-client0 libwayland-cursor0 libwayland-egl1
  libwww-perl libwww-robotrules-perl libx11-protocol-perl libx11-xcb1 libxaw7 libxcb-dri2-0 libxcb-dri3-0 libxcb-glx0 libxcb-present0 libxcb-randr0 libxcb-shape0 libxcb-sync1 libxcb-xfixes0 libxft2 libxkbcommon0 libxkbfile1
  libxml-parser-perl libxml-twig-perl libxml-xpathengine-perl libxmu6 libxshmfence1 libxt6 libxtst6 libxv1 libxxf86dga1 libxxf86vm1 libz3-4 mesa-vulkan-drivers node-abbrev node-agent-base node-ajv node-ansi node-ansi-regex
  node-ansi-styles node-ansistyles node-aproba node-archy node-are-we-there-yet node-asap node-asn1 node-assert-plus node-asynckit node-aws-sign2 node-aws4 node-balanced-match node-bcrypt-pbkdf node-brace-expansion node-builtins
  node-cacache node-caseless node-chalk node-chownr node-clone node-color-convert node-color-name node-colors node-columnify node-combined-stream node-concat-map node-console-control-strings node-copy-concurrently node-core-util-is
  node-dashdash node-debug node-defaults node-delayed-stream node-delegates node-depd node-ecc-jsbn node-encoding node-err-code node-escape-string-regexp node-extend node-extsprintf node-fast-deep-equal node-forever-agent
  node-form-data node-fs-write-stream-atomic node-fs.realpath node-function-bind node-gauge node-getpass node-glob node-graceful-fs node-gyp node-har-schema node-har-validator node-has-flag node-has-unicode node-hosted-git-info
  node-http-signature node-https-proxy-agent node-iconv-lite node-iferr node-imurmurhash node-indent-string node-inflight node-inherits node-ini node-ip node-ip-regex node-is-typedarray node-isarray node-isexe node-isstream node-jsbn
  node-json-parse-better-errors node-json-schema node-json-schema-traverse node-json-stable-stringify node-json-stringify-safe node-jsonify node-jsonparse node-jsonstream node-jsprim node-leven node-lockfile node-lru-cache node-mime
  node-mime-types node-minimatch node-mkdirp node-move-concurrently node-ms node-mute-stream node-nopt node-normalize-package-data node-npm-bundled node-npm-package-arg node-npmlog node-number-is-nan node-oauth-sign node-object-assign
  node-once node-opener node-osenv node-p-map node-path-is-absolute node-performance-now node-process-nextick-args node-promise-inflight node-promise-retry node-promzard node-psl node-puka node-punycode node-qs node-read
  node-read-package-json node-readable-stream node-request node-resolve node-resolve-from node-retry node-rimraf node-run-queue node-safe-buffer node-semver node-set-blocking node-signal-exit node-slash node-spdx-correct
  node-spdx-exceptions node-spdx-expression-parse node-spdx-license-ids node-sshpk node-ssri node-string-decoder node-string-width node-strip-ansi node-supports-color node-tar node-text-table node-through node-tough-cookie
  node-tunnel-agent node-tweetnacl node-typedarray-to-buffer node-unique-filename node-universalify node-uri-js node-util-deprecate node-uuid node-validate-npm-package-license node-validate-npm-package-name node-verror node-wcwidth.js
  node-which node-wide-align node-wrappy node-write-file-atomic node-yallist nodejs-doc perl-openssl-defaults python3-pkg-resources termit x11-common x11-utils x11-xserver-utils xdg-utils xkb-data
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s a lot more packages than I was expecting. Wait, &lt;code&gt;x11-common&lt;/code&gt;? &lt;code&gt;x11-xserver-utils&lt;/code&gt;? What&amp;#39;s going on here?&lt;/p&gt;
&lt;p&gt;It turns out that &lt;a href=&quot;https://packages.debian.org/bullseye/npm&quot;&gt;Debian&amp;#39;s package for NPM&lt;/a&gt; depends on something called &lt;a href=&quot;https://packages.debian.org/bullseye/node-opener&quot;&gt;node-opener&lt;/a&gt;, which depends on &lt;a href=&quot;https://packages.debian.org/bullseye/xdg-utils&quot;&gt;xdg-utils&lt;/a&gt;, which is described as &amp;quot;desktop integration utilities from freedesktop.org&amp;quot;. Uh oh. Yeah, that depends on X11.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why in the world does a command line package manager depend on a GUI environment?&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;node-opener&quot;&gt;node-opener&lt;/h1&gt;
&lt;p&gt;So what is this &lt;code&gt;node-opener&lt;/code&gt; thing, and does NPM really require it?&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/domenic/opener&quot;&gt;package&amp;#39;s web site&lt;/a&gt; describes it as &amp;quot;Opens stuff, like webpages and files and executables, cross-platform&amp;quot;. I&amp;#39;m still not seeing the relation to NPM. Looking at the code, it&amp;#39;s just a script that calls &lt;code&gt;xdg-open&lt;/code&gt; on Linux (and other commands on Windows and Mac).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/npm/cli/blob/04eb43f2b2a387987b61a7318908cf18f03d97e0/lib/utils/open-url.js&quot;&gt;Peering into NPM&amp;#39;s source code&lt;/a&gt;, I see that it does in fact seem to &lt;code&gt;require(&amp;#39;opener&amp;#39;)&lt;/code&gt;. That&amp;#39;s disappointing.&lt;/p&gt;
&lt;h1 id=&quot;nodesource-to-the-rescue&quot;&gt;NodeSource to the rescue?&lt;/h1&gt;
&lt;p&gt;The official nodejs.org site &lt;a href=&quot;https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions&quot;&gt;mentions&lt;/a&gt; binary distributions &lt;a href=&quot;https://github.com/nodesource/distributions/blob/master/README.md&quot;&gt;from NodeSource&lt;/a&gt;. NodeSource helpfully suggests downloading and running their setup script as root.&lt;/p&gt;
&lt;p&gt;The script appears to mostly do reasonable things like checking for required packages and then updating apt&amp;#39;s &lt;code&gt;sources.list&lt;/code&gt; file, and I guess I&amp;#39;m trusting them with the binaries they&amp;#39;re providing, so I&amp;#39;ll give it a try. They do provide manual install instructions as well.&lt;/p&gt;
&lt;h1 id=&quot;success&quot;&gt;Success&lt;/h1&gt;
&lt;p&gt;I can&amp;#39;t say I&amp;#39;m pleased with this setup, but NodeSource&amp;#39;s Node package did in fact work and now I&amp;#39;ve got &lt;code&gt;node&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands running fine without an X11 installation.&lt;/p&gt;
</content>
</entry>
</feed>
