<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-03-26T23:12:57.048Z</updated>

<entry>
<title>Reflecting on my first release on Steam, SIC-1</title>
<id>https://log.schemescape.com/posts/game-development/sic-1-retrospective.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/sic-1-retrospective.html"/>
<updated>2023-03-25T00:00:00.000Z</updated>
<summary type="text">This is a retrospective on my first game I&apos;ve released on Steam, along with some thoughts about the future.</summary>
<content type="html">&lt;p&gt;It&amp;#39;s been almost four months since I released &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html&quot;&gt;SIC-1&lt;/a&gt; (a single-instruction programming game) for free on Steam (and re-released it &lt;a href=&quot;https://jaredkrinke.itch.io/sic-1&quot;&gt;on itch.io&lt;/a&gt;). This is an update on how the release went, and my plans for the future.&lt;/p&gt;
&lt;h1 id=&quot;financial-summary&quot;&gt;Financial summary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Revenue: $0&lt;/li&gt;
&lt;li&gt;Expenses: $134.07&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SIC-1 can be played by anyone for free (with no ads), so it&amp;#39;s earned a grand total of $0 in revenue. Expenses include a $100 Steam direct fee, and roughly $34 for a year of (completely optional) web hosting.&lt;/p&gt;
&lt;h2 id=&quot;do-i-regret-releasing-sic-1-for-free&quot;&gt;Do I regret releasing SIC-1 for free?&lt;/h2&gt;
&lt;p&gt;I released SIC-1 for free because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Free games attract more players, and I wanted as many players as possible to fill up the charts/leaderboards&lt;/li&gt;
&lt;li&gt;I strongly doubted I would ever earn enough money from SIC-1 to make a meaningful financial difference in my life&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the absolute best case scenario, let&amp;#39;s assume that all 1,800 players on Steam bought the game for my hypothetical full price of $10. Taking out Steam&amp;#39;s 30% fee and another 15% for taxes, that would be a little under $11,000 in my theoretical pocket. An extra $11k actually sounds pretty great! Realistically, however, &lt;a href=&quot;https://vginsights.com/insights/article/infographic-indie-game-revenues-on-steam&quot;&gt;most indie games make less than $4,000 (lifetime)&lt;/a&gt;, and SIC-1 probably would have ended up even lower (on a couple hundred sales, at less than $4 net profit per sale).&lt;/p&gt;
&lt;p&gt;Additionally, if I had wanted to charge for the game on Steam, I would have had to either start charging for the previously free game on itch.io or take that version down entirely. That would feel like a betrayal of existing players. On the flip side, if I had charged for the game, I would have felt like I couldn&amp;#39;t eventually make the game free (or open source) because that might annoy my biggest fans (the ones who actually gave me money). A freemium model might have resolved these problems, but I didn&amp;#39;t want to fragment the player base over a small amount of money.&lt;/p&gt;
&lt;p&gt;In the end, earning some extra money would have been nice from a motivational standpoint, but I think I made the right decision to release the game for free.&lt;/p&gt;
&lt;h1 id=&quot;statistics&quot;&gt;Statistics&lt;/h1&gt;
&lt;h2 id=&quot;steamitchio-statistics&quot;&gt;Steam+itch.io statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;3,500 people started in the in-game tutorial&lt;/li&gt;
&lt;li&gt;1,700 completed the first puzzle&lt;/li&gt;
&lt;li&gt;500 completed the most difficult arithmetic task&lt;/li&gt;
&lt;li&gt;230 completed the first sequence task&lt;/li&gt;
&lt;li&gt;50 completed (correctly) the entire set of sequence puzzles&lt;/li&gt;
&lt;li&gt;30 completed the original set of 30 puzzles&lt;/li&gt;
&lt;li&gt;11 have completed the (new) final puzzle&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;steam-specific-statistics&quot;&gt;Steam-specific statistics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;13,000 free licenses granted&lt;/li&gt;
&lt;li&gt;1,800 lifetime unique users&lt;/li&gt;
&lt;li&gt;20 positive reviews&lt;/li&gt;
&lt;li&gt;Peak concurrent players: 10&lt;/li&gt;
&lt;li&gt;Daily active users peaked at 65 in January and trended down to 10 as of late March&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;statistics-summary&quot;&gt;Statistics summary&lt;/h2&gt;
&lt;p&gt;I made SIC-1 for fun. I knew that the market for programming games was probably pretty small. But I guess I didn&amp;#39;t quite realize &lt;em&gt;how small&lt;/em&gt; that market actually is. Even &lt;a href=&quot;https://www.zachtronics.com/last-call-bbs/&quot;&gt;Last Call BBS&lt;/a&gt;, the most recent (and final) game from &lt;a href=&quot;https://www.zachtronics.com/&quot;&gt;Zachtronics&lt;/a&gt; only has roughly 700 positive reviews (and approximately 22k sales).&lt;/p&gt;
&lt;p&gt;SIC-1 was able to reach 20 positive reviews in four months (with no negative reviews) and &lt;a href=&quot;https://vginsights.com/game/2124440&quot;&gt;Video Game Insights estimates that SIC-1 is in the top 45% for positive reviews and units &amp;quot;sold&amp;quot;&lt;/a&gt;. Given the niche audience and punishing nature of single-instruction programming, that actually sounds pretty good!&lt;/p&gt;
&lt;p&gt;Unfortunately, I didn&amp;#39;t really do any market research before diving into the Steam release for SIC-1, so I&amp;#39;d been hoping for a small single digit multiple of all the numbers above. Oh well, next time I&amp;#39;ll mentally set the bar lower.&lt;/p&gt;
&lt;h1 id=&quot;marketing&quot;&gt;Marketing&lt;/h1&gt;
&lt;p&gt;As SIC-1&amp;#39;s Steam debut approached, I cobbled together a long list of potential marketing activities. For example, sharing the game on sites that are popular with programmers, esolang enthusiasts, and zachlike players. As &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1.html#steam-release&quot;&gt;noted in the previous post&lt;/a&gt;, none of my marketing activities were terribly fruitful, but I was at least heartened to eventually see &lt;em&gt;someone else&lt;/em&gt; organically share my game on the unofficial Zachtronics Discord server (someone even streamed it on Twitch!). Regardless, until late December 2022, just relying on Steam was my best marketing activity (and, spoiler alert, not much has changed).&lt;/p&gt;
&lt;h2 id=&quot;december-2022-traffic-spike&quot;&gt;December 2022 traffic spike&lt;/h2&gt;
&lt;p&gt;After the first few disappointing weeks on Steam, I seriously started to consider shelving the entire project. But one day I saw a large spike in traffic coming from (of all places) GitHub. It took a little bit of searching to find out that &lt;a href=&quot;https://github.com/jaredkrinke/sic1&quot;&gt;SIC-1&amp;#39;s GitHub repository&lt;/a&gt; had been shared on Twitter... by someone will millions of followers!&lt;/p&gt;
&lt;p&gt;Specifically, &lt;a href=&quot;https://twitter.com/notch/status/1604998134354137099&quot;&gt;the original creator of Minecraft, Notch, shared my game&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Zachlike subleq &amp;quot;game&amp;quot; ... I&amp;#39;m going to lose a lot of braincells to this one ... ie, highly recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given that Notch had 3.5 million followers, I thought this might be my big break, and I did get quite a few new players at the time, but the total impact was probably only in the (very) low hundreds of new players. Regardless, it was fairly surreal to see a billionaire live-tweeting about playing my game (during the winter holiday season, no less).&lt;/p&gt;
&lt;h2 id=&quot;positive-rating-on-steam&quot;&gt;&amp;quot;Positive&amp;quot; rating on Steam&lt;/h2&gt;
&lt;p&gt;But it turns out the best marketing for SIC-1 was, again, just to let Steam provide some visibility. Once SIC-1 hit 10 reviews, it got a &amp;quot;Positive&amp;quot; rating and a very large spike in traffic (over 5,000 visitors in one day). The spike has been receding, but I&amp;#39;m still seeing over 100 unique visitors to the Steam page per day.&lt;/p&gt;
&lt;h2 id=&quot;marketing-summary&quot;&gt;Marketing summary&lt;/h2&gt;
&lt;p&gt;All things considered, I should probably be content with where SIC-1 ended up, given the small audience and my apparent lack of marketing prowess, but I can&amp;#39;t shake the feeling that the game didn&amp;#39;t attract as many players as I&amp;#39;d hoped.&lt;/p&gt;
&lt;h1 id=&quot;overall&quot;&gt;Overall&lt;/h1&gt;
&lt;p&gt;Obviously, I learned a lot producing and launching a small (but complete) game on Steam, not limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How Steam works behind the scenes&lt;/li&gt;
&lt;li&gt;How to make a trailer for a game&lt;/li&gt;
&lt;li&gt;How to create Yamaha DX7 music (without owning any synthesizers or spending any money)&lt;/li&gt;
&lt;li&gt;How to write a narrative for a game&lt;/li&gt;
&lt;li&gt;How to run asynchronous operations with WebView2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of the list above, creating original music was definitely the most enjoyable activity, so it&amp;#39;s good that SIC-1 provided motivation to learn more about that process.&lt;/p&gt;
&lt;p&gt;Releasing a game on Steam was a bucket list item for me, and I&amp;#39;m glad I did it. It remains to be seen if I&amp;#39;ll make any more games in the future.&lt;/p&gt;
&lt;h1 id=&quot;the-future&quot;&gt;The future&lt;/h1&gt;
&lt;p&gt;Speaking of the future, SIC-1 is mostly complete. I&amp;#39;d like to add an interactive tutorial and support for custom puzzles, but given the lower player count I&amp;#39;m not convinced that would be a good use of my (limited) free time.&lt;/p&gt;
&lt;p&gt;Here are the biggest remaining open questions for me&lt;/p&gt;
&lt;h2 id=&quot;should-i-open-source-sic-1&quot;&gt;Should I open-source SIC-1?&lt;/h2&gt;
&lt;p&gt;Currently the game is free and source is available, but it&amp;#39;s not &lt;a href=&quot;https://opensource.org/osd/&quot;&gt;Open Source&lt;/a&gt; because I don&amp;#39;t allow redistribution/resale/modifications. I love open source software, but there are two reasons I&amp;#39;m hesitant to release my game as open source:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I don&amp;#39;t want someone else to turn around and sell my game (that I released for free)&lt;/li&gt;
&lt;li&gt;I&amp;#39;m proud of the music and characters/narrative, and I don&amp;#39;t want other people to be able to profit off of them&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An obvious solution would be to release everything except the narrative and music as open source, but I&amp;#39;m not sure that&amp;#39;s worth the effort.&lt;/p&gt;
&lt;h2 id=&quot;should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;Should I port the Steam version of the game to Linux?&lt;/h2&gt;
&lt;p&gt;I feel bad for only supporting Windows for the Steam release. My original reasoning was:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The web version already works on Linux/macOS/whatever&lt;/li&gt;
&lt;li&gt;By using WebView2 (instead of Electron), I could keep the download size reasonable (less than 30 MB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In retrospect, I should have just used Electron from the beginning. Not only would it have been easier to implement, but then I could have easily supported Steam on Linux (and maybe even macOS), allowing those players to sync save data across devices and compare achievement statistics. The only downside is that the download would be roughly 5 times as large (which &lt;em&gt;does&lt;/em&gt; seem excessive for a mostly text-based game).&lt;/p&gt;
&lt;p&gt;But once again, I&amp;#39;m just not sure that the game is popular enough to warrant porting to Linux. It might please a handful of people (and make me feel better), but I should probably focus on more impactful projects.&lt;/p&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all, for now&lt;/h1&gt;
&lt;p&gt;Thus concludes my brain dump. Feel free to send questions or comments to &lt;a href=&quot;mailto:&amp;#x6c;&amp;#111;&amp;#x67;&amp;#64;&amp;#115;&amp;#x63;&amp;#x68;&amp;#101;&amp;#109;&amp;#101;&amp;#x73;&amp;#99;&amp;#97;&amp;#x70;&amp;#x65;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#x6d;&quot;&gt;&amp;#x6c;&amp;#111;&amp;#x67;&amp;#64;&amp;#115;&amp;#x63;&amp;#x68;&amp;#101;&amp;#109;&amp;#101;&amp;#x73;&amp;#99;&amp;#97;&amp;#x70;&amp;#x65;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#x6d;&lt;/a&gt;. If you enjoyed the game, I&amp;#39;d love to hear from you!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Speeding up md2blog</title>
<id>https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/static-site-generators/speeding-up-rebuilds.html"/>
<updated>2023-03-07T00:00:00.000Z</updated>
<summary type="text">md2blog is fast on my desktop, but slow on my Raspberry Pi. Here are my plans to improve rebuild performance.</summary>
<content type="html">&lt;p&gt;I&amp;#39;ve been happily using &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/md2blog-deno.html&quot;&gt;md2blog&lt;/a&gt; to generate this site for over a year now, but I recently ran into a problem: it&amp;#39;s not as fast as it could be.&lt;/p&gt;
&lt;p&gt;On my desktop computer, this is no big deal because a clean build only takes a couple of seconds and a live rebuild takes less than 2 seconds. But on my &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/../programming-languages/minimal-dev-env-3.html&quot;&gt;minimal development environment I&amp;#39;ve been playing with&lt;/a&gt; (which runs on a Raspberry Pi 1, model B), even after some basic optimization, it still takes 2 minutes to build the site from scratch! I haven&amp;#39;t bothered to attempt a &amp;quot;live&amp;quot; rebuild.&lt;/p&gt;
&lt;p&gt;One reason for this is the fact that md2blog always rebuilds the entire site, regardless of whether or not anything changed. This was a design decision I made solely to simplify the implementation, with the understanding that my site was small enough and my computer fast enough that it wouldn&amp;#39;t matter. Now, my computer is slow.&lt;/p&gt;
&lt;h1 id=&quot;solutions-to-explore&quot;&gt;Solutions to explore&lt;/h1&gt;
&lt;p&gt;Here are some ideas I had for improving performance on low-end devices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hugo&lt;/strong&gt;: Give up on JavaScript/Deno/&lt;a href=&quot;https://github.com/jaredkrinke/goldsmith&quot;&gt;Goldsmith&lt;/a&gt; and port everything to &lt;a href=&quot;https://gohugo.io/&quot;&gt;Hugo&lt;/a&gt; (which is implemented in Go and therefore compiled to native code, so probably faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: Give up on JavaScript and rewrite md2blog (and possibly Goldsmith) in Rust (also compiles to native code, but without a garbage collector, so maybe even faster)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caching&lt;/strong&gt;: Refactor Goldsmith so that it avoids rebuilding items whose source files haven&amp;#39;t changed&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hugo&quot;&gt;Hugo&lt;/h2&gt;
&lt;p&gt;Hugo is a popular static site generator. I &lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/hugo.html&quot;&gt;tried it out&lt;/a&gt; when I was first creating this site, but I hated the template language and the learning curve for creating new themes was fairly steep. Despite my complaints, I admire Hugo&amp;#39;s portability and speed, so I&amp;#39;m willing to give it another shot, so this option remains on the table.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I looked into Hugo more, and it doesn&amp;#39;t support deriving taxonomies from file system metadata (namely: parent directory), so I&amp;#39;d have to make some compromises (either to my workflow or the site design) if I wanted to switch to Hugo. Still on the table (just less attractive).&lt;/p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;/h2&gt;
&lt;p&gt;I&amp;#39;d like to learn Rust because it&amp;#39;s unique as a &lt;em&gt;safe&lt;/em&gt; systems language, and redesigning/reimplementing Goldsmith+md2blog in Rust would be a great way to learn the language. Using a compiled language would enable parallel builds (although my Raspberry Pi 1 only has a single CPU core), and I suspect that native Markdown/syntax highlighting libraries would speed things up.&lt;/p&gt;
&lt;p&gt;This would be a large project, but educational enough that I&amp;#39;m open to it.&lt;/p&gt;
&lt;h2 id=&quot;caching&quot;&gt;Caching&lt;/h2&gt;
&lt;p&gt;It&amp;#39;s hard to estimate the impact of caching intermediate objects and outputs, but done correctly this would at least reduce the number of files written out from roughly 100, down to just a handful.&lt;/p&gt;
&lt;p&gt;This option also has the attractive quality that it doesn&amp;#39;t require reimplementing everything in a new language or framework, so it&amp;#39;s probably the shortest path to performance improvements without functional regressions.&lt;/p&gt;
&lt;p&gt;For now, I&amp;#39;m planning to investigate caching first since it&amp;#39;s the easiest and safest option.&lt;/p&gt;
&lt;h1 id=&quot;adding-caching-to-goldsmith&quot;&gt;Adding caching to Goldsmith&lt;/h1&gt;
&lt;p&gt;I never got around to documenting Goldsmith (the base upon which md2blog is built), but it&amp;#39;s essentially &amp;quot;&lt;a href=&quot;https://log.schemescape.com/posts/static-site-generators/metalsmith.html&quot;&gt;Metalsmith&lt;/a&gt; for Deno, with very few dependencies&amp;quot;. Unfortunately, Metalsmith&amp;#39;s data model (which Goldsmith copies) doesn&amp;#39;t trivially lend itself to caching.&lt;/p&gt;
&lt;h2 id=&quot;goldsmiths-data-model-vs-caching&quot;&gt;Goldsmith&amp;#39;s data model vs. caching&lt;/h2&gt;
&lt;p&gt;Goldsmith&amp;#39;s data model is essentially one giant mutable map of filenames to metadata and content. A sequence of plugins manipulate this map, in order to transform input files to output files (adding/modifying metadata along the way). At the end of the plugin chain, files are written out to disk.&lt;/p&gt;
&lt;p&gt;The problem with this approach is that output files never specify their dependencies. Looking at it from the other direction, if I modify this post&amp;#39;s Markdown file, the only change to Goldsmith&amp;#39;s initial data model is the content of this Markdown file. The problem is that this one input file could impact numerous output files: the post itself, the Atom feed, any category/keyword index pages (especially if keywords are added or removed), the home page, and, of course, the archive page.&lt;/p&gt;
&lt;h2 id=&quot;caching-requirements&quot;&gt;Caching requirements&lt;/h2&gt;
&lt;p&gt;In order to rebuild the minimal set of files when a change is detected, I need an accurate dependency graph. There are a couple of pitfalls:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The pipeline itself can change&lt;/strong&gt; (in general for Goldsmith, and in configuration for md2blog)&lt;/li&gt;
&lt;li&gt;Plugins always consume the entire data model (plugins internally may filter the set of files, but that&amp;#39;s an implementation detail)&lt;/li&gt;
&lt;li&gt;Plugins can add/delete files at will (there isn&amp;#39;t even a &amp;quot;rename&amp;quot; operation--it just shows up as two independent operations: add and delete)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;brainstorming-dependency-graph-approaches&quot;&gt;Brainstorming dependency graph approaches&lt;/h2&gt;
&lt;p&gt;Obviously, I could just mandate that Goldsmith plugins have to accurately enumerate their dependencies when adding or modifying entires in the collection data model. For md2blog, with its fixed pipeline, this should be feasible, but potentially error-prone.&lt;/p&gt;
&lt;p&gt;Another approach would be to automatically gather dependency information for each output by providing the data model wrapped in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;proxy object&lt;/a&gt;. The trick is scoping the proxy object to a single output, and I don&amp;#39;t see a way to accomplish this without changing the plugin contract. One approach might be to create a new class of plugins that &lt;em&gt;only&lt;/em&gt; transform/rename files individually. &lt;strong&gt;This would also open the door to parallel processing of these &amp;quot;per-file&amp;quot; plugins&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Having the dependency graph computed automatically is preferable, so I&amp;#39;ll try that first.&lt;/p&gt;
&lt;h2 id=&quot;from-dependencies-to-caching&quot;&gt;From dependencies to caching&lt;/h2&gt;
&lt;p&gt;Creating the dependency graph is necessary, but not sufficient. I&amp;#39;ll need to also cache the intermediate results from plugins, along with the timestamps of input files so that I can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check to see which files have changed&lt;/li&gt;
&lt;li&gt;Restart the build pipeline from the deepest point that hasn&amp;#39;t changed&lt;/li&gt;
&lt;li&gt;Add back in unmodified data model entries&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;testing&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;Other than ad-hoc tests, it will probably be a good idea to &lt;strong&gt;run both the new cache-aware pipeline and the old rebuild-the-world approach to ensure there aren&amp;#39;t any differences&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll also, of course, need to &lt;strong&gt;ensure that the additional overhead from caching isn&amp;#39;t so large as to negate any of the benefits&lt;/strong&gt;, at least on my personal site (I&amp;#39;m not the only md2blog use in the entire world, but there are very few, and I suspect most won&amp;#39;t ever find the updated version).&lt;/p&gt;
&lt;h1 id=&quot;stay-tuned&quot;&gt;Stay tuned&lt;/h1&gt;
&lt;p&gt;I have no idea how long this project will take or whether I&amp;#39;ll abandon it, but if I make progress, I&amp;#39;ll be sure to post an update (and link it from here--hopefully the rebuild picks up the change!).&lt;/p&gt;
</content>
</entry>
<entry>
<title>Future-proof programming languages, part 3</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html"/>
<updated>2023-03-03T00:00:00.000Z</updated>
<summary type="text">Finally! I&apos;ve landed on my set of future-proof languages.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;part 1&lt;/a&gt;, I narrowed down a list of popular programming languages to the ones I liked and that I  thought would still be useful in the future. In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html&quot;&gt;part 2&lt;/a&gt;, I recorded some initial impressions, and added a few more languages to the mix.&lt;/p&gt;
&lt;p&gt;In this update, I&amp;#39;m recording my experiences with a trivial program in each language, with an eye towards possibly incorporating one or more of these languages into my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html&quot;&gt;minimal development environment&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;scenarios-and-metrics&quot;&gt;Scenarios and metrics&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;This post is not an attempt to definitively benchmark or objectively compare programming languages in depth!&lt;/strong&gt; Instead, I&amp;#39;m playing around with each language and environment to see which ones are even worth my consideration. Specifically, I&amp;#39;m looking at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDK size (measured on x86_64 Alpine Linux), as a proxy for &lt;strong&gt;simplicity&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;Hello, world!&amp;quot; program size, as a proxy for &lt;strong&gt;overhead&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Stand-alone executable size, as a proxy for &lt;strong&gt;ease of deployment&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Cross-compiling for a Raspberry Pi B, as a proxy for &lt;strong&gt;portability&lt;/strong&gt; and &lt;strong&gt;developer experience&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;For reference, my Alpine Linux baseline image was around 150 MB. Here are the results, ordered by descending SDK size:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;SDK size&lt;/th&gt;
&lt;th&gt;Program size&lt;/th&gt;
&lt;th&gt;Stand-alone size&lt;/th&gt;
&lt;th&gt;Build on Pi?&lt;/th&gt;
&lt;th&gt;Cross-compile for Pi?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Rust&lt;/td&gt;
&lt;td&gt;650 MB&lt;/td&gt;
&lt;td&gt;300 KB&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Probably&lt;/td&gt;
&lt;td&gt;Mostly easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go&lt;/td&gt;
&lt;td&gt;550 MB&lt;/td&gt;
&lt;td&gt;1.2 MB&lt;/td&gt;
&lt;td&gt;1.2 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C#&lt;/td&gt;
&lt;td&gt;510 MB&lt;/td&gt;
&lt;td&gt;75 KB&lt;/td&gt;
&lt;td&gt;67 MB&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Failed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Zig&lt;/td&gt;
&lt;td&gt;335 MB&lt;/td&gt;
&lt;td&gt;800 KB&lt;/td&gt;
&lt;td&gt;800 KB&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Mostly easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;230 MB&lt;/td&gt;
&lt;td&gt;14 KB&lt;/td&gt;
&lt;td&gt;940 KB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Tedious&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;144 MB&lt;/td&gt;
&lt;td&gt;14 KB&lt;/td&gt;
&lt;td&gt;13 KB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Tedious&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;75 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;7 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript (Node)&lt;/td&gt;
&lt;td&gt;60 MB&lt;/td&gt;
&lt;td&gt;1KB&lt;/td&gt;
&lt;td&gt;80 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lisp (SBCL)&lt;/td&gt;
&lt;td&gt;45 MB&lt;/td&gt;
&lt;td&gt;1KB&lt;/td&gt;
&lt;td&gt;40 MB&lt;/td&gt;
&lt;td&gt;Probably&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tcl&lt;/td&gt;
&lt;td&gt;8 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lua&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;1 KB&lt;/td&gt;
&lt;td&gt;1 MB&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Unnecessary&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;sdk-size&quot;&gt;SDK size&lt;/h2&gt;
&lt;p&gt;Just looking at SDK size, Rust is an outlier. Even compared to a similarly complex language like C++, the Rust SDK is absolutely huge. At the moment, I don&amp;#39;t know why the SDK is so big. Even after allowing for a build tool, custom linker, and standard library, the Rust SDK is disappointingly heavy. This unfortunately matches my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;previous experience with Rust on Windows&lt;/a&gt;. &lt;strong&gt;Update&lt;/strong&gt;: Using the &amp;quot;minimal&amp;quot; profile, the SDK was closer to 650 MB for native compilation and another 150 MB for cross-compilation.&lt;/p&gt;
&lt;p&gt;Obviously, it&amp;#39;s not fair to compare the compile-to-native languages to scripting languages, but comparisons within each category seem appropriate. Go is the second largest, but it comes with some impressive features: the ability to trivially cross-compile and &lt;a href=&quot;https://pkg.go.dev/std&quot;&gt;a large standard library&lt;/a&gt;. Go&amp;#39;s offering seems on par with C#, but with a better &amp;quot;compile to native code&amp;quot; story (and, obviously, larger differences in the programming languages themselves).&lt;/p&gt;
&lt;p&gt;Zig is larger than I expected for a simple language, but it can cross-compile for different architectures (similar to Go), and &lt;a href=&quot;https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j&quot;&gt;Zig can even compile C/C++ code&lt;/a&gt;, so it&amp;#39;s arguably worth the footprint.&lt;/p&gt;
&lt;p&gt;Looking at interpreted languages, the results are pretty similar except for Tcl and Lua (both of which don&amp;#39;t come with much of a standard library).&lt;/p&gt;
&lt;h2 id=&quot;hello-world-program-size&quot;&gt;&amp;quot;Hello, world!&amp;quot; program size&lt;/h2&gt;
&lt;p&gt;The Go binary shows one of Go&amp;#39;s weaknesses -- it&amp;#39;s compiled to native, but it has to include the entire runtime in each binary. This isn&amp;#39;t a deal-breaker for me, so I&amp;#39;m not too concerned.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;am&lt;/em&gt; curious why the Zig binary is so large, but I haven&amp;#39;t investigated any further yet. Given that Zig supports &amp;quot;freestanding&amp;quot; binaries, I&amp;#39;m sure it&amp;#39;s possible to create minimal binaries with Zig.&lt;/p&gt;
&lt;p&gt;The C++ binary using &amp;quot;iostream&amp;quot; was unacceptably big, but using &amp;quot;stdio.h&amp;quot; gets it back in line with C, in the low double-digit kilobytes.&lt;/p&gt;
&lt;h2 id=&quot;stand-alone-executable-size&quot;&gt;Stand-alone executable size&lt;/h2&gt;
&lt;p&gt;Deployment is probably my least favorite part of software. Obviously, there are exceptions, but in most cases, a &amp;quot;program that does X&amp;quot; would be most convenient as a single executable (or at least a single zip file) that just does X. Here, I&amp;#39;m looking at fully statically-linked or bundled binaries.&lt;/p&gt;
&lt;p&gt;Native languages generally compile to a single binary. I didn&amp;#39;t try to get a fully static binary from Rust, but I&amp;#39;ve read that it&amp;#39;s possible. C certainly is good at producing small executables (in the past, this was a prerequisite!).&lt;/p&gt;
&lt;p&gt;The other languages show some interesting results: JavaScript and C# appear to be the most bloated, closely followed by SBCL (a Common Lisp implementation). But for JavaScript there are multiple runtimes--80 MB is for Deno, but QuickJS is under 1 MB--so JavaScript supports indirectly optimizing for either size or speed. Lisp has a similar story, although I didn&amp;#39;t investigate it in depth. Python was impressively slim (definitely a surprise for me!).&lt;/p&gt;
&lt;p&gt;That leaves C# which, sadly, just appears to be bloated. For the record, I couldn&amp;#39;t get a Tcl bundle working, but I suspect it would be &amp;lt; 10 MB.&lt;/p&gt;
&lt;h2 id=&quot;developing-on-a-raspberry-pi&quot;&gt;Developing &lt;em&gt;on&lt;/em&gt; a Raspberry Pi&lt;/h2&gt;
&lt;p&gt;Note: this section is about developing/compiling &lt;em&gt;on&lt;/em&gt; a Raspberry Pi B.&lt;/p&gt;
&lt;p&gt;The only languages that appeared to not be trivial to compile on a Raspberry Pi B with Alpine Linux were C# (this appears to be an unsupported platform) and Zig (theoretically, you might be able to bootstrap an environment, but I haven&amp;#39;t attempted that yet).&lt;/p&gt;
&lt;h2 id=&quot;cross-compiling-for-a-raspberry-pi&quot;&gt;Cross-compiling for a Raspberry Pi&lt;/h2&gt;
&lt;p&gt;Although I&amp;#39;m interested in developing directly on a Pi (as part of &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html&quot;&gt;my minimal development environment&lt;/a&gt;), it&amp;#39;s likely I&amp;#39;ll end up doing some development on a (faster) desktop, and then want to run the output on a Pi. Results here are easily categorized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cross-compiling not needed&lt;ul&gt;
&lt;li&gt;JavaScript (QuickJS, Node, but &lt;em&gt;not&lt;/em&gt; Deno)&lt;/li&gt;
&lt;li&gt;Lua&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Tcl&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trivial to cross-compile&lt;ul&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust (note: requires &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;editing Cargo&amp;#39;s config file&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Zig (&lt;a href=&quot;https://github.com/ziglang/zig/issues/4875&quot;&gt;except for C/C++ code&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tedious, but possible to cross-compile&lt;ul&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cross-compile failed/didn&amp;#39;t work/not possible&lt;ul&gt;
&lt;li&gt;C# (executable failed to run)&lt;/li&gt;
&lt;li&gt;SBCL (not necessary with runtime, but not possible &lt;em&gt;without&lt;/em&gt; a runtime)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scripting languages sort of get a free pass here, but there are almost certainly large differences in ease of deployment.&lt;/p&gt;
&lt;p&gt;Go and Zig have excellent tooling for cross-compiling. And if Zig can eventually support cross-compiling C/C++ code without requiring a separate toolchain, that would be huge! &lt;strong&gt;Update&lt;/strong&gt;: Cross-compilation for Rust worked well, once I found out &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;how to tell Rust to use its bundled linker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C/C++ support cross-compiling through a painful process of setting up an entire compilation environment for the target. It&amp;#39;s tedious and annoying, and I hope I never have to do it again.&lt;/p&gt;
&lt;p&gt;As for C#, I suspect there&amp;#39;s some way to get them to successfully cross-compile for a Pi, but neither worked for me. I put SBCL in the last category because it seems to require running on the target in order to produce a bundle.&lt;/p&gt;
&lt;h1 id=&quot;analysis&quot;&gt;Analysis&lt;/h1&gt;
&lt;p&gt;Subjectively, I was least impressed with the following languages, so they&amp;#39;ve been cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C#: big and bloated, with poor support for Raspberry Pi -- it&amp;#39;s a shame because I really like C# and the .NET standard library&lt;/li&gt;
&lt;li&gt;Lisp: unimpressive bundle size/cross-compiling story -- but honestly, it&amp;#39;s too esoteric for me, and the community is highly fragmented&lt;/li&gt;
&lt;li&gt;Tcl: inconvenient tooling and, sadly, not popular enough to ensure it doesn&amp;#39;t fade away&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;ll tackle the remaining languages in two categories: native/compiled/statically typed vs. interpreted/dynamically typed.&lt;/p&gt;
&lt;h2 id=&quot;native-languages&quot;&gt;Native languages&lt;/h2&gt;
&lt;p&gt;Here are the remaining native languages, along with my favorite and least favorite qualities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C: simple and portable, but requires macros for many abstractions (and has an error-prone standard library)&lt;/li&gt;
&lt;li&gt;C++: powerful abstractions, but an inconsistent standard library&lt;/li&gt;
&lt;li&gt;Go: excellent tooling, but I still don&amp;#39;t like the overhead of a garbage collector for native code&lt;/li&gt;
&lt;li&gt;Rust: memory safety without a garbage collector, but the SDK is enormous (and supposedly slow)&lt;/li&gt;
&lt;li&gt;Zig: efficient tooling, but immature (likely with breaking changes)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;c-and-rust&quot;&gt;C++ and Rust&lt;/h3&gt;
&lt;p&gt;If I need powerful abstractions, C++ and Rust are the candidates. At the moment, I&amp;#39;m leaning towards giving Rust a try (despite the gigantic SDK). I&amp;#39;m familiar with C++, and it&amp;#39;s certainly capable, but Rust&amp;#39;s memory safety guarantees are worth exploring in depth. Hopefully that doesn&amp;#39;t end up being a mistake...&lt;/p&gt;
&lt;h3 id=&quot;c-go-zig&quot;&gt;C, Go, Zig&lt;/h3&gt;
&lt;p&gt;If I&amp;#39;m just looking for a simple and fast language, that would leave C, Go, and Zig. C is almost certainly future-proof for another decade or two and the SDK is reasonably sized. I&amp;#39;m less sure about Go and Zig, despite their efficient tooling. I&amp;#39;m skeptical of Go&amp;#39;s niche (native code, but with a garbage collector). Zig seems too immature, but its C/C++ compatibility is attractive.&lt;/p&gt;
&lt;p&gt;Overall, Rust&amp;#39;s unique combination of safety and speed is compelling, and I&amp;#39;m sure I&amp;#39;ll end up using it eventually. I&amp;#39;ll probably also need to use C where it&amp;#39;s already entrenched.&lt;/p&gt;
&lt;h2 id=&quot;interpreted-languages&quot;&gt;Interpreted languages&lt;/h2&gt;
&lt;p&gt;Here are the remaining interpreted/dynamic languages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python: ubiquitous, with a large standard library, but the language has a lot of warts and a history of compatibility problems&lt;/li&gt;
&lt;li&gt;JavaScript/TypeScript: the only option for the web, with a convenient type system in TypeScript, but without a standard library and runtime (and the module story is &lt;em&gt;still&lt;/em&gt; fragmented!)&lt;/li&gt;
&lt;li&gt;Lua: minimalist, but no standard library&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These languages are almost a battery inclusion continuum from &amp;quot;included&amp;quot; to &amp;quot;sold separately&amp;quot;.&lt;/p&gt;
&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;
&lt;p&gt;I don&amp;#39;t like Python. But it&amp;#39;s everywhere! Now that Python is convenient on Windows, Python is almost a defacto portable shell scripting language (with a lot more). For example, the &lt;a href=&quot;https://github.com/ziglang/zig-bootstrap&quot;&gt;Zig bootstrap process&lt;/a&gt; requires Python! If it had required Node, people would have lost their minds. I think it&amp;#39;s high time I give in and just embrace Python.&lt;/p&gt;
&lt;h3 id=&quot;javascript&quot;&gt;JavaScript&lt;/h3&gt;
&lt;p&gt;JavaScript has somehow leap-frogged Python to become a convenient language, and TypeScript makes it even better for large projects. But I will admit that Node&amp;#39;s API is irritating, and the NPM ecosystem continually has to grapple with the lack of a standard library. Deno&amp;#39;s tooling is excellent, but Deno also breaks compatibility left and right. JavaScript is definitely future-proof, but the non-browser runtimes I&amp;#39;m less sure about.&lt;/p&gt;
&lt;h3 id=&quot;lua&quot;&gt;Lua&lt;/h3&gt;
&lt;p&gt;Lua is a great language for embedding, but I&amp;#39;m not sure it can compete with the popularity of Python and JavaScript for general software tasks.&lt;/p&gt;
&lt;h3 id=&quot;all-of-the-above&quot;&gt;All of the above&lt;/h3&gt;
&lt;p&gt;Realistically, I&amp;#39;m probably going to use all three of these scripting languages, just for different purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python for tools and scripts&lt;/li&gt;
&lt;li&gt;JavaScript on the web&lt;/li&gt;
&lt;li&gt;Lua for embedding&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-all&quot;&gt;That&amp;#39;s all!&lt;/h1&gt;
&lt;p&gt;When I started this investigation, I thought Rust was a shoo-in, but it&amp;#39;s big and not as stable/polished as I&amp;#39;d expected. It&amp;#39;s still at the top of my &amp;quot;native&amp;quot; list, but only because of its unique combination of memory safety and systems-level design.&lt;/p&gt;
&lt;p&gt;Prior to digging in a bit more, I wanted to continue avoiding Python in favor of JavaScript/TypeScript (running under Deno where possible, and Node otherwise). I&amp;#39;ve finally given in, and I think I&amp;#39;ll be writing a lot more Python in the future. I&amp;#39;d also written off Lua, but its minimalist design dovetails nicely with my minimal development environment aspirations, so I might give Lua another shot. I&amp;#39;ll happily continue using JavaScript (really TypeScript) for the web, of course.&lt;/p&gt;
&lt;h2 id=&quot;addendumnotes&quot;&gt;Addendum/notes&lt;/h2&gt;
&lt;p&gt;The next section is just a collection of notes I made while testing out languages. It&amp;#39;s likely riddled with factual errors.&lt;/p&gt;
&lt;h3 id=&quot;c&quot;&gt;C#&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Install involves running a script -- will it pollute my system? Can I fully remove it?&lt;/li&gt;
&lt;li&gt;Docker images are provided -- would that be the safest way to try it out?&lt;/li&gt;
&lt;li&gt;Not seeing a Dockerfile on GitHub for ARMv6...&lt;/li&gt;
&lt;li&gt;What about Mono? Didn&amp;#39;t see any packages starting with &amp;quot;mono&amp;quot; on Alpine Linux...&lt;/li&gt;
&lt;li&gt;Cross-compile for Pi didn&amp;#39;t work&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;go&quot;&gt;Go&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Set &lt;code&gt;GOOS&lt;/code&gt; and &lt;code&gt;GOARCH&lt;/code&gt; to set OS and architecture for cross-compilation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;lisp-sbcl&quot;&gt;Lisp (SBCL)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Native package&lt;/li&gt;
&lt;li&gt;Arrow keys didn&amp;#39;t work in interpreter&lt;/li&gt;
&lt;li&gt;It seems like producing a self-contained, native executable for a different platform is frequently not supported by Lisps&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;lua-1&quot;&gt;Lua&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Has tons of native packages... but is it portable to Windows?&lt;/li&gt;
&lt;li&gt;Language server: &lt;a href=&quot;https://github.com/LuaLS/lua-language-server&quot;&gt;https://github.com/LuaLS/lua-language-server&lt;/a&gt; -- note that it&amp;#39;s complicated to build...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;jsts&quot;&gt;JS/TS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Probably will need Node at some point, but that runs on Raspberry Pi&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;python-1&quot;&gt;Python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Zig bootstrap requires Python 3, ha!&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;rust&quot;&gt;Rust&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Try with Alpine package first, since it&amp;#39;s convenient, and easy to remove&lt;/li&gt;
&lt;li&gt;Raspberry Pi B Alpine Linux triple: arm-unknown-linux-musleabihf&lt;/li&gt;
&lt;li&gt;Attempt to cross-compile failed with &amp;quot;linker `cc` not found&amp;quot; (and suggestions from the web didn&amp;#39;t help)&lt;/li&gt;
&lt;li&gt;Cross-compiler setup from rustup was Visual Studio-levels of huge (1.5 GB)&lt;/li&gt;
&lt;li&gt;Finally found &lt;a href=&quot;https://github.com/KodrAus/rust-cross-compile#cross-compiling-to-linux&quot;&gt;the trick&lt;/a&gt; for linking during cross-compilation: point Cargo to &amp;quot;rust-lld&amp;quot; (which is installed with the toolchain)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;tcl&quot;&gt;Tcl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Couldn&amp;#39;t figure out how to make a TclKit...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;zig&quot;&gt;Zig&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;No build for armv6l, but old build for armv6kz&lt;/li&gt;
&lt;li&gt;Crashes on C compile--also very slow to compile&lt;/li&gt;
&lt;li&gt;Hello world didn&amp;#39;t work--also kind of slow to compile&lt;/li&gt;
&lt;li&gt;Might try bootstrapping from my desktop, but probably too immature at the moment&lt;/li&gt;
&lt;li&gt;Cross compile to Raspberry Pi B with Alpine Linux: &lt;code&gt;zig build -Dtarget=arm-linux-musleabihf -Dcpu=arm1176jzf_s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cross-compiling C code &lt;a href=&quot;https://github.com/ziglang/zig/issues/4875&quot;&gt;doesn&amp;#39;t appear to be possible at the moment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Minimal dev environment, part 3: introducing &quot;leano&quot;, a tiny Deno-compatible runtime</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-3.html"/>
<updated>2023-02-28T00:00:00.000Z</updated>
<summary type="text">I developed an actual piece of software using my minimal development environment. Here&apos;s how it went.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html&quot;&gt;part 2&lt;/a&gt;, I laid out my initial minimal development environment (Raspberry Pi B, Alpine Linux, console only). Today, I&amp;#39;m sharing my initial experience using this setup.&lt;/p&gt;
&lt;h1 id=&quot;the-task-at-hand&quot;&gt;The task at hand&lt;/h1&gt;
&lt;p&gt;In order to document my experience, I needed to be able to build and update my dev blog using my &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt;-based static site generator (&lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt;), along with Git (and GitHub Pages). Problem: Deno &lt;a href=&quot;https://github.com/denoland/deno/issues/2295&quot;&gt;doesn&amp;#39;t support Raspberry Pi&lt;/a&gt; (32-bit or 64-bit).&lt;/p&gt;
&lt;p&gt;Fortunately, my static site generator only uses a tiny fraction of Deno&amp;#39;s API surface (at least to build the site), so it&amp;#39;s straight-forward to port the tool to a Pi-friendly runtime. One option would be to compile my TypeScript code to JavaScript, bundle it, and then use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node&lt;/a&gt; with a Node-to-Deno compatibility layer (written in JavaScript).&lt;/p&gt;
&lt;p&gt;But a more &lt;em&gt;interesting&lt;/em&gt; option would be to create my own (minimal, of course) Deno-compatible runtime, and use &lt;em&gt;that&lt;/em&gt; to run md2blog.&lt;/p&gt;
&lt;h2 id=&quot;dependencies&quot;&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;For this project, I decided to get back to my roots and use plain, boring old C. I would have like to try out Zig, but they don&amp;#39;t appear to build SDK binaries for the Raspberry Pi. Why C (or Zig)? Mostly because I was planning to leverage &lt;a href=&quot;https://bellard.org/quickjs/&quot;&gt;QuickJS&lt;/a&gt; (an implementation of ES2020 in C), and I knew that integrating the library would be simple if I stuck to C. If I&amp;#39;d used a new (to me) programming language, I&amp;#39;d immediately be thrown into the treacherous waters of foreign function interfaces/bindings (and past experience told me that&amp;#39;s usually the least fun part of learning a new programming language).&lt;/p&gt;
&lt;p&gt;Between QuickJS and the C standard library, I was hopeful I could get md2blog up and running on my Raspberry Pi.&lt;/p&gt;
&lt;h1 id=&quot;code-editing&quot;&gt;Code editing&lt;/h1&gt;
&lt;p&gt;In the past, I used Vim extensively, but lately I&amp;#39;ve mostly used VS Code (and Visual Studio, if necessary). This project was a good opportunity to reacquaint myself with Vim. Specifically, I wanted to see if I could carry some of my favorite features from VS Code back to Vim:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Smart) Auto-complete&lt;/li&gt;
&lt;li&gt;Go to definition&lt;/li&gt;
&lt;li&gt;Spellcheck&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;auto-complete-for-c-code-in-vim&quot;&gt;Auto-complete for C code in Vim&lt;/h2&gt;
&lt;p&gt;I used to think auto-complete was often used as a crutch for not being familiar with code. Nowadays, I&amp;#39;ll take any crutch I can get, because there&amp;#39;s so much code, and it&amp;#39;s honestly not worth my time to understand it all in depth--most of the time, at least.&lt;/p&gt;
&lt;p&gt;Although I was aware of it, I&amp;#39;d never taken the time to setup &lt;a href=&quot;https://en.wikipedia.org/wiki/Ctags&quot;&gt;Ctags&lt;/a&gt; in Vim. Ctags isn&amp;#39;t as nice as a real language server (it doesn&amp;#39;t automatically regenerate and can&amp;#39;t find all references, for example), but I&amp;#39;m not sure my Raspberry Pi could run a real language server anyway. Fortunately, setting up Ctags was as easy as running &lt;code&gt;ctags -R *&lt;/code&gt; in my project. Then it just all magically worked in insert mode with &lt;strong&gt;Ctrl+N&lt;/strong&gt;. Nice!&lt;/p&gt;
&lt;h2 id=&quot;go-to-definition&quot;&gt;Go to definition&lt;/h2&gt;
&lt;p&gt;With Ctags set up, I was just a &lt;code&gt;:help tags&lt;/code&gt; away from learning how to go to the definition of a symbol:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+]&lt;/strong&gt; jumps to the definition of the currently highlighted symbol&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+W Ctrl+]&lt;/strong&gt; opens the definition in a new pane&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl+T&lt;/strong&gt; jumps back to where you were&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&amp;#39;s pretty handy, although I started to remember how annoying it is to have to memorize a million key bindings to be productive in Vim.&lt;/p&gt;
&lt;h2 id=&quot;spellcheck&quot;&gt;Spellcheck&lt;/h2&gt;
&lt;p&gt;For blog entries, it&amp;#39;s nice to have a spellchecker running, to catch typos. I did a bit of research and couldn&amp;#39;t figure out why &lt;strong&gt;Ctrl+X s&lt;/strong&gt; didn&amp;#39;t work for spellcheck, but &lt;code&gt;:set spell&lt;/code&gt; worked like magic, and highlights any suspicious words.&lt;/p&gt;
&lt;h2 id=&quot;navigating-new-code-in-vim&quot;&gt;Navigating new code in Vim&lt;/h2&gt;
&lt;p&gt;Armed with some new Vim knowledge, I got started. The first task was to navigate around the QuickJS code to understand things like how to evaluate JavaScript code and how to expose native functions to JavaScript. Being able to search around the code and jump to definitions was great, but I did start to wish I was in VS Code. In Vim, I&amp;#39;m used to splitting panes horizontally and vertically, but I&amp;#39;m not sure what to do when I need to have so many things open at once that the panes are too small to be readable. In VS Code, I can keep files open without losing context. I&amp;#39;m sure this is possible in Vim, but I haven&amp;#39;t figure it out yet (and I&amp;#39;m not sure I&amp;#39;d remember all the keyboard shortcuts to make it happen).&lt;/p&gt;
&lt;p&gt;Has someone made a command palette for Vim yet?&lt;/p&gt;
&lt;h1 id=&quot;web-browser-woes&quot;&gt;Web browser woes&lt;/h1&gt;
&lt;p&gt;In addition to reading the QuickJS code, I also needed to refer to the HTML manual (although it&amp;#39;s fairly light on details, so no substitute for just reading the code). Once again, the console web browser experience was painful. It&amp;#39;s not the fault of the browsers themselves, it&amp;#39;s just that most web pages don&amp;#39;t seem to be designed with console browsers in mind. The QuickJS manual worked well, but trying to drill into search results, navigate GitHub issues, and read StackOverflow threads was a chore.&lt;/p&gt;
&lt;p&gt;At least DuckDuckGo and &lt;a href=&quot;https://developer.mozilla.org/en-US&quot;&gt;MDN&lt;/a&gt; provide decent experiences in console mode.&lt;/p&gt;
&lt;h1 id=&quot;so-slow&quot;&gt;So... &lt;em&gt;slow&lt;/em&gt;...&lt;/h1&gt;
&lt;p&gt;The preceding issues were tolerable. Performance was another story.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not sure what I was expecting from a 10 year old computer that cost $50 to begin with. I thought I&amp;#39;d heard that you could play Quake 3 on a Raspberry Pi (although I&amp;#39;m not sure which model). Having used a Raspberry Pi model B with 512 MB of RAM and a 700 MHz ARM CPU for a few days, I&amp;#39;m skeptical.&lt;/p&gt;
&lt;p&gt;Installing packages and opening web pages in w3m was pretty snappy, but compiling QuickJS was a rude awakening. I typed &lt;code&gt;make&lt;/code&gt; and then left to do something else when it became apparent that it might be a while. Later, I came back, and it was &lt;em&gt;still&lt;/em&gt; compiling! With link-time optimization, it took almost half an hour to build QuickJS.&lt;/p&gt;
&lt;p&gt;I hoped that the GCC compiler was just being slow (and link-time optimization is probably pretty CPU-intensive in general), but over the course of the day it became apparent that &lt;em&gt;everything&lt;/em&gt; was slow. Navigating large C files in Vim was slow (frequently, I could see the screen re-drawing individual lines of text). Syntax highlighting (which I think isn&amp;#39;t even parsing the full C grammar) was slow enough that it kept automatically turning itself off.&lt;/p&gt;
&lt;h1 id=&quot;success-and-leano&quot;&gt;Success! And &lt;strong&gt;leano&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;But I persisted and eventually was able to create a minimal Deno-compatible JavaScript runtime, built on QuickJS. I call the result &lt;strong&gt;leano&lt;/strong&gt;, and &lt;a href=&quot;https://github.com/jaredkrinke/leano&quot;&gt;the toy-level prototype code is up on GitHub&lt;/a&gt;. The whole thing weighs in at roughly 800 KB. But, of course, it doesn&amp;#39;t do very much--leano only implements the Deno functions/properties that md2blog uses.&lt;/p&gt;
&lt;p&gt;For the record: this blog post was written (and built) using leano on my Raspberry Pi.&lt;/p&gt;
&lt;p&gt;The implementation is fairly simple:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sets up a QuickJS runtime and context&lt;/li&gt;
&lt;li&gt;Exposes a couple of native functions (for performance reasons)&lt;/li&gt;
&lt;li&gt;Injects JavaScript code to implement Deno and web APIs (e.g. &lt;code&gt;Deno.args&lt;/code&gt;, &lt;code&gt;Deno.writeTextFile&lt;/code&gt;, and &lt;code&gt;TextEncoder&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Runs the requested module&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#39;ll admit that md2blog hasn&amp;#39;t been optimized. It always regenerates the entire site, and it&amp;#39;s written in JavaScript. On my desktop computer, I can build my site in maybe 1 second. On the Raspberry Pi (admittedly using a much simpler JavaScript runtime), it took &lt;em&gt;over 6 minutes&lt;/em&gt;! Even after moving UTF-8 encode/decode to native code, it still took 4 minutes to rebuild this site.&lt;/p&gt;
&lt;h1 id=&quot;lessons-learned&quot;&gt;Lessons learned&lt;/h1&gt;
&lt;p&gt;That was just a depiction of my experience using this minimal dev environment. But what have I &lt;em&gt;learned&lt;/em&gt;?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A ten year-old, cheap computer is capable, but &lt;em&gt;slow&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Regardless, it &lt;em&gt;is&lt;/em&gt; possible to develop software in C, with most of the bells and whistles, &lt;em&gt;while using under 500 MB of disk space&lt;/em&gt; (this is probably the biggest surprise of this whole experiment)&lt;/li&gt;
&lt;li&gt;Vim with Ctags is great, but remembering all the key bindings is annoying, and I still feel less productive than in VS Code&lt;/li&gt;
&lt;li&gt;Not mentioned above, but I haven&amp;#39;t found a good debugging setup, even for C&lt;/li&gt;
&lt;li&gt;JavaScript is pretty portable, thanks to QuickJS (though I worry what will happen as the language continues to evolve beyond QuickJS&amp;#39;s implementation)&lt;/li&gt;
&lt;li&gt;Browsing most of the web on the console is tedious&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;next-steps&quot;&gt;Next steps&lt;/h1&gt;
&lt;p&gt;First of all, it&amp;#39;s clear to me that I&amp;#39;d like a faster computer. Would a newer Raspberry Pi hit the sweet spot between performance and cheapness? What about an old laptop?&lt;/p&gt;
&lt;p&gt;Additionally, I&amp;#39;m still on the fence about wanting to stick to console mode. Ultimately, it&amp;#39;s an arbitrary goal, and I don&amp;#39;t think I&amp;#39;m aiming for it for any other reason than to see if it&amp;#39;s possible. It&amp;#39;s likely at some point I will break down and install a GUI environment. Maybe economizing a GUI is superior to maximizing the console?&lt;/p&gt;
&lt;p&gt;Regardless, I still plan to play around with a few more code editors and programming languages.&lt;/p&gt;
</content>
</entry>
<entry>
<title>In search of a minimal development environment, part 2</title>
<id>https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/minimal-dev-env-2.html"/>
<updated>2023-02-26T00:00:00.000Z</updated>
<summary type="text">Some practical research into a minimal development environment.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/minimal-dev-env.html&quot;&gt;part 1&lt;/a&gt;, I was yearning for simpler times, when entire operating systems could fit on a single digit number of 1.44 MB floppy disks.&lt;/p&gt;
&lt;p&gt;What did my initial &amp;quot;minimal development environment&amp;quot; research uncover?&lt;/p&gt;
&lt;h1 id=&quot;platforms&quot;&gt;Platforms&lt;/h1&gt;
&lt;p&gt;Although it&amp;#39;s probably possible to run some useful software on a tiny or old platforms (e.g. a microcontroller or Game Boy), the smallest platform I seriously considered was a &lt;a href=&quot;https://www.raspberrypi.com/&quot;&gt;Raspberry Pi&lt;/a&gt; (for the simple reason that I inherited one and hadn&amp;#39;t been using it). My Raspberry Pi is a model B with 512 MB of RAM, apparently from 2012.&lt;/p&gt;
&lt;h1 id=&quot;operating-systems&quot;&gt;Operating systems&lt;/h1&gt;
&lt;p&gt;While investigating operating systems, I immediately had to confront the fact that I&amp;#39;m not looking for a &lt;em&gt;truly&lt;/em&gt; minimal operating system. The following OSes intrigued me, but they&amp;#39;re a little too restrictive/esoteric for my current goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://collapseos.org/&quot;&gt;Collapse OS&lt;/a&gt; runs on Z80-based hardware with 64 KB or less of RAM&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sr.ht/~vdupras/duskos/&quot;&gt;Dusk OS&lt;/a&gt; runs on x86 hardware, and can bootstrap itself into a &lt;a href=&quot;https://en.wikipedia.org/wiki/Forth_(programming_language)&quot;&gt;Forth&lt;/a&gt;-based shell with an &amp;quot;Almost C&amp;quot; compiler in just a few thousand lines of code&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fiwix.org/&quot;&gt;Fiwix&lt;/a&gt; uses a (relatively) small kernel (50k lines of code), but strives to be Linux-compatible&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://minix3.org/&quot;&gt;MINIX&lt;/a&gt; uses an educational kernel that has apparently made its way into Intel products, but the project is &lt;a href=&quot;https://github.com/o-oconnell/minixfromscratch&quot;&gt;no longer maintained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the end, I decided to focus on more popular platforms: Linux, FreeBSD, OpenBSD, and NetBSD. (Although I&amp;#39;d really like to explore Dusk OS in the future.)&lt;/p&gt;
&lt;p&gt;To my surprise, it looked like the smallest full-featured option (in terms of disk footprint, and ignoring &amp;quot;nano&amp;quot; installs that lack functionality) was probably &lt;a href=&quot;https://www.alpinelinux.org/&quot;&gt;Alpine Linux&lt;/a&gt;. A command-line only development environment on Debian weighed in at over 1.5 GB (!), but I was able to set up a somewhat comfortable C development environment on Alpine Linux in under 300 MB! (Although &lt;a href=&quot;https://wiki.alpinelinux.org/wiki/Raspberry_Pi&quot;&gt;installing Alpine Linux on a Raspberry Pi&lt;/a&gt; is tedious.)&lt;/p&gt;
&lt;p&gt;I&amp;#39;m a little nervous to adopt Alpine Linux without haven&amp;#39;t a good grasp of how updates (especially kernel updates) work, but so far it just feels like exactly what I was looking for.&lt;/p&gt;
&lt;h1 id=&quot;software&quot;&gt;Software&lt;/h1&gt;
&lt;p&gt;With a minimal Alpine Linux install on a Raspberry Pi model B, I investigated various console applications.&lt;/p&gt;
&lt;h2 id=&quot;web-browser&quot;&gt;Web browser&lt;/h2&gt;
&lt;p&gt;There are a lot of console web browser options today. I tried: &lt;a href=&quot;https://lynx.browser.org/&quot;&gt;Lynx&lt;/a&gt;, &lt;a href=&quot;http://elinks.or.cz/&quot;&gt;ELinks&lt;/a&gt;, &lt;a href=&quot;https://w3m.sourceforge.net/&quot;&gt;w3m&lt;/a&gt;, and a few that I don&amp;#39;t remember. In the past, I used ELinks because it seemed to have the most functionality, but as of today, my favorite is w3m. I liked its rendering the best, and it&amp;#39;s comfortable to use from the keyboard, thanks to vi-inspired key bindings. I will say that w3m has a steep learning curve (there aren&amp;#39;t any user-friendly menus, at least that I found), so it might not be a great choice for everyone.&lt;/p&gt;
&lt;p&gt;For the record: Lynx was oddly slow and ELinks&amp;#39;s menus seemed a little glitchy.&lt;/p&gt;
&lt;p&gt;Unfortunately, using the modern web from the console is not a pleasant experience. I ran into sites with huge navigation lists that I&amp;#39;d have to page through, sites that require JavaScript to render anything, etc. &lt;/p&gt;
&lt;h2 id=&quot;terminal-multiplexer&quot;&gt;Terminal multiplexer&lt;/h2&gt;
&lt;p&gt;I realize that &lt;a href=&quot;https://github.com/tmux/tmux/wiki&quot;&gt;tmux&lt;/a&gt; has a lot of momentum, but I&amp;#39;ve been using &lt;a href=&quot;https://www.gnu.org/software/screen/&quot;&gt;GNU Screen&lt;/a&gt; because I&amp;#39;m already familiar with it. tmux &lt;em&gt;does&lt;/em&gt; seem to have some nice features (e.g. retaining panes across detach/reattach), so it&amp;#39;s probably what I&amp;#39;d use today if I was starting from scratch.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s also &lt;a href=&quot;https://zellij.dev/&quot;&gt;Zellij&lt;/a&gt;, which has some interesting ideas (namely floating windows), wrapped up in what appears to be a user-friendly interface. I haven&amp;#39;t tried it yet, however.&lt;/p&gt;
&lt;h2 id=&quot;rss-reader&quot;&gt;RSS reader&lt;/h2&gt;
&lt;p&gt;One motivation for setting up a simpler development environment is to slow down and reduce distractions. With some freed up &amp;quot;focus&amp;quot; time, I&amp;#39;d like to get back to using RSS feeds to keep up to date on blogs I enjoy. &lt;a href=&quot;https://newsboat.org/&quot;&gt;Newsboat&lt;/a&gt; is an excellent console RSS reader.&lt;/p&gt;
&lt;h2 id=&quot;irc&quot;&gt;IRC&lt;/h2&gt;
&lt;p&gt;And why stop at RSS? Let&amp;#39;s go all the way back to 1988 and use &lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Relay_Chat&quot;&gt;IRC&lt;/a&gt;! I don&amp;#39;t like how &lt;a href=&quot;https://discord.com/&quot;&gt;Discord&lt;/a&gt; has monopolized chat-based communities, but IRC is fairly tedious to set up, and the command-based interface is unfriendly (the last thing I want to do is embarrass myself by mistyping a command and having everyone see it as a chat message!).&lt;/p&gt;
&lt;p&gt;I have &lt;a href=&quot;https://irssi.org/&quot;&gt;irssi&lt;/a&gt; installed, but I haven&amp;#39;t really used it enough to say whether this is a good choice for IRC (or if IRC is even a good choice at all).&lt;/p&gt;
&lt;h2 id=&quot;code-editor&quot;&gt;Code editor&lt;/h2&gt;
&lt;p&gt;I haven&amp;#39;t investigated editor options in depth yet. The main features I&amp;#39;m looking for are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Runs in console mode&lt;/li&gt;
&lt;li&gt;Comfortable editing&lt;/li&gt;
&lt;li&gt;Helpful syntax highlighting&lt;/li&gt;
&lt;li&gt;Language-specific features (from most important to least):&lt;ul&gt;
&lt;li&gt;Auto-complete/lookup&lt;/li&gt;
&lt;li&gt;Go to definition&lt;/li&gt;
&lt;li&gt;Find all references&lt;/li&gt;
&lt;li&gt;Rename/refactor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now, I&amp;#39;m using &lt;a href=&quot;https://www.vim.org/&quot;&gt;Vim&lt;/a&gt;, with nothing but default syntax highlighting and &amp;quot;Ctrl+N&amp;quot; as a minimal auto-complete. This was great in the 90s, but I&amp;#39;m more productive with advanced language features.&lt;/p&gt;
&lt;p&gt;Here are a few options I&amp;#39;m planning to investigate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vim with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ctags&quot;&gt;Ctags&lt;/a&gt; (ideally automated)&lt;/li&gt;
&lt;li&gt;Vim/&lt;a href=&quot;https://neovim.io/&quot;&gt;NeoVim&lt;/a&gt; with an actual &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;language server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://helix-editor.com/&quot;&gt;Helix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kakoune.org/&quot;&gt;Kakoune&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and maybe even &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;Emacs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;but-am-i-making-a-mistake&quot;&gt;But... am I making a mistake?&lt;/h1&gt;
&lt;p&gt;After a couple of days using this setup, I&amp;#39;m already starting to question my decision to use the console.&lt;/p&gt;
&lt;h2 id=&quot;console-web-experience-isnt-great&quot;&gt;Console web experience isn&amp;#39;t great&lt;/h2&gt;
&lt;p&gt;The biggest issue is that the web is really hard to use from a terminal. It&amp;#39;s difficult to quickly scan headings and identify distinct content areas using only text (specifically: text that wasn&amp;#39;t designed to be used from the console). I guess I didn&amp;#39;t realize how helpful subtle font size/color changes are for quickly scanning content.&lt;/p&gt;
&lt;h2 id=&quot;sometimes-the-mouse-is-handy&quot;&gt;Sometimes the mouse is handy&lt;/h2&gt;
&lt;p&gt;Then there&amp;#39;s mouse support. I use the keyboard extensively, but the mouse is sometimes faster for selecting text and interacting with UI elements that aren&amp;#39;t in a simple order/hierarchy. &lt;a href=&quot;https://man.archlinux.org/man/gpm.8.en.html&quot;&gt;GPM&lt;/a&gt; helps, but it&amp;#39;s kind of clunky, and doesn&amp;#39;t help when I need to scroll text while using the mouse.&lt;/p&gt;
&lt;h2 id=&quot;lack-of-consistency&quot;&gt;Lack of consistency&lt;/h2&gt;
&lt;p&gt;Finally, there is very little user interface consistency between most console tools. Many include vi-like key bindings (either by default or with customizations), but that&amp;#39;s often where the consistency ends. I guess I didn&amp;#39;t realize how much I&amp;#39;d come to rely on standard GUI elements like menus, tooltips, and buttons. I &lt;em&gt;do&lt;/em&gt; think that a searchable &amp;quot;command palette&amp;quot; would go a long way toward making console tools easier to use, but I&amp;#39;m not planning on implementing those myself. Using Emacs for everything might help with consistency, but I&amp;#39;m skeptical of the performance and robustness of huge pile of Emacs extensions.&lt;/p&gt;
&lt;h1 id=&quot;to-be-continued&quot;&gt;To be continued...&lt;/h1&gt;
&lt;p&gt;Next up, I&amp;#39;m planning to document my misadventures in getting &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt; (my &lt;a href=&quot;https://deno.land/&quot;&gt;Deno&lt;/a&gt;-based static site generator) running on a Raspberry Pi B (a platform that Deno doesn&amp;#39;t support).&lt;/p&gt;
</content>
</entry>
</feed>
