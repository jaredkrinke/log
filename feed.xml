<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Mon, 20 Sep 2021 19:58:31 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Test-driving Metalsmith for a simple dev blog]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> to see which is closest to <a href="../overview/">my ideal setup</a>. Next up is <a href="https://metalsmith.io/">Metalsmith</a>.</p>
<p>Spoiler: I really like Metalsmith&#39;s modular design, so much so that I&#39;m now using Metalsmith for this blog.</p>
<h1 id="metalsmith">Metalsmith</h1>
<p>Metalsmith is a Node-based static site generator with a modular architecture that relies on many small plugins (similar in style to <a href="https://gulpjs.com/">gulp</a>). Installation is done via NPM (but note that you&#39;ll likely need to track down and install many plugins).</p>
<h2 id="architecture">Architecture</h2>
<p>Metalsmith is configured using plain old JavaScript code and building the site is just a matter of running your script, which is especially nice for debugging issues. See their &quot;elevator pitch&quot; on the <a href="https://metalsmith.io/">Metalsmith home page</a> for an example. It&#39;s refreshingly simple and transparent, but you&#39;ll need to install plugins and write some code to get a test server with live reloading (unlike many other modern static site generators that support this out the box).</p>
<p>While vetting and adding plugins is tedious, I like the fact that Metalsmith doesn&#39;t install 500+ packages by default (... like Eleventy).</p>
<p>Thanks to <a href="https://github.com/jstransformers/jstransformer">jstransformer</a>, Metalsmith supports a wide variety of template languages. I&#39;m not a fan of <a href="https://liquidjs.com/">Liquid</a> or <a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>, but I&#39;m trying out <a href="https://handlebarsjs.com/">Handlebars</a> because I find it more intuitive and less verbose. So far, it seems easier to maintain than the plain JavaScript templates I used with <a href="../eleventy-2/">Eleventy</a>.</p>
<h2 id="themes">Themes?</h2>
<p>If you don&#39;t want to author your own HTML templates, Metalsmith honestly doesn&#39;t seem like a good choice. It&#39;s possible to construct a Metalsmith &quot;theme&quot; by combining plugins, configuration, and templates, but really what you&#39;re providing is an entire skeleton project (with a <code>package.json</code> file, build scripts, and so on). This means the result is less portable and more difficult to integrate (unless you&#39;re starting from scratch and don&#39;t have any opinions or constraints).</p>
<p>Other static site generators (e.g. Hugo) abstract out the concept of a theme (along with standard metadata that themes can leverage), so you don&#39;t have to mix code and configuration together with HTML templates and CSS styling. This seems better for people who don&#39;t want total control of every character in their final HTML output.</p>
<h2 id="setup">Setup</h2>
<p><a href="https://metalsmith.io/#introduction">Metalsmith&#39;s home page</a> has a sample script right at the top you can look at, but you&#39;ll end up with a bunch of <code>require(...)</code>s followed by something like this:</p>
<pre><code>Metalsmith(__dirname)
    .metadata({
        site: {
            title: &quot;Schemescape&quot;,
            url: &quot;https://log.schemescape.com/&quot;,
            description: &quot;Development log of a life-long coder&quot;,
        },
    })
    .source(&quot;./content&quot;)
    .destination(&quot;./out&quot;)
    .use(collections({
        posts: {
            pattern: &quot;posts/**/*.md&quot;,
            sortBy: &quot;date&quot;,
            reverse: true,
        }
    }))
    .use(markdown())
    .use(layouts({
        directory: &quot;templates&quot;,
        default: &quot;default.hbs&quot;,
    }))
    ...
    .build(err =&gt; { if (err) throw err; });</code></pre><p>If you just want to build a dev blog like everyone else, it does feel like a lot of boilerplate code, but I like that it forces you to consider and understand each step of the process. Some of the other static site generators were too proactive and did things I didn&#39;t expect or understand (or want). With Metalsmith, it only does exactly what you tell it.</p>
<p>But there&#39;s a dark side to Metalsmith&#39;s simple model, and that&#39;s that Metalsmith has to be taught to do even the most basic things. For example, I&#39;m building my site on Windows, which has the unfortunate property of using backslashes for path separators. Metalsmith doesn&#39;t seem to know or care about this detail, so I had to actually write code to switch to web-friendly forward slashes when creating links between files in different directories.</p>
<h3 id="plugins-plugins-plugins">Plugins, plugins, plugins</h3>
<p>Metalsmith&#39;s modular architecture with a very simple core library means you need plugins--a lot of plugins. Fortunately, most of the functionality I was interested in already existed in the form of published plugins (some official, some third party). Here are the ones I used:</p>
<table>
<thead>
<tr>
<th>Plugin (* = official)</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a>*</td>
<td>Translates Markdown to HTML (using <a href="https://marked.js.org/">Marked</a>)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-drafts">metalsmith-drafts</a>*</td>
<td>Excludes files marked &quot;draft: true&quot; in YAML front matter (yep, you need a plugin for this)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-collections">metalsmith-collections</a>*</td>
<td>Groups and sorts files by path (e.g. for listing blog posts)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-permalinks">metalsmith-permalinks</a>*</td>
<td>Creates a directory for each HTML file (so links only specify directories and not files)</td>
</tr>
<tr>
<td><a href="https://github.com/metalsmith/metalsmith-layouts">metalsmith-layouts</a>*</td>
<td>Adds support for templates using <a href="https://github.com/jstransformers">jstransformers</a></td>
</tr>
<tr>
<td><a href="https://github.com/jstransformers/jstransformer-handlebars">jstransformer-handlebars</a>*</td>
<td>Adds support for <a href="https://handlebarsjs.com/">Handlebars</a></td>
</tr>
<tr>
<td><a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a></td>
<td>Copies static assets (e.g. CSS and my &quot;CNAME&quot; file)</td>
</tr>
<tr>
<td><a href="https://github.com/radiovisual/metalsmith-rootpath">metalsmith-rootpath</a></td>
<td>Computes the path to root of each page (allowing you to use relative links to CSS, etc.)</td>
</tr>
<tr>
<td><a href="https://github.com/timdp/metalsmith-discover-partials">metalsmith-discover-partials</a></td>
<td>Registers <a href="https://handlebarsjs.com/guide/partials.html">Handlebar partials</a> (for reusing/nesting templates)</td>
</tr>
<tr>
<td><a href="https://github.com/hurrymaplelad/metalsmith-feed">metalsmith-feed</a></td>
<td>Creates an RSS feed from a collection</td>
</tr>
<tr>
<td><a href="https://github.com/davidxmoody/metalsmith-broken-link-checker">metalsmith-broken-link-checker</a></td>
<td>Validates relative links in the final site</td>
</tr>
<tr>
<td><a href="https://github.com/chiefy/metalsmith-express">metalsmith-express</a></td>
<td>Runs a test server for local testing (with live reloading)</td>
</tr>
<tr>
<td><a href="https://github.com/FWeinb/metalsmith-watch">metalsmith-watch</a></td>
<td>Triggers rebuilds when files are updated (needed for live reloading)</td>
</tr>
</tbody></table>
<p>Note that some of the plugins I installed had dependencies flagged by NPM as having vulnerabilities. I reviewed the notices and none seemed concerning for my use case (e.g. all of the input is code/content I wrote and I don&#39;t plan on targeting myself for a regular expression denial of service attack).</p>
<h3 id="missing-plugins">Missing plugins</h3>
<p>Despite all these great plugins, I did end up needing to add a little extra functionality. Theoretically, these could be packaged into plugins.</p>
<ul>
<li>Translate relative <code>*.md</code> links to point to the corresponding output directories</li>
<li>Compute relative link paths, with forward slashes only (Metalsmith only provides the source path by default)</li>
<li>A &quot;no-op&quot; plugin for conditional inclusion of plugins without breaking up the giant configuration chain</li>
</ul>
<h2 id="issues">Issues</h2>
<p>Here are a couple of snags I hit while integrating Metalsmith into my site.</p>
<h3 id="inflexible-directory-structure">Inflexible directory structure</h3>
<p>For how simple Metalsmith is, I figured it would allow for a flexible directory structure, but Metalsmith actually only allows a single source directory by default. This is a problem for my directory structure because I separated all of my content (Markdown files) from files needed to build the web site (scripts, templates, but also CSS). Fortunately, the <a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a> plugin handle this scenario:</p>
<pre><code>const assets = require(&quot;metalsmith-static&quot;);

Metalsmith
...
    .use(assets({
        src: &quot;static&quot;,
        dest: &quot;.&quot;,
    }))</code></pre><h3 id="destination-paths-arent-available">Destination paths aren&#39;t available</h3>
<p>Somewhere in Metalsmith&#39;s pipeline, it knows where a file is going to end up, but for some inexplicable reason, this information isn&#39;t available to templates or plugins. In my case, it&#39;s easy to infer the destination (although I had to deal with Windows&#39; annoying path-separating backslashes), so it wasn&#39;t a big deal, but this really isn&#39;t something I should have had to think about.</p>
<h3 id="plugin-ordering">Plugin ordering</h3>
<p>Since plugins enrich and mutate files and metadata along the way, the ordering of plugins matters. One annoying interaction was between the &quot;layouts&quot; (templating) and &quot;feed&quot; (RSS) plugins:</p>
<ul>
<li>&quot;Feed&quot; then &quot;layouts&quot;: the RSS feed gets wrapped in HTML (&quot;layouts&quot; is run on <em>every</em> file by default)</li>
<li>&quot;Layouts&quot; then &quot;feed&quot;: the RSS content for each post is now a full HTML page, because templates were already applied</li>
</ul>
<p>The fix in this case was to run &quot;layouts&quot; after &quot;feed&quot; but tell &quot;layouts&quot; to only process HTML files (and not &quot;feed.xml&quot;).</p>
<p>This all makes sense if you think about how Metalsmith plugins receive a set of files, manipulate them, and then pass them on to the next plugin, but other generators do a good job of insulating me from mistakes like this.</p>
<h3 id="handling-internal-links">Handling internal links</h3>
<p>I&#39;m still surprised that using relative links to Markdown files for internal linking between posts isn&#39;t well supported by the static site generators I&#39;ve tried so far (Metalsmith included). I ended up having to extend the <a href="https://marked.js.org/using_pro#renderer">Marked renderer</a> to enable internal links:</p>
<pre><code>const marked = require(&quot;marked&quot;);
...
// Translate relative Markdown links to point to corresponding HTML output files
const markdownRenderer = new marked.Renderer();
const baseLinkRenderer = markdownRenderer.link;
markdownRenderer.link = function (href, title, text) {
    return baseLinkRenderer.call(this,
        href.replace(/^([^/][^:]*)\.md(#[^#]+)?$/, &quot;../$1/$2&quot;),
        title,
        text);
};
...
Metalsmith
...
    .use(markdown({ renderer: markdownRenderer }))
    .use(permalinks())</code></pre><p><strong>Update</strong>: I realized I also want to be able to link to a heading <em>within</em> another post (examples: <a href="#architecture">link to Architecture heading in this post</a>; <a href="../comparison/#metalsmith">link to my initial impression of Metalsmith in a different post</a>). The code about has been updated to handle this case.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Overall, I really liked that Metalsmith just did exactly what I asked, even if I didn&#39;t initially know what, precisely, I wanted. I was able to find plugins for almost everything to get started (including local testing with live reloading). Importantly, I also feel like I fully understand what Metalsmith is doing, so I don&#39;t have to worry about later discovering that it was processing files multiple times (something that did happen with Eleventy).</p>
<p>Additionally, because Metalsmith is so simple to extend, I can actually foresee myself writing a plugin to, say, add inline diagrams that are automatically converted to SVG at build time (a feature that&#39;s part of my <a href="../overview/">my ideal workflow</a>).</p>
<p>One comment on Handlebars: this isn&#39;t a review of Handlebars, but I did find Handlebars to be a surprisingly agreeable template language. This is actually high praise coming from me, since I find most template languages to be hideous and verbose. Only annoyance is that the automatic indentation isn&#39;t always what you want (e.g. in the case of <code>&lt;pre&gt;</code> blocks).</p>
<p>Overall, I&#39;m very happy with Metalsmith, and it&#39;s likely that I will be using it moving forward. <strong>Update</strong>: I switched from Eleventy to Metalsmith.</p>
<p>For reference, all of my code is here:
<a href="https://github.com/jaredkrinke/log">https://github.com/jaredkrinke/log</a></p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith</guid><pubDate>Sat, 18 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[How to benchmark disk drives on Windows]]></title><description><![CDATA[<p>My computer (running Windows) has multiple drives in it and I was wondering which drive is actually the fastest. Fortunately, there&#39;s an app for that.</p>
<h1 id="background">Background</h1>
<p>In the past, I kept up to date on computer hardware (because, let&#39;s be honest, games), but I&#39;ve been lazy for the past decade or so.</p>
<p>I recently inherited some new parts and now I&#39;ve got 3 drives:</p>
<ol>
<li>Cheapo solid state drive I bought off Newegg a few years back</li>
<li>1 TB rotational drive I salvaged from a discarded Western Digital My Book</li>
<li>Fancy new non-volatile memory (NVMe) drive</li>
</ol>
<p>My limited understanding tells me that the NVMe drive should be the fastest and that the rotational drive should be incredibly slow in comparison.</p>
<h1 id="benchmarking-with-diskspd">Benchmarking with DiskSpd</h1>
<p>Enter <a href="https://github.com/Microsoft/diskspd/wiki">DiskSpd</a>, an official disk benchmarking tool from Microsoft. It&#39;s just an executable that you download and run (as administrator).</p>
<p>It has <a href="https://github.com/Microsoft/diskspd/wiki/Command-line-and-parameters">a lot of command line options</a>, but <a href="https://www.windowscentral.com/how-test-hard-drive-performance-diskspd-windows-10">a random article I found directed me to the most relevant ones</a>.</p>
<p>In my case, I&#39;m just interested in read performance, so I ran the following two commands (the first, <code>-s</code>, is for sequential reads and the second, <code>-r</code>, is for random reads):</p>
<pre><code>diskspd -d10 -c128M -t1 -o1 -Sh -w0 -s d:\tmp.dat
diskspd -d10 -c128M -t1 -o1 -Sh -w0 -r d:\tmp.dat</code></pre><p>These tests run:</p>
<ul>
<li>For 10 seconds</li>
<li>On a 128 MB test file (which DiskSpd leaves behind after it finishes)</li>
<li>On a single thread</li>
<li>With one operation outstanding</li>
<li>Without write caching (probably unnecessary for read tests)</li>
<li>0% of operations are writes</li>
<li>In sequential or random access, as indicated</li>
<li>On a file named d:\tmp.dat (I change the drive letter for each drive, obviously)</li>
</ul>
<h1 id="results">Results</h1>
<table>
<thead>
<tr>
<th>Drive</th>
<th align="right">Sequential (MB/s)</th>
<th align="right">Random (MB/s)</th>
</tr>
</thead>
<tbody><tr>
<td>SATA SSD</td>
<td align="right">190</td>
<td align="right">130</td>
</tr>
<tr>
<td>Rotational</td>
<td align="right">55</td>
<td align="right">8</td>
</tr>
<tr>
<td>NVMe</td>
<td align="right">550</td>
<td align="right">530</td>
</tr>
</tbody></table>
<p>As expected, the NVMe drive was the fastest and the rotational drive was the slowest (especially for random reads)... but the actual gaps are enormous!</p>
<p>I guess if I ever get to a point where I have a project that is big enough that disks become the bottleneck, I can just throw everything over onto the NVMe and enjoy a ~3x speedup. Good to know!</p>
]]></description><link>https://log.schemescape.com/posts/hardware/benchmarking-drives</link><guid isPermaLink="true">https://log.schemescape.com/posts/hardware/benchmarking-drives</guid><pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Eleventy for a simple dev blog, part 2]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> for my blog. In <a href="../eleventy/">part 1</a>, I recorded my initial impression of Eleventy; in this post, I describe my experience fully integrating Eleventy into my dev blog (<a href="https://github.com/jaredkrinke/log/tree/eleventy">final code here</a>).</p>
<h1 id="background">Background</h1>
<p>I <a href="../overview/">already covered my ideal dev blog setup in detail</a>, but here&#39;s the gist of it:</p>
<ul>
<li>Content is written using <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> (because it&#39;s succinct and ubiquitous)</li>
<li>Each post is a separate file, with YAML front matter for title, date, description, keywords</li>
</ul>
<p>And the corresponding directory structure:</p>
<ul>
<li><code>content/</code>: Root directory of all blog content<ul>
<li><code>posts/</code>: Root of all blog posts<ul>
<li><code>topic1/</code>: Blog posts organized by topics<ul>
<li><code>post1.md</code>: Blog post 1</li>
<li><code>post2.md</code></li>
<li>etc.</li>
</ul>
</li>
<li><code>topic2/</code></li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
<li><code>static/</code>: Static files (namely CSS)</li>
<li><code>templates/</code>: Template/layout files</li>
</ul>
<h1 id="configuration">Configuration</h1>
<p>My initial <code>.eleventy.js</code> configuration file looked something like this:</p>
<pre><code>module.exports = function(eleventyConfig) {
    // Copy everything under &quot;static&quot; to the root of the built site (note: this is relative to this config file)
    eleventyConfig.addPassthroughCopy({ &quot;static&quot;: &quot;./&quot; });

    return {
        // Don&#39;t process Markdown first with a template language
        markdownTemplateEngine: false,

        dir: {
            input: &quot;content&quot;,
            output: &quot;out&quot;,
            includes: &quot;../templates&quot; // Note: this is relative to the input directory
        }
    }
};</code></pre><p>Note: the <code>markdownTemplateEngine: false</code> setting is to prevent Eleventy from using Liquid to process my Markdown (I don&#39;t want this step because it tries to process all instances of <code>{%</code>, etc., when I actually want to be able to use those tokens in my blog post content).</p>
<h1 id="javascript-templates-easy-to-write-hard-to-maintain">JavaScript templates: easy to write, hard to maintain</h1>
<p>After spending the last few posts railing against &quot;unintuivie&quot;, &quot;verbose&quot;, and &quot;ugly&quot; template languages like Liquid and EJS, <a href="https://www.11ty.dev/docs/languages/javascript/">Eleventy&#39;s JavaScript templates</a> felt like a shining beacon of familiarity and simplicity -- it&#39;s just JavaScript! Sure, JavaScript used to be a terrible language (what do you expect for a language that was <a href="https://web.archive.org/web/20160305202500/http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf">originally created in 10 days</a>?), but modern JavaScript is pleasant to write, especially with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a>.</p>
<p>I was able to easily dive in and create a bare bones page template (I put this in a shared library, <code>templates\shared.js</code>):</p>
<pre><code>    renderPage: (data, content) =&gt; `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;Schemescape${data.title?.length &gt; 0 ? `: ${escapeHTML(data.title)}` : &quot;&quot;}&lt;/title&gt;
        ${data.description ? `&lt;meta name=&quot;description&quot; content=&quot;${escapeHTML(data.description)}&quot; /&gt;` : &quot;&quot;}
        ${data.keywords?.length &gt; 0 ? `&lt;meta name=&quot;keywords&quot; content=&quot;${escapeHTML(data.keywords.join(&quot;,&quot;))}&quot; /&gt;` : &quot;&quot;}
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;${getPagePathToRoot(data)}/css/style.css&quot; /&gt;
        ${/* TODO: RSS */ &quot;&quot;}
    &lt;/head&gt;
    &lt;body&gt;
        &lt;main&gt;
            &lt;header&gt;&lt;h1&gt;&lt;a href=&quot;${getPagePathToRoot(data)}/&quot;&gt;Schemescape&lt;/a&gt;&lt;/h1&gt;&lt;/header&gt;
            ${content}
        &lt;/main&gt;
    &lt;/body&gt;
&lt;/html&gt;`,</code></pre><p>This probably took me 10 minutes to create. But there are a few problems I&#39;ve noticed along the way:</p>
<ul>
<li>It&#39;s hard to read because it&#39;s constant switching back and forth between strings and code (and the code would balloon if I started pulling code out of the template)</li>
<li>There&#39;s no syntax validation because it&#39;s just plain text<ul>
<li>At one point, after moving some HTML around, I forgot to delete an opening tag -- Node doesn&#39;t care because it&#39;s just opaque text! I felt bad that the browser had to try and make sense of my malformed HTML</li>
</ul>
</li>
<li>You always have to add code to escape text that might contain quotation marks, etc.<ul>
<li>Granted, other template languages can be too overzealous about escaping text, leading to mistakes I see all over the web that look like &quot;I&amp;apos;m double-escaped!&quot;</li>
</ul>
</li>
<li>As noted in a previous post, &quot;themes&quot; become JavaScript code, which seems like a security issue for anyone who wants to just download and try random themes off the web</li>
</ul>
<p>Given that I already know JavaScript, for a simple web site like mine, JavaScript templates are quick and easy. I&#39;m not sure I&#39;d want to maintain a large list of such templates, however, because they&#39;re a bit messy and error-prone.</p>
<p>Note: the template above uses some helpers defined elsewhere in the file, e.g. to compute the path to the root of the site (so I can use relative links and view my HTML directly from the file system). The full code is in <a href="https://github.com/jaredkrinke/log/blob/eleventy/templates/shared.js">my GitHub repository, on the eleventy branch</a>.</p>
<h1 id="blog-post-pages">Blog post pages</h1>
<p>Setting up blog post pages was pretty simple:</p>
<h2 id="1-create-the-html-template">1. Create the HTML template</h2>
<p>I called it <code>templates/post.11ty.js</code>:</p>
<pre><code>const escapeHTML = require(&quot;escape-html&quot;)
const { renderPage } = require(&quot;./shared&quot;);

const formatDateAsTimeElement = date =&gt; `&lt;time datetime=&quot;${date.toISOString().replace(/T.*$/, &quot;&quot;)}&quot;&gt;${dateFormatter.format(date)}&lt;/time&gt;`;

const renderArticle = data =&gt; `
&lt;article&gt;
    &lt;header&gt;
        &lt;h1&gt;&lt;a href=&quot;./&quot;&gt;${escapeHTML(data.title)}&lt;/a&gt;&lt;/h1&gt;
        &lt;p&gt;${formatDateAsTimeElement(data.page.date)}&lt;/p&gt;
    &lt;/header&gt;
    ${data.content}
&lt;/article&gt;`;

module.exports = data =&gt; renderPage(data, renderArticle(data))</code></pre><h2 id="2-inject-data-into-all-posts">2. Inject data into all posts</h2>
<p>Add <code>content/posts.json</code> to inject data to all files under the <code>content/posts</code> directory:</p>
<pre><code>{
    &quot;layout&quot;: &quot;post.11ty.js&quot;,
    &quot;tags&quot;: &quot;post&quot;
}</code></pre><p>The first setting selects the template and the second tags all the files as part of the &quot;post&quot; collection (for later iteration).</p>
<p>With those two simple steps, Eleventy will generate directories with an HTML file for each Markdown source file I write.</p>
<h1 id="adding-a-home-page">Adding a home page</h1>
<p>For now, I&#39;m just aggregating all my posts in reverse chronological order on the home page. Also pretty simple:</p>
<h2 id="1-create-the-html-template-1">1. Create the HTML template</h2>
<p>Along with my generic page template above, the template is pretty simple (note the <code>data.collections.post.slice().reverse().map(...)</code> part):</p>
<p><code>templates/index.11ty.js</code>:</p>
<pre><code>const { renderPage } = require(&quot;./shared&quot;);

const renderArticleShort = data =&gt; `
&lt;article&gt;
    &lt;header&gt;
        &lt;h1&gt;&lt;a href=&quot;.${data.page.url}&quot;&gt;${data.title}&lt;/a&gt;&lt;/h1&gt;
        &lt;p&gt;${formatDateAsTimeElement(data.page.date)}&lt;/p&gt;
    &lt;/header&gt;
    &lt;summary&gt;&lt;p&gt;${data.description}&lt;/p&gt;&lt;/summary&gt;
&lt;/article&gt;`;

module.exports = data =&gt; renderPage(data,
`&lt;ul&gt;
    ${data.collections.post.slice().reverse().map(post =&gt; `&lt;li&gt;${renderArticleShort(post.data)}&lt;/li&gt;`).join(&quot;\n&quot;)}
&lt;/ul&gt;`);</code></pre><p>Note: the <code>.slice()</code> is needed because JavaScript&#39;s <code>reverse()</code> function mutates the array (<a href="https://www.11ty.dev/docs/collections/#array-reverse">as Eleventy&#39;s documentation notes</a>).</p>
<h2 id="2-add-a-source-file">2. Add a source file</h2>
<p>The <code>content\index.md</code> file just points to the template:</p>
<pre><code>---
layout: index.11ty.js
---</code></pre><p>Eleventy will now build my <code>index.html</code> file at the root of the output directory.</p>
<h1 id="enabling-links-between-pages">Enabling links between pages</h1>
<p>I use relative links between my Markdown files for internal links. For example, the post you&#39;re reading is <a href="../eleventy-2/"><code>eleventy-2.md</code></a> and my previous post on Eleventy is <a href="../eleventy/"><code>eleventy.md</code></a>. Here&#39;s how I made that second link:</p>
<pre><code>[`eleventy.md`](eleventy.md)</code></pre><p>This setup feels natural and works great for Markdown, both in <a href="https://code.visualstudio.com/Docs/languages/markdown">Visual Studio Code&#39;s Markdown preview mode</a>, and when <a href="https://github.com/jaredkrinke/log/blob/main/content/posts/static-site-generators/eleventy-2.md">viewing Markdown files in my repository directly on GitHub</a>.</p>
<p>I was <em>hoping</em> that many static site generators would translate these links into ones that worked on the HTML web site, but so far it&#39;s seeming like that was just wishful thinking.</p>
<p>Fortunately, since I&#39;m not tweaking output locations, this translation is just a simple mechanical process (prepend &quot;../&quot; and remove the &quot;.md&quot; suffix). Even better, there is a markdown-it plugin named <a href="https://www.npmjs.com/package/markdown-it-replace-link">markdown-it-replace-link</a> for making such changes. This plugin can be integrated into Eleventy&#39;s pipeline via the <code>.eleventy.js</code> config file (after <code>npm install --save-dev markdown-it-replace-link</code>, of course):</p>
<pre><code>module.exports = function(eleventyConfig) {
    // Convert relative Markdown file links to relative post links
    const customMarkdownIt = require(&quot;markdown-it&quot;)({
            html: true,
            replaceLink: link =&gt; link.replace(/^([^/][^:]*)\.md$/, &quot;../$1&quot;),
        })
        .use(require(&quot;markdown-it-replace-link&quot;));

    eleventyConfig.setLibrary(&quot;md&quot;, customMarkdownIt);
...</code></pre><p>The regular expression just checks for relative links (not starting with &quot;/&quot; or containing a &quot;:&quot;) that end with &quot;.md&quot; and then prepends &quot;../&quot; and omits the &quot;.md&quot; suffix, to instead point to the source Markdown file&#39;s corresponding output directory (which contains an <code>index.html</code>).</p>
<h1 id="adding-an-rss-feed">Adding an RSS feed</h1>
<p>Many of the static site generators I tested out automagically generate an RSS news feed. Eleventy does not do this.</p>
<p>Eleventy&#39;s documentation points to an <a href="https://www.11ty.dev/docs/plugins/rss/">official plugin</a> for generating an <a href="https://en.wikipedia.org/wiki/Atom_(Web_standard)">Atom</a> feed.</p>
<p>But if you read the documentation, it becomes apparent that the plugin is just a couple of helpers and the actual Atom template is something you&#39;ll be copy-pasting into your repository. Interestingly, I don&#39;t see any logic in the sample template to limit the number of posts.</p>
<p>This feels like a shortcoming of Eleventy (and one that probably wouldn&#39;t be difficult to fix). I shouldn&#39;t have to maintain my own template for a standard format.</p>
<h1 id="validating-links">Validating links</h1>
<p>In the interest of catching mistakes before sharing them with the entire Internet, I&#39;d like to at least validate all of the internal links between my pages at build time.</p>
<p>My ideal implementation would be a tool that I unleash on the output HTML files, crawling relative links to ensure they&#39;re all valid and that all pages are reachable. It would also ensure that any links to anchors within pages exist. Such a tool probably exists, but I haven&#39;t found it yet.</p>
<p>For now, I&#39;m just using a quick and dirty hack that validates Markdown files exist in the process of updating the relative links noted previously. The code is fragile and slow enough that I won&#39;t advertise it anymore here, but it is in the repository linked below, if you&#39;re curious.</p>
<h1 id="and-thats-it">And that&#39;s it!</h1>
<p>It took a little while to sort out some of the above details, but since I was able to leverage my existing JavaScript knowledge, Eleventy ended up being pretty easy to integrate. As proof, this page exists, and you&#39;re reading it.</p>
<p>All of the actual code used to generate this page is <a href="https://github.com/jaredkrinke/log/tree/eleventy">up on GitHub under the &quot;eleventy&quot; branch</a>.</p>
<p><strong>Update</strong>: I ended up <a href="../metalsmith/">switching from Eleventy to Metalsmith</a> because Metalsmith has a simpler design and is easier to extend with plugins.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/eleventy-2</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/eleventy-2</guid><pubDate>Thu, 16 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Zola for a simple dev blog]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> to see which is closest to <a href="../overview/">my ideal setup</a>. Next up is <a href="https://www.getzola.org/">Zola</a>.</p>
<h1 id="zola">Zola</h1>
<p>Zola is a zero-dependency static site generator, similar to Hugo. Since it&#39;s compiled to native code, I expect it to be fast.</p>
<h2 id="installation">Installation</h2>
<p>I do my development on Windows (despite having been a Linux desktop user in the past), so where do I download the Zola binary? Let&#39;s check the <a href="https://www.getzola.org/documentation/getting-started/installation/">Zola docs</a></p>
<blockquote>
<p>Zola is available on Scoop ... and Chocolatey</p>
</blockquote>
<p>Hmmm... so I have to install software to install my software? Maybe I can go to the <a href="https://scoop.sh/">Scoop web site</a> and find a zip file? It looks like they just have a huge JSON file that points to Zola&#39;s releases on GitHub. Maybe I&#39;ll just go to the <a href="https://github.com/getzola/zola/releases">Zola release page</a> directly. Ok, found a zip file (only 7.5mb, too!). Time to dig in.</p>
<h2 id="concepts">Concepts</h2>
<p>Zola&#39;s <a href="https://www.getzola.org/documentation/getting-started/overview/">overview documentation</a> is excellent. It introduces concepts succinctly in the form of an example, while still making it easy for me to skim and jump around to quickly understand the basics. This is the sort of introduction that I wished Hugo and Eleventy had.</p>
<p>The documentation is so well organized, that I&#39;m not going to bother trying to explain the concepts here -- just go <a href="https://www.getzola.org/documentation/getting-started/overview/">read the docs</a> instead!</p>
<p>One note: Zola uses a template language called <a href="https://tera.netlify.app/docs#templates">Tera</a> that is supposed to be similar to what Django uses. That might be helpful to some folks, but I haven&#39;t used Django. I don&#39;t like the looks of the language, but the documentation seems adequate.</p>
<h2 id="first-run">First run</h2>
<p>Following the documentation to initialize Zola, it oddly demands that the directory be empty (in my case, I already have content, such as this article). This seems unnecessary given that Zola doesn&#39;t actually do anything other than create empty directories (which happen to match my existing naming scheme) along with a configuration file.</p>
<h2 id="some-opinions">Some opinions</h2>
<p>Zola is an opinionated static site generator and sometimes these opinions get in my way. For instance, despite <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> being the standard for front matter, Zola strongly encourages <a href="https://toml.io/en/">TOML</a> (which I find to be unnecessarily verbose for my simple key-string value pairs), and the documentation makes it sound like supporting YAML is a grudging favor for those migrating content out of other systems.</p>
<p>Additionally, Zola draws a line between the variables it supports and any &quot;extra&quot; variables you want to use. I&#39;m also not sure I like  mixing template input data with content, as Zola does with <code>_index.md</code> files in each section (this makes sense for, say, keywords, but not as much for custom data that exists solely to modify behavior in a parent template--I&#39;d like to do that in the child template itself).</p>
<p>Opinions are great for nudging people into good choices when they might not foresee the benefits, but I am starting to wonder if maybe Zola is a little <em>too</em> opinionated.</p>
<h2 id="templates">Templates</h2>
<p>My experience with static site generators until recently was all home-built stuff, so I don&#39;t have any experience with standard template languages like Tera, Jinja, or Liquid. I like to think my fresh eyes let me accurately grade the ergonomics of template languages for career developers.</p>
<p>So far, (as with Hugo&#39;s templates) I don&#39;t like what I see. The syntax is incredibly ugly and verbose. Here&#39;s how you mark an input to a template (I was hoping for something more like this JavaScript&#39;s template literal syntax):</p>
<pre><code>{% block content %}{% endblock %}</code></pre><p>How do I supply an input to the template?</p>
<pre><code>{% block content %}
&lt;p&gt;Content goes here&lt;/p&gt;
{% endblock content %}</code></pre><p>The definition is so similar to the declaration that I&#39;m not sure how you even tell them apart if the definition is empty.</p>
<p>Conditionals also aren&#39;t just expressions which means lots of <code>{%</code> and <code>%}</code> in my case where I just want my home page title to be &quot;Blog&quot; and all pages to be &quot;Blog: Some page&quot;:</p>
<pre><code>{% if section.extra.root %}
    Blog
{% else %}
    Blog: {{ section.title }}
{% endif %}</code></pre><p>Ok, enough griping about standard template languages (even if they do seem ripe for a Markdown-like takeover). Some people are probably perfectly at home with Tera/Jinja.</p>
<h2 id="i-guess-were-stopping-here-now">I guess we&#39;re stopping here now</h2>
<p>A little ways into integrating Zola into this blog, I hit a couple of snags:</p>
<ul>
<li><code>zola serve</code> doesn&#39;t seem to serve up all the pages that <code>zola build</code> creates -- there was a past Windows-only issue for this, but my problem seems more specific to my particular site</li>
<li>Zola doesn&#39;t seem to like that I&#39;ve grouped my posts into subdirectories (that don&#39;t represent a new type of content)</li>
</ul>
<p>If I was persistent, I probably could have solved these problems this evening, but I&#39;m not sure that Zola&#39;s opinions are compatible with my own, so I&#39;m ok with setting this experiment aside for now.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/zola</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/zola</guid><pubDate>Wed, 15 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Eleventy for a simple dev blog]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> to see which is closest to <a href="../overview/">my ideal setup</a>. Next up is <a href="https://www.11ty.dev/">Eleventy</a>.</p>
<h1 id="eleventy">Eleventy</h1>
<p>Eleventy is a Node-based static site generator that seems to be popular with people who would rather use JavaScript instead of Ruby/Jekyll.</p>
<h2 id="installation">Installation</h2>
<p>Installation is done via NPM. Obnoxiously, if you don&#39;t install globally, <a href="https://www.11ty.dev/docs/usage/">there is a non-Eleventy NPM package named &quot;eleventy&quot; that is picked up by default</a>, so you have to use <code>npx @11ty/eleventy ...</code> for commands. This is the recommended approach and I find it very awkward to type (NPM scripts seem like a good mitigating practice). At least the other package doesn&#39;t appear to obviously be name squatting malware!</p>
<h2 id="setup">Setup</h2>
<p>Configuration of input/output directories, etc. is done on the command line or in a JavaScript config file (yes, it&#39;s real JavaScript code). Their <a href="https://www.11ty.dev/docs/config/">sample</a> feels a bit convoluted for what amounts to JSON:</p>
<pre><code>module.exports = function(eleventyConfig) {
  // Return your Object options:
  return {
    dir: {
      input: &quot;views&quot;,
      output: &quot;dist&quot;
    }
  }
};</code></pre><p>I was curious what all might go in an Eleventy configuration file, so I took a peek at their <a href="https://github.com/11ty/eleventy-base-blog">official blog sample</a> and was horrified to see 142 lines of JavaScript code in their <code>.eleventy.js</code> config file. I thought this was supposed to be the simplest static site generator! Looking more closely, there appear to be helper functions defined in this configuration file. I&#39;m not going to question their design yet, but it makes me nervous.</p>
<h2 id="concepts">Concepts</h2>
<p><a href="https://www.11ty.dev/docs/">Eleventy&#39;s documentation</a> has lots of details, but there isn&#39;t a great overview of all the concepts and the associated directory structure. For example, I still haven&#39;t found a clear definition for their use of the word &quot;template&quot;.</p>
<p>I&#39;m far from an expert, but here is my understanding of Eleventy&#39;s concepts:</p>
<ul>
<li>Input: directory that content is pulled from (defaults to root)<ul>
<li>Note: Content is opt <em>out</em> not opt in, so you have to tell Eleventy which files you don&#39;t want published (this seems like a risky default to me)</li>
</ul>
</li>
<li>Output: directory where built/rendered/copied content goes (for subsequent uploading/publishing)</li>
<li>Layouts: templates for rendering content; a wide variety of template engines are supported (including Liquid, EJS, JavaScript, but but <a href="https://github.com/11ty/eleventy/issues/235"><em>not</em> JSX</a>)</li>
<li>Data: properties that come from several sources and can be used in layouts, including the file system, per-directory JSON files, templates, YAML front matter in content files</li>
<li>Collection: specified with the &quot;tags&quot; property, collections are used for iterating over multiple pieces of content</li>
<li>(Pagination, filters, shortcodes, and custom tags are other concepts I haven&#39;t needed yet)</li>
</ul>
<p>I found Eleventy&#39;s terminology to be unintuitive (templates vs. layouts vs. includes), but the concepts make sense. The <a href="https://www.11ty.dev/docs/data-cascade/">cascading data model</a> is particularly elegant.</p>
<p>The default directory structure for a blog could look like this:</p>
<ul>
<li>(root): By default, the root is the directory from which Eleventy pulls content (note: content is opt <em>out</em> not opt in)<ul>
<li><code>index.html</code>: Home page for the blog</li>
<li><code>_data</code>: Directory for site-wide data<ul>
<li><code>site.json</code>: Site-wide metadata properties</li>
</ul>
</li>
<li><code>_includes</code>: Directory for storing templates, etc.<ul>
<li><code>post.ejs</code>: EJS template for blog posts</li>
</ul>
</li>
<li><code>_site</code>: Output directory (yes, the output directory is a subdirectory of the input directory by default)</li>
<li><code>posts</code>: Directory for storing blog posts<ul>
<li><code>posts.json</code>: Metadata properties to apply to all posts (namely: <code>layout: post.ejs</code>)</li>
<li><code>something-interesting.md</code>: A blog post</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="first-run">First run</h2>
<p>Eleventy&#39;s directory structure initially seemed simpler than Hugo&#39;s, but as I dove in, I found that it muddled distinct concepts and I ended up having to change the configuration quite a bit to give me what I wanted. Because I wanted to separate content from everything else, I ended up with a <code>.eleventy.js</code> configuration file that looked like this:</p>
<pre><code>module.exports = function(eleventyConfig) {
    // Copy everything under &quot;static&quot; to the root of the built site (note: this is relative to this config file)
    eleventyConfig.addPassthroughCopy({ &quot;static&quot;: &quot;./&quot; });

    return {
        dir: {
            input: &quot;content&quot;,
            output: &quot;out&quot;,
            includes: &quot;../templates&quot; // Note: this is relative to the input directory
        }
    }
};</code></pre><p>My corresponding directory structure is visible on the <a href="https://github.com/jaredkrinke/log/tree/eleventy">eleventy branch of this repository on GitHub</a>.</p>
<h2 id="themes">Themes?</h2>
<p>My experience with Hugo themes wasn&#39;t great because they push hard to make you want to share your theme. Eleventy is basically the opposite. Because configuration is JavaScript code run in Node, you probably don&#39;t want to download others&#39; themes unless you&#39;ve gone through the code to make sure it does only what you want.</p>
<p>Not supporting themes in a safe manner could be a downside for people who don&#39;t want to create their own templates, but it&#39;s fine for me because I want to craft the HTML myself to ensure it has only what I want (simple HTML) and nothing that I don&#39;t (e.g. social media icons).</p>
<h2 id="javascript-templates">JavaScript templates</h2>
<p>Originally, I planned to use a standard template system because that knowledge would be portable across different static site generators. But as I looked at examples of Hugo&#39;s templates or Liquid templates, I came to the conclusion that these template languages are surprisingly ugly and unfamiliar. Eleventy supports plain old JavaScript templates which (security concerns aside, since I&#39;m writing my own templates) is convenient because it&#39;s just JavaScript. Sure, it&#39;s is a quirky language, but with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a>, it&#39;s surprisingly readable (although you have to take care to properly escape everything):</p>
<pre><code>module.exports = function(data) {
    return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;Blog: ${data.title}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;main&gt;
            &lt;header&gt;&lt;h1&gt;My Blog&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;header&gt;
                    &lt;h1&gt;${data.title}&lt;/h1&gt;
                    &lt;p&gt;Date: &lt;time&gt;${data.page.date}&lt;/time&gt;&lt;/p&gt;
                &lt;/header&gt;
                ${data.content}
            &lt;/article&gt;
        &lt;/main&gt;
    &lt;/body&gt;
&lt;/html&gt;
`
}</code></pre><h3 id="escaping-html">Escaping HTML</h3>
<p>Note: when using Eleventy&#39;s JavaScript template language, I didn&#39;t see a built-in, documented way to escape arbitrary text for inserting into HTML. The <a href="https://www.npmjs.com/package/escape-html">escape-html NPM Package</a> worked for my purposes, but now I feel like I&#39;m getting close to wanting to build my own template language.</p>
<h2 id="issues">Issues</h2>
<h3 id="relative-links-dont-work">Relative links don&#39;t work</h3>
<p>I&#39;m using relative links to <code>*.md</code> files for linking between posts, but (at least with the default configuration), those links aren&#39;t being being updated to point to the resulting HTML files. Note: I&#39;m not implying that Eleventy told me this would work -- it&#39;s just part of my desired workflow.</p>
<h3 id="markdown-post-processed-by-default">Markdown post-processed by default</h3>
<p>In one of my posts, written in Markdown, I show Liquid/Tera/Jinja syntax (e.g. <code>{%</code>) inside a code block. With my mostly-default setup, Eleventy tried to interpret this as template syntax, which is definitely not what I would have expected (it&#39;s Markdown, not a template!). Fortunately, you can disable this behavior with the <a href="https://www.11ty.dev/docs/config/#default-template-engine-for-markdown-files">markdownTemplateEngine: false</a> setting.</p>
<h3 id="page-urls-arent-relative">Page URLs aren&#39;t relative</h3>
<p>This problem isn&#39;t unique to Eleventy (and arguably it&#39;s easier to handle in Eleventy&#39;s JavaScript template language), but Eleventy doesn&#39;t supply relative links to posts -- the <code>page.url</code> property starts with <code>/</code>. This prevents you from just viewing the HTML files directly from the file system (and it also makes it difficult to host a site in a subdirectory).</p>
<p>In my case, since it&#39;s just JavaScript code hosted in Node anyway, I&#39;m using Node&#39;s <a href="https://nodejs.org/api/path.html#path_path_relative_from_to">path.posix API</a> to compute the relative path to the site root.</p>
<h2 id="lets-stop-there">Let&#39;s stop there</h2>
<p>That&#39;s probably enough for one post.</p>
<p>Overall, ramping up on Eleventy was more confusing than I anticipated, but all the pain I felt around Hugo&#39;s template language was partially avoided in Eleventy by the ability to use good old JavaScript code. I&#39;m not a fan of some of the design decisions (namely, drawing content from the root folder), but I feel like I could actually end up choosing Eleventy just because it prevents me from having to learn (and, later, remember) another programming language.</p>
<p><strong>Update</strong>: I fully integrated Eleventy into my dev blog, details are in <a href="../eleventy-2/">part 2</a>.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/eleventy</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/eleventy</guid><pubDate>Tue, 14 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>