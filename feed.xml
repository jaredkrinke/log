<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Wed, 29 Sep 2021 04:57:28 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[WebAssembly and C libraries]]></title><description><![CDATA[<p>In the <a href="../trivial-example/">last post</a>, I compiled a trivial C function to WebAssembly. This was a good learning exercise, but I didn&#39;t use the C standard library, so compiling the code was trivial. Let&#39;s look into how to use the C standard library when compiling C to WebAssembly with Clang/LLVM.</p>
<h1 id="is-this-even-a-good-idea">Is this even a good idea?</h1>
<p>WebAssembly is simple, which is nice for getting started. It&#39;s also extremely limited (at least, in the browser). In order to compile typical C code to WebAssembly, you need a C standard library.</p>
<p>Obviously, the browser doesn&#39;t supply a C run time to WebAssembly modules (any language could be compiled to WebAssembly), so that means that the module itself has to include all the functionality it uses from the C library within itself (or get it from another module). In other words, it&#39;s statically linked.</p>
<p>How much overhead is including the C library in every module going to add? That&#39;s a good question, that I&#39;m hoping to answer eventually.</p>
<h1 id="which-c-library-to-use">Which C library to use?</h1>
<p>In hopes of avoiding writing my own C library, I looked around for existing C libraries (either already compiled to WebAssembly or simple enough that there&#39;s hope I could compile to WebAssembly myself). Here&#39;s what I found (and I&#39;m sure there are many other options I haven&#39;t run across yet):</p>
<ul>
<li><a href="https://github.com/emscripten-core/emscripten">Emscripten</a>: Modified version of <a href="https://musl.libc.org/">musl libc</a> that can run in a browser</li>
<li><a href="https://github.com/WebAssembly/wasi-libc">WASI libc</a>: Also built on musl (I think), but designed to run on top of <a href="https://wasi.dev/">WASI</a>--I didn&#39;t think this would run in the browser, but <a href="https://depth-first.com/articles/2019/10/16/compiling-c-to-webassembly-and-running-it-without-emscripten/">this blog post indicates otherwise</a></li>
<li><a href="https://github.com/embeddedartistry/libc">Embedded Artistry libc</a>: Designed for embedded applications; I&#39;m hoping this would be easy to bring up on a new platform like WebAssembly</li>
<li><strong>Build your own!</strong> If you only need a handful of functions, maybe you can implement them yourself (here&#39;s <a href="https://dassur.ma/things/c-to-webassembly/">one great example with a trivial allocator</a>)</li>
</ul>
<p>I&#39;m going to continue avoiding Emscripten because a) it wants me to install Python first and b) I&#39;d like to keep things as simple as possible. I didn&#39;t think WASI&#39;s C library would work for me in the browser, but I&#39;m going to try it anyway.</p>
<h1 id="setup-for-wasi-libc">Setup for WASI libc</h1>
<p>In order to compile against a C library, you need header files and compiled objects (in an archive) or a shared library (a concept that I don&#39;t think exists for WebAssembly since they use modules for that purpose). Note that we&#39;re basically cross-compiling for a different architecture.</p>
<p>Fortunately, <a href="https://github.com/WebAssembly/wasi-sdk">WASI provides an SDK for exactly this purpose</a>. I downloaded the latest release (~140 MB) and took a peek at the contents:</p>
<ul>
<li><code>bin/</code>: Oh, look, Clang and LLVM -- I guess I should have just started here!</li>
<li><code>lib/clang/11.0.0/lib/wasi/libclang_rt.builtins-wasm32.a</code>: This archive contains WebAssembly implementations of so-called &quot;builtins&quot; that <a href="https://releases.llvm.org/11.0.0/tools/clang/docs/Toolchain.html">Clang implicitly requires</a></li>
<li><code>share/wasi-sysroot</code>: System root for the cross compiler, containing all the headers and libraries (all raw objects or archives)</li>
</ul>
<p>Note that the version of LLVM that I installed in my last post didn&#39;t come from the WASI SDK and it didn&#39;t contain the &quot;builtins&quot; archive noted above. In order to use that installation of Clang/LLVM, I needed to copy <code>libclang_rt.builtins-wasm32.a</code> into my installation (fortunately the eventual error message you see provides the exact destination path).</p>
<h1 id="a-slightly-less-trivial-example">A slightly less trivial example</h1>
<h2 id="source-code">Source code</h2>
<p>Here&#39;s the C source for my test module that uses the WASI C library (<code>sine.c</code>):</p>
<pre><code>#include &lt;math.h&gt;

#define WASM_EXPORT_AS(name) __attribute__((export_name(name)))
#define WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol

double WASM_EXPORT(sine)(double theta) {
    return sin(theta);
}</code></pre><p>All I&#39;m doing is exposing <code>sin</code> from <code>math.h</code> as an export named <code>sine</code>.</p>
<h2 id="compiling">Compiling</h2>
<p>The build command is a bit more complicated than <a href="../trivial-example/#compiling-the-code">last time</a>:</p>
<ul>
<li><code>-nostdlib</code> is gone since we&#39;re using the C standard library this time</li>
<li><code>-nostartfiles</code> is present because we don&#39;t need to link in any bootstrapping entry point to call <code>main()</code> (we don&#39;t have a <code>main()</code>)</li>
<li><code>-target wasm32-wasi</code> could be updated to specify the &quot;operating system&quot; (used loosely here) as WASI</li>
<li><code>--sysroot wasi-sdk-12.0/share/wasi-sysroot</code> to point to the cross-compiler system root that came from the WASI SDK</li>
</ul>
<p>Note that in this example, I extracted the WASI SDK into a subfolder of my project (the <a href="https://github.com/WebAssembly/wasi-sdk">SDK&#39;s README has an example as well</a>).</p>
<p>Here&#39;s the build command (note: I omitted the <code>-target</code> option because I&#39;m using the WASI SDK&#39;s Clang, which defaults to targeting <code>wasm32-wasi</code>):</p>
<pre><code>wasi-sdk-12.0\bin\clang.exe -Os --sysroot wasi-sdk-12.0/share/wasi-sysroot -nostartfiles -Wl,--no-entry sine.c -o sine.wasm &amp;&amp; dir sine.wasm</code></pre><h2 id="calling-from-node">Calling from Node</h2>
<pre><code>const fs = require(&#39;fs&#39;);
(async () =&gt; {
    const module = await WebAssembly.instantiate(await fs.promises.readFile(&quot;./sine.wasm&quot;));
    const sine = module.instance.exports.sine;
    console.log(sine(1.57));
})();</code></pre><p>Output: 0.9999996829318346 (looks reasonable, since 1.57 is approximately pi/2 and so sine of that angle should be roughly 1).</p>
<h2 id="calling-from-a-browser">Calling from a browser</h2>
<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;The value of sin(1.57) is &lt;span id=&quot;result&quot;&gt;?&lt;/span&gt;&lt;/p&gt;

        &lt;script&gt;
            (async () =&gt; {
                const module = await WebAssembly.instantiateStreaming(fetch(&quot;./sine.wasm&quot;));
                const sine = module.instance.exports.sine;
                document.getElementById(&quot;result&quot;).innerText = sine(1.57);
            })();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Result:</p>
<pre><code>The value of sin(1.57) is 0.9999996829318346</code></pre><p>Looks like the WASI libc works in the browser, at least in a case like this where no system calls are needed.</p>
<h1 id="overhead">Overhead</h1>
<p>Earlier, I was wondering how much overhead there is in linking against a C standard library for WebAssembly. My understanding is that linking for C is done a per-function level, so you&#39;re only pulling in what you need. Here are some measurements I took (and yes, I linked in <code>malloc</code> but not <code>free</code>):</p>
<table>
<thead>
<tr>
<th align="left">Dependencies</th>
<th align="right">Module size (in bytes)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">(none)</td>
<td align="right">207</td>
</tr>
<tr>
<td align="left"><code>sin</code></td>
<td align="right">7851</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>cos</code></td>
<td align="right">8116</td>
</tr>
<tr>
<td align="left"><code>malloc</code></td>
<td align="right">7350</td>
</tr>
<tr>
<td align="left"><code>sin</code>, <code>malloc</code></td>
<td align="right">14995</td>
</tr>
</tbody></table>
<p>Not great, but also not terrible. My hope is that WebAssembly written in C <em>and using the C standard library</em> is uncommon, and generally only used for hosting programs with large C code bases that would be prohibitively time-consuming to rewrite.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, that could have gone a lot worse.</p>
<p>I&#39;m still not thrilled with the overhead of statically linking <em>everything</em>, and the thought of each module essentially having its own allocator is a bit alarming, but I need to remind myself that the alternatives are often worse. For example, if rewriting a C program in JavaScript isn&#39;t in the cards, the previous best options were either transpiling the C code to something like asm.js or, even worse, emulating an x86 CPU in the browser (using JavaScript) and running existing binaries.</p>
<p>I will state, however, that I&#39;m not quite as thrilled with the idea of compiling C programs to WebAssembly to support &quot;run anywhere&quot; scenarios as I was before I started this exercise.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/c-standard-library-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/c-standard-library-example</guid><pubDate>Tue, 28 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[A trivial WebAssembly example]]></title><description><![CDATA[<p>In the last post, I provided an <a href="../overview/">overview of WebAssembly</a>. In this post, I&#39;m going to build and run a complete (but trivial) WebAssembly module in C using <a href="https://llvm.org/">LLVM</a> and <a href="https://clang.llvm.org/">Clang</a>.</p>
<p>All of the code is here: <a href="https://github.com/jaredkrinke/webassembly-trivial-example">webassembly-trivial-example</a>.</p>
<h1 id="aside">Aside</h1>
<p>It looks like someone else was frustrated with Emscripten in the past, so they wrote a post about <a href="http://schellcode.github.io/webassembly-without-emscripten">WebAssembly without Emscripten</a>. Their guide was helpful, but I&#39;m not sure if it&#39;s up to date. I also found their Makefiles to be excessively complex.</p>
<h1 id="setup">Setup</h1>
<p>First, download and install LLVM (I used <a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">LLVM 12.0.1</a>) from the LLVM GitHub releases page (note: 180 MB download that expands to <em>1.8 GB</em> installed). The programs I&#39;m actually planning to use are <code>clang</code> and <code>wasm-ld</code>.</p>
<p>I also wanted to inspect the output WebAssembly, so I needed the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>, which was a much more reasonable ~2 MB download (note: the Windows version is a gzipped tarball instead of a zip file). I&#39;m going to use <code>wasm2wat</code> for disassembly.</p>
<h2 id="some-notes-on-c">Some notes on C</h2>
<p>C compilation is usually done as follows:</p>
<ol>
<li>Run the preprocessor (<code>cpp</code>) to expand macros and includes (often on many source files)</li>
<li>Compile the preprocessed code into object files</li>
<li>Link everything into a final binary</li>
</ol>
<p>A decent overview of the most common command line arguments for a <em>different</em> compiler is <a href="https://www.thegeekstuff.com/2012/10/gcc-compiler-options/">here</a>. Many of the options are identical for most C compilers.</p>
<h1 id="implementing-a-trivial-function">Implementing a trivial function</h1>
<p>I&#39;m going to start with a very simple example (just to reduce the number of things that could go wrong).</p>
<h2 id="source-code">Source code</h2>
<p>File name: &quot;add.c&quot;:</p>
<pre><code>int add(int a, int b) {
    return a + b;
}</code></pre><h2 id="compiling-the-code">Compiling the code</h2>
<p>First, I&#39;m just going to compile (but not link) the code, to see what happens.</p>
<pre><code>clang -target wasm32 -Os -c add.c</code></pre><ul>
<li><code>-target wasm32</code> tells Clang to tell LLVM to produce 32-bit WebAssembly output (note: as of today, <a href="https://github.com/WebAssembly/proposals">64-bit memory support is in progress</a>)</li>
<li><code>-Os</code> tells Clang to optimize for size (I did this in hopes of getting simpler, more readable code)</li>
<li><code>-c</code> tells Clang to compile, but not link</li>
<li><code>add.c</code> is the source file</li>
</ul>
<p>Since I&#39;m compiling and not linking, this command generates an object file named &quot;add.o&quot;.</p>
<h2 id="disassembling-the-object-file">Disassembling the object file</h2>
<p>Run the disassembler:</p>
<pre><code>wasm2wat add.o</code></pre><p>And it produces the following surprisingly readable output:</p>
<pre><code>(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (import &quot;env&quot; &quot;__linear_memory&quot; (memory (;0;) 0))
  (func $add (type 0) (param i32 i32) (result i32)
    local.get 1
    local.get 0
    i32.add))</code></pre><p>MDN has a great <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">explanation of the Web Assembly text format</a> (&quot;.wat&quot; files). The syntax is based on <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> (similar to <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>). Note that inline comments are delimited by semicolons (e.g. <code>; comment goes here ;</code>), as noted in <a href="https://github.com/WebAssembly/spec/blob/master/interpreter/README.md#s-expression-syntax">this more detailed look at Web Assembly text format syntax.</a>.</p>
<p>Breaking down the first two lines:</p>
<ul>
<li><code>module</code> is the root and encloses the entire module</li>
<li><code>type</code> denotes a type that can be later referenced<ul>
<li><code>(;0;)</code> is an empty list (<code>;0;</code> is just a comment) for the name of the type</li>
<li><code>func</code> denotes a function type<ul>
<li><code>param</code> denotes a list of function arguments</li>
<li><code>i32</code> is a <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&#39;s complement</a> 32-bit integer<ul>
<li>Note: there is no corresponding &quot;unsigned&quot; type--instructions themselves indicate the expected sign of operands, as needed (e.g. for division)</li>
</ul>
</li>
<li><code>result</code> is a list of result values (<a href="https://github.com/WebAssembly/multi-value">support for multiple result values</a> was added in April of 2020)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So far, we have a module and an unnamed type (which can be referenced by index 0) for a function taking two 32-bit integers and returning one 32-bit integer. Moving on:</p>
<ul>
<li><code>import</code> is used to indicate data that is passed into the module from the host<ul>
<li><code>&quot;env&quot; &quot;__linear_memory&quot;</code> indicates the import is from the &quot;env&quot; module and the item being imported is &quot;__linear_memory&quot; (these are arbitrary strings that must match the instantiation code in the host)</li>
<li><code>(memory (;0;) 0)</code> specifies an unnamed memory, which must have an initial size of at least zero 64 KB pages<ul>
<li>I believe this could have been omitted from the output in this trivial example</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The host code would need to pass in a (zero-sized) memory buffer named <code>env.__linear_memory</code>. On to the actual code:</p>
<ul>
<li><code>func</code> defines a function<ul>
<li><code>$add</code> is the name of the function (names are prefixed with <code>$</code>)</li>
<li><code>(type 0)</code> refers to the type zero, defined previously: (i32, i32) =&gt; (i32)</li>
<li>The function type/signature/prototype is then specified -- I&#39;m not sure why the type needs to be duplicated here</li>
<li>The function body follows as a series of instructions (here&#39;s the <a href="https://webassembly.github.io/spec/core/syntax/instructions.html">full list of WebAssembly instructions</a>)</li>
</ul>
</li>
</ul>
<p>Looking at the function body, note that local values are referenced by a zero-based index that starts with the function arguments and then continues on to any local variables:</p>
<ul>
<li><code>local.get 1</code> gets the second argument and pushes it onto the stack</li>
<li><code>local.get 0</code> gets the first argument and pushes it onto the stack</li>
<li><code>i32.add</code> pops the two arguments off and pushes their sum onto the stack<ul>
<li>The return value is just the last argument left on the stack, so no additional instructions are required</li>
</ul>
</li>
</ul>
<p>It looks like the C code compiled correctly and the output WAT seems reasonable. So far, so good.</p>
<h2 id="linking">Linking</h2>
<p>Note that my original Clang command specified <code>-c</code>, so it only compiled the code and never ran the linker. Let&#39;s go all the way this time:</p>
<pre><code>clang -target wasm32 -Os -nostdlib -Wl,--no-entry add.c -o add.wasm</code></pre><p>I removed <code>-c</code> and added some new arguments:</p>
<ul>
<li><code>-nostdlib</code> indicates that the C standard library should not be used (it&#39;s not needed in this case, and I don&#39;t have it available anyway)</li>
<li><code>-Wl,--no-entry</code> tells the linker that there is no entry point (i.e. no <code>main()</code> or <code>_start()</code> function)</li>
<li><code>-o add.wasm</code> tells the linker to write the output to &quot;add.wasm&quot; (instead of the default &quot;a.out&quot; file)</li>
</ul>
<p>Disassembling &quot;add.wasm&quot; yields the following:</p>
<pre><code>(module
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (export &quot;memory&quot; (memory 0)))</code></pre><p>My code disappeared! Of course, this isn&#39;t surprising because my code has no entry point and doesn&#39;t export anything.</p>
<h3 id="memory-and-a-stack">Memory and a stack</h3>
<p>Interestingly, this most recent disassembly shows some other changes:</p>
<ul>
<li>A block of linear memory that starts at 2 pages long is declared</li>
<li>There is a stack pointer that is initialized to 1 KB into the second page of memory</li>
<li>This memory is exported from the module</li>
<li>The seemingly unnecessary memory <em>import</em> (<code>env.__linear_memory</code>) is no longer present</li>
</ul>
<p>I have some questions about this arrangement:</p>
<ul>
<li>Why is the memory exported? Can the host code read or even modify the stack? (Spoiler: yes)</li>
<li>Does this stack solely exist to support C semantics (e.g. taking the address of a variable on the stack)? (Probably)<ul>
<li>Note that <a href="https://github.com/WebAssembly/design/blob/main/Nondeterminism.md">this WebAssembly note</a> indicates the VM&#39;s stack can&#39;t be accessed by a program (&quot;Note that this stack isn&#39;t located in the program-accessible linear memory&quot;)</li>
</ul>
</li>
</ul>
<h3 id="aside-a-webassembly-critique">Aside: a WebAssembly critique</h3>
<p>As an aside: while trying to find answers to some of my questions, I ran across an <a href="http://troubles.md/wasm-is-not-a-stack-machine/">incredibly insightful series of posts</a> that retrospectively critiques some of WebAssembly&#39;s design decisions.</p>
<h3 id="exports">Exports</h3>
<p>Back to my trivial experiment.</p>
<p>How do I tell Clang/LLVM that I want to export a function? Consulting the <a href="https://lld.llvm.org/WebAssembly.html">linker documentation</a>, it looks like I can export everything (not my preferred approach) or specify exports either on the command line or with attributes in the code. In code, the two options appear to be:</p>
<ul>
<li>Mark exports with <code>__attribute__((export_name(&quot;nameOfExport&quot;)))</code></li>
<li>Specify <code>-Wl,--export-dynamic</code> on the Clang command line and mark exports with <code>__attribute__ ((visibility (&quot;default&quot;)))</code></li>
</ul>
<p>I kind of wish there was an &quot;always export this symbol by name&quot; option that didn&#39;t require duplicating the name. C preprocessor to the rescue!</p>
<pre><code>#define WASM_EXPORT_AS(name) __attribute__((export_name(name)))
#define WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol

int WASM_EXPORT(add)(int a, int b) {
    return a + b;
}</code></pre><p>Output:</p>
<pre><code>(module
  (type (;0;) (func (param i32 i32) (result i32)))
  (func $add (type 0) (param i32 i32) (result i32)
    local.get 1
    local.get 0
    i32.add)
  (memory (;0;) 2)
  (global $__stack_pointer (mut i32) (i32.const 66560))
  (export &quot;memory&quot; (memory 0))
  (export &quot;add&quot; (func $add)))</code></pre><p>This looks like what I want. I&#39;ve got my function and it&#39;s being exported (along with a memory region that I&#39;m not actually using in my code).</p>
<h2 id="using-the-module">Using the module</h2>
<p>Now that I&#39;ve got my finished module (<code>add.wasm</code>), I need to host it somewhere.</p>
<h3 id="using-the-module-in-node">Using the module in Node</h3>
<p>Here&#39;s an example of loading the module and calling <code>add</code> in Node:</p>
<pre><code>const fs = require(&#39;fs&#39;);
(async () =&gt; {
    const module = await WebAssembly.instantiate(await fs.promises.readFile(&quot;./add.wasm&quot;));
    const add = module.instance.exports.add;
    console.log(add(2, 2));
})();</code></pre><ul>
<li><code>await fs.promises.readFile(&quot;./add.wasm&quot;)</code> initiates a file read and resumes upon completion</li>
<li><code>const module = await WebAssembly.instantiate(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>add(2, 2)</code> returns 4, as expected</li>
</ul>
<h3 id="using-the-module-in-a-web-page">Using the module in a web page</h3>
<p>Here&#39;s a web page for my trivial example:</p>
<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;The value of 2 + 2 is &lt;span id=&quot;result&quot;&gt;?&lt;/span&gt;&lt;/p&gt;

        &lt;script&gt;
            (async () =&gt; {
                const module = await WebAssembly.instantiateStreaming(fetch(&quot;./add.wasm&quot;));
                const add = module.instance.exports.add;
                document.getElementById(&quot;result&quot;).innerText = add(2, 2);
            })();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Note that using <code>fetch</code> isn&#39;t supported from the file system, so I used <a href="https://github.com/http-party/http-server">a trivial HTTP server</a> for local testing.</p>
<ul>
<li><code>fetch(&quot;./add.wasm&quot;)</code> initiates a request to load the module by relative path</li>
<li><code>const module = await WebAssembly.instantiateStreaming(...);</code> starts instantiating the module and resumes upon completion</li>
<li><code>module.instance.exports</code> contains the named exports</li>
<li><code>document.getElementById(&quot;result&quot;).innerText = add(2, 2);</code> updates the &quot;result&quot; span with the result of the call to <code>add</code></li>
</ul>
<p>To my surprise, everything worked on the first try.</p>
<p>I was also able to confirm that the module&#39;s memory was exported (<code>module.instance.exports.memory</code>) and could be read from within my browser&#39;s dev tools window. I&#39;m still not clear on why LLVM decided to export the memory by default.</p>
<h1 id="thats-it">That&#39;s it!</h1>
<p>The end result of all this was actually pretty simple. Here are some links for reference:</p>
<ul>
<li><a href="https://github.com/jaredkrinke/webassembly-trivial-example">GitHub repository with all the code and build commands</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-trivial-example/">Live demo of the module hosted in a web page</a> (using <code>WebAssembly.instantiate()</code> instead of <code>instantiateStreaming()</code> for compatibility with older browsers)</li>
</ul>
<p>Remembering how to use a C compiler on the command line, and deciphering LLVM&#39;s export semantics took a bit more time than I would have liked, but I learned a lot about WebAssembly in the process.</p>
<p>Next up, I&#39;ll see if I can get the C standard library working.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/trivial-example</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/trivial-example</guid><pubDate>Mon, 27 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly overview]]></title><description><![CDATA[<h1 id="background">Background</h1>
<h1 id="emscripten">Emscripten</h1>
<p>I first heard of <a href="https://emscripten.org/">Emscripten</a> in the mid-2010s. At the time, you could compile C code to an optimizability-focused subset of JavaScript known as <a href="http://asmjs.org/">asm.js</a>. This meant that, given the source code to a native app and appropriate implementations of system APIs, you could run <em>formerly</em> native-only programs in the browser--convenient, if you don&#39;t want to install anything.</p>
<h2 id="enter-webassembly">Enter WebAssembly</h2>
<p>In the intervening years, <a href="https://webassembly.org/">WebAssembly</a> appeared. WebAssembly is a binary format for programs that run on a portable virtual machine. This VM can be hosted in your browser, but non-browser runtimes have also sprung up (e.g. <a href="https://wasmtime.dev/">wasmtime</a>).</p>
<p>WebAssembly, to me, seems like the <a href="https://en.wikipedia.org/wiki/Holy_Grail">Holy Grail</a> of compilation targets. I wouldn&#39;t be surprised if, thanks to browser support, WebAssembly is <em>the</em> most broadly supported binary program format. What other binary format works on my desktop, phone, <a href="https://www.raspberrypi.org/">Raspberry Pi</a>?</p>
<p>Note that WebAssembly runtimes seem to be standardizing on an in-development system interface named <a href="https://wasi.dev/">WASI</a>. You probably can&#39;t write a GUI app solely with WebAssembly and WASI today, but I&#39;m sure that day is coming (in the distant future).</p>
<h2 id="one-note-on-emscripten">One note on Emscripten</h2>
<p>If you just want to port native programs to the browser, Emscripten is an environment for doing that. It even converts <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> to <a href="https://www.khronos.org/webgl/">WebGL</a> and handles the <a href="https://www.libsdl.org/">SDL</a> API. Unfortunately, just <em>installing</em> Emscripten requires Python. For now, I refuse to setup bloated software just to <em>install</em> the software I actually want, so I&#39;m skipping Emscripten.</p>
<h1 id="webassembly-concepts">WebAssembly concepts</h1>
<p>Mozilla&#39;s documentation has a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts">great overview of WebAssembly concepts</a>. There&#39;s also an <a href="https://hacks.mozilla.org/2017/07/creating-a-webassembly-module-instance-with-javascript/">approachable series of WebAssembly articles</a> on Mozilla Hacks. I&#39;ll try to summarize:</p>
<ul>
<li><strong>Module</strong>: a compiled WebAssembly binary (declaring imports and exports)</li>
<li><strong>Instance</strong>: a module along with its state (memory, table, imports)</li>
<li><strong>Memory</strong>: a read/write, resizable buffer provided to the instance</li>
<li><strong>Table</strong>: array of references that aren&#39;t directly stored in WebAssembly-accessible memory (for security reasons)<ul>
<li>The example I&#39;ve seen for this is to be able to pass function pointers into C/C++ code</li>
</ul>
</li>
</ul>
<h1 id="webassembly-formats">WebAssembly formats</h1>
<p>WebAssembly defines two formats:</p>
<ul>
<li><strong>.wasm</strong>: Binary format</li>
<li><strong>.wat</strong>: Text format (assembly)</li>
</ul>
<p>The <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> contains tools for converting between these formats. Specifically, <code>wat2wasm</code> is analogous to a very simple assembler, and <code>wasm2wat</code> to a disassembler.</p>
<h1 id="webassembly-browser-interface">WebAssembly browser interface</h1>
<p>Within the browser, WebAssembly <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running">currently needs to be loaded using JavaScript</a> (it sounds like there are plans to support loading using script tags and import statements in the future). Sadly, as of today, the recommended way to load WebAssembly (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming()</a>) is <a href="https://caniuse.com/?search=instantiateStreaming">only supported by 75% of browsers</a>. The more broadly supported <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">WebAssembly.instantiate()</a> seems cumbersome. I&#39;m hopeful that WebAssembly&#39;s ergonomics will improve, but I suppose this is just the price you pay when using new technology.</p>
<h1 id="next-steps">Next steps</h1>
<p>Armed with the above information, I think I&#39;m ready to dive in and test out WebAssembly with a trivial example. I&#39;ll report my findings in a subsequent update.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/overview</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/overview</guid><pubDate>Sat, 25 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 2)]]></title><description><![CDATA[<p>In the <a href="../diagrams/">last post</a>, I looked at options for generating diagrams from text descriptions at build time for my static site. Here&#39;s my (failed) attempt at integrating <a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a> into my site.</p>
<h1 id="mermaid-is-browser-based">Mermaid is browser-based</h1>
<p>Mermaid is built on top of <a href="https://d3js.org/">D3.js</a>, which is designed to be used in the browser. It exposes a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API reminiscent of <a href="https://jquery.com/">jQuery</a>. It directly manipulates a DOM, which means you need a browser.</p>
<p>This is a problem for my scenario where I&#39;m building my site outside of any browser in Node.</p>
<p>Mermaid provides a command line interface where you can pass in the text describing a diagram and get SVG back out, but rather than doing something sensible, it uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> to spin up a headless Chromium browser DOM (enjoy that 200+ MB download!) that D3.js manipulates, and then gets everything back out. I guess this is fine for generating, say, a PNG image file, but for SVG it seems excessively wasteful. You shouldn&#39;t need a DOM or browser just to generate XML!</p>
<h1 id="sanity-check">Sanity check</h1>
<p>Just to make sure I&#39;m not missing something obvious, let&#39;s try building a Mermaid diagram in Node without doing anything special.</p>
<h2 id="module-woes">Module woes...</h2>
<p>The first problem I hit is that Mermaid 8.13.0 with D3.js 7.0.3 won&#39;t load in either a CommonJS or ES Module environment in Node 14.17.0. If, in CommonJS mode, I try to use <code>require(&quot;mermaid&quot;)</code>, Node rightly points out that D3.js is an ES Module. If, in an ES Module, I try to use <code>import &quot;mermaid&quot;;</code>, then Mermaid tries to use <code>require()</code> on D3.js, which obviously doesn&#39;t work. This seems like a bug in Webpack&#39;s &quot;universal module&quot; pattern.</p>
<h2 id="jsdom-to-the-rescue">jsdom to the rescue?</h2>
<p><a href="https://github.com/jsdom/jsdom">jsdom</a> provides a fake DOM implementation for use in Node. Sounds promising!</p>
<p>Unfortunately, Mermaid&#39;s dependencies require some SVG functionality that jsdom doesn&#39;t implement, e.g. <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox">SVGGraphicsElement.getBBox()</a>. Alright, now it&#39;s making more sense why Mermaid has this dependency on a browser--it&#39;s using the browser&#39;s SVG API to measure text, compute transformations, and so on. I&#39;m still not thrilled with this design, but I can see how one might need to measure text when generating diagrams (althoug embedding a full Chromium engine seems like overkill).</p>
<p>I did a bit of searching to see if anyone has implemented the SVG API for use in Node, but I couldn&#39;t find anything that looked promising. There was a library for the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">Canvas</a> API that can be used in Node, which probably solved many similar problems (related to CSS and measuring fonts), but implementing SVG just so I can generate diagrams without downloading Chrome is beyond the amount of effort I&#39;m willing to put into this endeavor.</p>
<h1 id="taking-a-step-back">Taking a step back</h1>
<p>It&#39;s looking like using Mermaid on the back end is probably going to require either a significant amount of effort or a willingness to settle for using Chromium behind the scenes.</p>
<p>Rather than start investigating the performance characteristics of mermaid-cli, I think I&#39;m going to take a step back and evaluate which of Mermaid, Graphviz, and <a href="https://github.com/microsoft/automatic-graph-layout">MSAGL</a> (which I just found) has syntax I find most comfortable (while still supporting the features I&#39;m interested in). Honestly, this should have been the first step, but I was hoping that one option would be clearly easier to integrate, at which point I&#39;d probably just make do with whatever syntax and features were available.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</guid><pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 1)]]></title><description><![CDATA[<h1 id="background">Background</h1>
<p>As described in a <a href="../overview/">previous post</a>, I&#39;d like to have a static site that requires no JavaScript whatsoever to view the site in full fidelity. I&#39;d also like to be able to embed diagrams into my posts, ideally by inserting a textual description of the diagram.</p>
<p>Given how huge the NPM ecosystem is, I thought this would be trivial to setup. I might have been wrong.</p>
<h1 id="diagramming-software">Diagramming software</h1>
<p>In the past, I&#39;ve used <a href="https://graphviz.org/">Graphviz</a> for generating diagrams, with some success. That was almost 15 years ago, so I assumed today there&#39;d be something newer and more Node-friendly that I could easily integrate into my workflow.</p>
<p>After scouring the web for an hour or so, I found a couple of patterns:</p>
<ul>
<li>There were several libraries that aggregate diagramming libraries under a unified API<ul>
<li>But the component libraries were written in a wide variety of languages (Python, C, etc.), so deployment would be a huge hassle (<a href="https://kroki.io/">Kroki</a> even went so far as to recommend <em>against</em> trying to deploy your own instance)</li>
</ul>
</li>
<li>Many of the libraries were written in Java (a language I&#39;d like to avoid, if possible)</li>
<li>Most of the libraries didn&#39;t have a convenient text-based input format</li>
<li>Most of the libraries were designed to run <em>on the client</em></li>
</ul>
<p>I definitely don&#39;t want to have to install multiple programming language environments, and it seems silly to have each client re-render the same diagram on every view. I also don&#39;t want to depend on a service that is currently free, but could potentially disappear overnight.</p>
<p>My research led me to two candidate tools:</p>
<ul>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a>: Markdown-inspired JavaScript-based tool</li>
<li><a href="https://graphviz.org/">Graphviz</a>: Super old (originally created by AT&amp;T!), C-based diagramming tool</li>
</ul>
<p>Neither of these is perfect for my environment. Will they work? Probably, but how inconvenient will it be?</p>
<h2 id="mermaid">Mermaid</h2>
<p>Mermaid is written in JavaScript, so I should just be able to install it via NPM, call an API, and be done, right? Actually, no.</p>
<p>Remember, I want to insert the source code of a diagram directly into my Markdown files, but then have that rendered to SVG at build time. <a href="https://mermaid-js.github.io/mermaid/#/n00b-gettingStarted">Mermaid&#39;s deployment model</a> is to have the client parse the source code from within the page, render an image, and insert it into the DOM.</p>
<p>Ok, so I can just run that same code in Node at build time, right? Then I can skip all the client-side JavaScript? Not according to <a href="https://github.com/mermaid-js/mermaid/issues/146">an issue in Mermaid&#39;s issue tracker</a>!</p>
<p>From reading that thread, it sounds like Mermaid interacts directly with the web page&#39;s DOM when rendering. Someone created a command line tool (<a href="https://github.com/mermaidjs/mermaid.cli">mermaid.cli</a>) that apparently uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a>&#39;s headless Chromium environment to supply a functioning DOM. Apparently, this is the normal workaround for using D3.js-based graphics on the back end. I find this implementation slightly appalling.</p>
<p>I&#39;m a little bit worried about the performance of building my site when each diagram has to spin up a new process which hosts a headless Chromium browser, just to spit out SVG. I suspect it will <em>work</em>, but it seems wasteful.</p>
<p>Let&#39;s see if I can find a better option.</p>
<h2 id="graphviz">Graphviz</h2>
<p>Graphviz is old and originated at AT&amp;T, so of course it is written in C. I love C, but compiling anything with dependencies beyond the standard library is a chore. Part of what attracted me to the Node ecosystem was that most everything is written in JavaScript and, since JavaScript compilers are so fast these days, performance is surprisingly adequate most of the time.</p>
<p>Anyway, so my first thought for integration is to just make sure Graphviz is installed and then spin up a process to render diagrams. I don&#39;t want to have to start a new process each time, but it&#39;s native code, so it&#39;s probably fast enough for my needs. Taking a dependency on a binary is highly unusual in Node land, however, so I&#39;d like to find some way to avoid doing that.</p>
<p>But wait, someone already solved this problem! <a href="https://github.com/JosephusPaye/node-graphviz">node-graphviz</a> is a theoretically Node-compatible version of Graphviz. According to the package, they compiled Graphviz to a <a href="https://webassembly.org/">Web Assembly</a> module, which can be hosted and run within Node.js. No C compiler needed (for users of the library, that is)!</p>
<p>Embedding Graphviz directly seems like a very promising solution, but I haven&#39;t vetted the library to ensure it works as advertised. The code certainly is not what I was expecting to see (it&#39;s enormous!), so I&#39;m a bit skeptical.</p>
<h1 id="mermaidcli-or-node-graphviz">mermaid.cli or node-graphviz?</h1>
<p>Unfortunately, neither of the two most promising solutions appears obviously better than the other.</p>
<p>Mermaid seems nice because it appears to be broadly used and, by virtue of being newer and web-focused, likely has better support for integrating into web pages (and supporting dark mode, etc.). But I&#39;m having a difficult time getting over the idea of it requiring direct access to a DOM. That just doesn&#39;t seem like a good fit for my &quot;local build&quot; scenario. I&#39;m afraid that, even if I use the command line tool or cook up some way to avoiding handing Mermaid a DOM, it will be fragile.</p>
<p>Graphviz doesn&#39;t seem to support as many diagram types, and I&#39;m a little bit worried to take on a Web Assembly dependency, but on the other hand I&#39;ve been meaning to learn more about Web Assembly anyway. This project might be a good way to learn what goes into integrating a Web Assembly module into Node.</p>
<h1 id="next-steps">Next steps</h1>
<p>Hopefully I don&#39;t regret this decision, but I think I&#39;m going to first try integrating Mermaid. If I hit any snags or if performance is abysmal, I&#39;ll see if node-graphviz is actually what I&#39;m looking for.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams</guid><pubDate>Thu, 23 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>