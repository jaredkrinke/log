<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-07-11T15:49:30.681Z</updated>

<entry>
<title>Porting a browser-based game to Steam... on Linux</title>
<id>https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux.html"/>
<updated>2023-07-10T00:00:00.000Z</updated>
<summary type="text">I ported a web game to Steam, but it only works on Windows. Can I get it to run on Linux?</summary>
<content type="html">&lt;p&gt;Last year, I &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html&quot;&gt;ported my single-instruction programming game to Steam&lt;/a&gt;, but I &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html#should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;felt bad that it didn&amp;#39;t run on Linux&lt;/a&gt; (because I chose to use Windows-only &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt; to avoid using Electron). I&amp;#39;d like to rectify this situation, but it&amp;#39;s testing my patience.&lt;/p&gt;
&lt;h1 id=&quot;original-plan&quot;&gt;Original plan&lt;/h1&gt;
&lt;p&gt;From the beginning, I wanted to avoid using Electron because it&amp;#39;s inherently inefficient (it basically ships an entire Node+Chromium browser runtime alongside the app)... but for games it&amp;#39;s probably fine. No one is going to notice or care that a game on Steam is 100 MB instead of 10 MB.&lt;/p&gt;
&lt;p&gt;So my original plan was to port my game to Electron, add &lt;a href=&quot;https://github.com/greenheartgames/greenworks&quot;&gt;Greenworks&lt;/a&gt; (a Steam integration library), and release a native Linux version on Steam.&lt;/p&gt;
&lt;h1 id=&quot;but&quot;&gt;But...&lt;/h1&gt;
&lt;p&gt;Unfortunately, it turns out that Greenworks is no longer maintained and (more importantly) it doesn&amp;#39;t support friend leaderboards. Given that friend leaderboards are arguably the most enticing integration point with Steam for a zachlike, this is a big problem.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not opposed to learning new technologies for educational purposes, but learning about &lt;a href=&quot;https://nodejs.org/api/addons.html&quot;&gt;Node native addons&lt;/a&gt; (which version of the API? I have no idea) and &lt;a href=&quot;https://www.electronjs.org/docs/latest/tutorial/using-native-node-modules&quot;&gt;rebuilding them for Electron&amp;#39;s incompatible ABI&lt;/a&gt; does not sound &lt;em&gt;at all&lt;/em&gt; enjoyable to me at the moment. If I have to patch Greenworks, I&amp;#39;ll do it, but I&amp;#39;d prefer a solution that is better aligned with my current interests.&lt;/p&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;Speaking of solutions, what other options do I have to bring SIC-1 to Linux on Steam? The game is implemented in TypeScript, using HTML+CSS for the UI, all bundled using Parcel.&lt;/p&gt;
&lt;p&gt;A few potential approaches and some commentary follow.&lt;/p&gt;
&lt;h2 id=&quot;electron&quot;&gt;Electron&lt;/h2&gt;
&lt;p&gt;Electron is nice because it works consistently across operating systems (and Linux distributions). Some initial testing also indicates that Electron-based games on Windows can run on Linux via Proton.&lt;/p&gt;
&lt;p&gt;The biggest downside to Electron (other than its immense size) is that it&amp;#39;s completely unnecessary (all Steam-supported operating systems already contain a native browser). I also suspect that as Electron adds more script isolation features it will become even more unwieldy for simple web games.&lt;/p&gt;
&lt;p&gt;As far as interfacing with Steam&amp;#39;s API, there are a few options:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Extend Greenworks to support friend leaderboards (pros: probably the least new code; cons: requires learning about a new platform I don&amp;#39;t have any interest in, Node native addons)&lt;/li&gt;
&lt;li&gt;Create a shared library that exposes necessary Steam API functionality as simple C functions and then use one of Node&amp;#39;s foreign function interfaces to call those functions from the Windows build, using Proton on Linux (pros: might be able to reuse existing C++ code from the WebView2 version; cons: translating WebView2&amp;#39;s Windows Runtime/VARIANT structure-based API into plain C functions could get tricky)&lt;/li&gt;
&lt;li&gt;Implement the existing Steam integration code on Linux, ideally using a unifying cross-platform synchronization library (pros: native Linux binaries; cons: requires rewriting the entire Steam integration library)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;native-webview&quot;&gt;Native WebView&lt;/h2&gt;
&lt;p&gt;I could shrink the disk and memory footprint by using native WebViews, of course (via &lt;a href=&quot;https://tauri.app/&quot;&gt;Tauri&lt;/a&gt;, &lt;a href=&quot;https://neutralino.js.org/&quot;&gt;Neutralino.js&lt;/a&gt;, or &lt;a href=&quot;https://github.com/webview/webview&quot;&gt;webview&lt;/a&gt;). Steam integration would likely require a full rewrite, however.&lt;/p&gt;
&lt;p&gt;This feels like The Right Thing To Do because it removes Electron-related bloat, but then I&amp;#39;m just trading efficiency for limited functionality and a compatibility can of worms. Notably, Steam&amp;#39;s Linux Runtime doesn&amp;#39;t include a native WebView library, so I&amp;#39;d have to package one with the game, which defeats the entire purpose of using a native library.&lt;/p&gt;
&lt;p&gt;In the long term, I like this approach because it would enable efficiently shipping the game in downloadable form on other operating systems (outside of Steam).&lt;/p&gt;
&lt;p&gt;Overall, this approach aligns with my interests better, but it isn&amp;#39;t a great fit for my immediate goal of supporting Steam on Linux.&lt;/p&gt;
&lt;h2 id=&quot;new-ui-framework&quot;&gt;New UI framework&lt;/h2&gt;
&lt;p&gt;Originally, I created SIC-1 to run in the browser because it&amp;#39;s convenient and doesn&amp;#39;t require downloading anything. Since it&amp;#39;s web-native, it also starts up pretty much instantly. However, as I fleshed out the game (adding music, save data, etc.), the browser became more of a hassle than a convenience (Local Storage is unreliable, looping music basically doesn&amp;#39;t work correctly on most browsers, styling native UI elements is tricky). I absolutely want to support playing in the browser, but playing outside the browser might produce a more reliable experience.&lt;/p&gt;
&lt;p&gt;Here are a few approaches I&amp;#39;m considering:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Refactor into &lt;a href=&quot;https://reactnative.dev/&quot;&gt;React Native&lt;/a&gt; (shared across desktop and web versions)&lt;/li&gt;
&lt;li&gt;Rewrite for a real game engine that supports web export (e.g. &lt;a href=&quot;https://godotengine.org/&quot;&gt;Godot 3&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Rewrite as a terminal game, just because it sounds fun&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All of these would solve portability and Steam-related issues, but they&amp;#39;re also all a lot of work. Maybe I&amp;#39;ll tackle them &lt;em&gt;someday&lt;/em&gt;, but I don&amp;#39;t think I want to rewrite my game &lt;em&gt;today&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id=&quot;current-plan&quot;&gt;Current plan&lt;/h1&gt;
&lt;p&gt;Unfortunately, there&amp;#39;s no clear winner amongst all these options. The shortest path to Linux support on Steam probably involves Electron and either extending Greenworks or repackaging my existing Steam integration code.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m still trying to decide how important it is to me to leave the door open to non-Steam downloadable releases (on various platforms). I&amp;#39;ve always had a dream of getting a piece of software incorporated into a popular Linux distribution, and I assume using Electron would make that very unlikely (because bloat).&lt;/p&gt;
&lt;p&gt;For now, I will likely pursue the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Port the Steam release to Electron&lt;/li&gt;
&lt;li&gt;Refactor Steam integration code into a flat C interface&lt;/li&gt;
&lt;li&gt;Consume the Steam integration code using one of Node&amp;#39;s FFI libraries&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Hope&lt;/em&gt; that this new version works acceptably via Proton&lt;/li&gt;
&lt;li&gt;Consider porting (again) to a native WebView library, for use in downloadable releases on Windows, Linux, and maybe even elsewhere&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That&amp;#39;s more work than I had anticipated and the next to last step (&amp;quot;hoping&amp;quot; Proton supports it) is questionable, but I think it&amp;#39;s the simplest option that is best aligned with my interests.&lt;/p&gt;
&lt;p&gt;Hopefully I don&amp;#39;t regret this decision!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Retrospective: Lisp Game Jam (Spring 2023)</title>
<id>https://log.schemescape.com/posts/game-development/lisp-game-jam-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/lisp-game-jam-2.html"/>
<updated>2023-06-13T00:00:00.000Z</updated>
<summary type="text">I managed to implement a multiplayer browser-based game in Common Lisp!</summary>
<content type="html">&lt;p&gt;This is a follow-up to &lt;a href=&quot;https://log.schemescape.com/posts/game-development/lisp-game-jam.html&quot;&gt;my previous post about discovering Lisp Game Jame (Spring 2023)&lt;/a&gt;. In the previous post, I described my word game and implementation approach. This post covers how it all went, along with some lessons learned and general thoughts about Common Lisp.&lt;/p&gt;
&lt;p&gt;You can play the game here (but note that it&amp;#39;s designed for multiplayer):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaredkrinke.itch.io/13l/&quot;&gt;https://jaredkrinke.itch.io/13l/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source code is &lt;a href=&quot;https://github.com/jaredkrinke/thirteen-letters/&quot;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Common Lisp&lt;/a&gt; and &lt;a href=&quot;https://itch.io/jam/spring-lisp-game-jam-2023&quot;&gt;Lisp Game Jam (Spring 2023)&lt;/a&gt; was an appropriate motivator. I wanted to make a simple word scramble game that was played in real time against other players, inside the browser.&lt;/p&gt;
&lt;h1 id=&quot;the-challenge&quot;&gt;The challenge&lt;/h1&gt;
&lt;p&gt;I set a challenge for myself to write &lt;em&gt;the entire game&lt;/em&gt; in Common Lisp. Specifically, I was going to use various domain-specific/template languages to produce HTML, CSS, and JavaScript for use in the browser. (Running Common Lisp on the back end was, and is, trivial.)&lt;/p&gt;
&lt;p&gt;After some searching, I settled on the following tools/libraries:&lt;/p&gt;
&lt;h2 id=&quot;front-end&quot;&gt;Front end&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://parenscript.common-lisp.dev/&quot;&gt;Parenscript&lt;/a&gt; for translating Common Lisp to JavaScript&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ruricolist/spinneret&quot;&gt;Spinneret&lt;/a&gt; for creating HTML from s-expressions and CL code&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Inaimathi/cl-css&quot;&gt;cl-css&lt;/a&gt; for creating CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;back-end&quot;&gt;Back end&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://edicl.github.io/hunchentoot/&quot;&gt;Hunchentoot&lt;/a&gt; as a base web server&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/joaotavora/hunchensocket&quot;&gt;Hunchensocket&lt;/a&gt; for handling WebSockets on the server side&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&quot;https://github.com/hankhero/cl-json&quot;&gt;cl-json&lt;/a&gt; for encoding/decoding JSON&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://phmarek.github.io/yason/&quot;&gt;YASON&lt;/a&gt; for encoding/decoding JSON (cl-json doesn&amp;#39;t support non-BMP Unicode)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt; for running the server (sitting behind nginx for TLS support)  and compiling everything&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;day-by-day-progress&quot;&gt;Day-by-day progress&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;May 26: Generated a word list (most frequent words from the YAWL corpus)&lt;/li&gt;
&lt;li&gt;May 27: Implemented command line game loop&lt;/li&gt;
&lt;li&gt;May 28: Investigated binary distribution options (static SBCL/ECL builds, AppImages), eventually giving up&lt;/li&gt;
&lt;li&gt;May 29: Prepared backup submission (the command line version)&lt;/li&gt;
&lt;li&gt;May 30: Investigated libraries for browser-based version (Hunchensocket, Lisp in Parallel, Parenscript, Spinneret, cl-json, cl-css)&lt;/li&gt;
&lt;li&gt;May 31: Partially implemented WebSocket-based server&lt;/li&gt;
&lt;li&gt;June 1: Completed server (mostly)&lt;/li&gt;
&lt;li&gt;June 2: Discovered ngrok free tier couldn&amp;#39;t support public WebSockets, settling on standing up a simple VPS instead&lt;/li&gt;
&lt;li&gt;June 3: Implemented basic HTML+JavaScript front end&lt;/li&gt;
&lt;li&gt;June 4: Added a countdown timer, hall of fame, and mobile formatting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(After the jam ended: bug fixes, WebSocket reconnecting, input validation, code cleanup.)&lt;/p&gt;
&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;Playing the completed entry myself confirmed my original suspicion that the game is really only fun when there&amp;#39;s someone else to compete against.&lt;/p&gt;
&lt;p&gt;I had hoped that the time-limited nature of the voting period would mean that people would end up connecting at the same time as others, but that ended up being wishful thinking. With 30 submissions, each game probably only got a few minutes of playing time, so there were only a handful of times when players overlapped and actually got to compete (often against me, since I connected very frequently). It &lt;em&gt;did&lt;/em&gt; sound like those players had fun, though!&lt;/p&gt;
&lt;p&gt;Even worse, when someone was streaming their playthroughs of all the submissions, I was sitting and waiting to hop in and give the streamer some competition, but they ended up breezing through my game in the 5 minutes I happened to be away from my computer! Very poor timing on my part...&lt;/p&gt;
&lt;p&gt;Despite the lack of ideal (multiplayer) conditions, my entry had generally positive feedback, with most praise being related to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making a real-time multiplayer game that runs in the browser&lt;/li&gt;
&lt;li&gt;Using Common Lisp everywhere&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I was going to be happy with an overall placement in the middle, but Thirteen Letters actually managed to end up in the top third. Not too bad!&lt;/p&gt;
&lt;h1 id=&quot;lessons-learned&quot;&gt;Lessons learned&lt;/h1&gt;
&lt;h2 id=&quot;multiplayer-games-need-multiple-players&quot;&gt;Multiplayer games need multiple players&lt;/h2&gt;
&lt;p&gt;I knew this intuitively going into the jam. I even had a plan to pop up a notification on my phone whenever someone connected, so that I could hop in and play against them, but I wasn&amp;#39;t able to implement it in time.&lt;/p&gt;
&lt;p&gt;In retrospect, implementing notifications should have been my top priority after getting the game working. Instead, I focused on creating a &amp;quot;hall of fame&amp;quot; so that players could compete asynchronously on the leaderboard, but this wasn&amp;#39;t actually interesting because it was just about play time (how many rounds they sat through by themself) and not skill.&lt;/p&gt;
&lt;p&gt;If I ever make another multipler game jam entry, I&amp;#39;ll focus on ensuring people are able to actually play against an opponent (even if I have to secretly create a bot or just play the game &lt;em&gt;all day long&lt;/em&gt;).&lt;/p&gt;
&lt;h2 id=&quot;repl-driven-developmentdeveloping-in-production&quot;&gt;REPL-driven development/developing in production&lt;/h2&gt;
&lt;p&gt;Given that my entire motivation to learn Common Lisp was to experiment with REPL-driven development, I decided to try and develop and test as much as possible using Emacs SLIME (over a Swank connection).&lt;/p&gt;
&lt;p&gt;Overall, having a direct connection to the server was helpful for monitoring activity, enabling/disabling logging, and making small tweaks (e.g. changing formatting or adding alerts).&lt;/p&gt;
&lt;p&gt;Notably, as the deadline for the jam approached, I decided to take advantage of the client-server architecture and make it possible to &amp;quot;cheat&amp;quot; the deadline a bit: I added a channel for pushing raw HTML from the server to the client. Since the server could be modified at any time, this would theoretically allow for updating part of the game post-deadline. I didn&amp;#39;t end up needing to use this facility, but it &lt;em&gt;did&lt;/em&gt; end up becoming the &amp;quot;hall of fame&amp;quot; section at the bottom of the page. (I also planned to use it as an easter egg while someone was streaming the game, but as noted above, I missed that opportunity.)&lt;/p&gt;
&lt;p&gt;Unfortunately, I also hit a couple of snags with REPL-driven development:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Obviously, you have to &lt;em&gt;plan&lt;/em&gt; if you want to keep your code and your live service in sync&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes I&amp;#39;d modify a function or add a parameter and then forget to send it to the live service, leading to errors in the production service&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Even worse, one time I connected to the live service via Swank, modified a few things, and then suspended my laptop--this then caused &lt;em&gt;every&lt;/em&gt; HTTP request to hang while Swank was trying to log to my unresponsive laptop--oops!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On the whole, &amp;quot;developing in production&amp;quot; isn&amp;#39;t generally a good idea, but just having the ability to connect and inspect things every now and then was invaluable. This was my first time having deep, read/write access to a running service, and it&amp;#39;s something I&amp;#39;d like to use again in the future--at least for hobby projects! Connecting a REPL to an important/income-generating service would require careful planning.&lt;/p&gt;
&lt;h2 id=&quot;ngrok-for-websockets-or-not&quot;&gt;ngrok for WebSockets (or not)&lt;/h2&gt;
&lt;p&gt;Despite ngrok (a service for exposing local endpoints publicly) officially supporting WebSockets, I&amp;#39;ve come to the conclusion that their &lt;em&gt;free tier&lt;/em&gt; has no such support. The reason for this is that it appears to sniff the browser user agent string and then add an interstitial HTML page to the HTTP Upgrade request. Obviously, the WebSocket client doesn&amp;#39;t understand HTML, and just bails out with an error.&lt;/p&gt;
&lt;p&gt;ngrok is great, but in this case I ended up having to spin up a VPS in short order to get my WebSocket server working properly (an unwelcome surprise during a short game jam!).&lt;/p&gt;
&lt;h2 id=&quot;parenscript&quot;&gt;Parenscript&lt;/h2&gt;
&lt;p&gt;Parenscript seems like a great tool for:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;People who are very familiar with Common Lisp and want to translate idioms/code into JavaScript&lt;/li&gt;
&lt;li&gt;People targeting very old versions of JavaScript (back before &lt;code&gt;let&lt;/code&gt; was added, for instance)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given that I&amp;#39;m new to Common Lisp and have a lot of experience with JavaScript and TypeScript, I wasn&amp;#39;t really the target market for Parenscript. I was able to stumble through it, but the resulting code make it obvious I was thinking in JavaScript and writing in Parenscript.&lt;/p&gt;
&lt;p&gt;The most interesting part of Parenscript for me was the ability to define macros. For instance, I added a macro to wrap code in a try-catch that logged to HTML (so I could find errors even when no JavaScript debugger was available). (Note that &lt;code&gt;@&lt;/code&gt; in function position is used for accessing object properties in Parenscript, e.g. &lt;code&gt;(@ window onerror)&lt;/code&gt; would translate to &lt;code&gt;window.onerror&lt;/code&gt;.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:defpsmacro&lt;/span&gt; watch (&lt;span class=&quot;hljs-name&quot;&gt;&amp;amp;body&lt;/span&gt; body)
  `(ps&lt;span class=&quot;hljs-symbol&quot;&gt;:try&lt;/span&gt; (progn ,@body) (:catch (e) (error (+ (@ e message) &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot; (&amp;quot;&lt;/span&gt; (@ e line-number) &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously, this could be done in plain JavaScript with a regular function that takes an anonymous function for the body, but I might as well use macros while they&amp;#39;re available!&lt;/p&gt;
&lt;h2 id=&quot;generating-html-and-css&quot;&gt;Generating HTML and CSS&lt;/h2&gt;
&lt;p&gt;Being able to use concise s-expressions for generating HTML and CSS felt comfortable (and much more productive than writing HTML in Notepad, as I&amp;#39;d done 20 years prior). But HTML and CSS tooling have come a &lt;em&gt;long&lt;/em&gt; way and these days I pretty much expect context-sensitive auto-complete.&lt;/p&gt;
&lt;p&gt;In the end, I like the look of s-expressions, but I don&amp;#39;t think they actually made me more productive than I&amp;#39;d be in, say VS Code.&lt;/p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h1&gt;
&lt;p&gt;The recurring theme I&amp;#39;m noticing with Common Lisp is that it&amp;#39;s easy to mold into new workflows, and these workflows would have been life-changing 20 years ago (and arguably still are notable for their simplicity), but some of the non-Lisp tooling has caught up to (and sometimes surpassed) Common Lisp in the last 5 - 10 years. Not in all cases or in all aspects, but in most of the ones that are important to me (auto-complete, documentation, static checks, debugging).&lt;/p&gt;
&lt;p&gt;Of course, modern tools come with &amp;quot;modern&amp;quot; system requirements (i.e. unbelievable bloat), so it&amp;#39;s possible that Common Lisp with SLIME is a happy middle ground, with powerful features, and minimal bloat. It doesn&amp;#39;t matter if VS Code can do everything I need with TypeScript if I can&amp;#39;t even get VS Code to run on my laptop!&lt;/p&gt;
&lt;p&gt;Regardless, I&amp;#39;m still having fun learning Common Lisp and have no plans to abandon it, so I guess in that sense this experiment has been a success.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Lisp Game Jam (Spring 2023)</title>
<id>https://log.schemescape.com/posts/game-development/lisp-game-jam.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/lisp-game-jam.html"/>
<updated>2023-05-26T00:00:00.000Z</updated>
<summary type="text">Might as well try and make a game in Common Lisp, right?</summary>
<content type="html">&lt;p&gt;Recently, I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Common Lisp&lt;/a&gt; and so I&amp;#39;ve been keeping an eye out for practice projects. Fortunately, as I&amp;#39;m writing this, the &lt;a href=&quot;https://itch.io/jam/spring-lisp-game-jam-2023&quot;&gt;Lisp Game Jam (Spring 2023)&lt;/a&gt; is just about to start, so I guess I&amp;#39;m doing that now.&lt;/p&gt;
&lt;p&gt;For the time being, I&amp;#39;ll just describe the (tiny) game I have in mind.  I&amp;#39;m not terribly confident that I&amp;#39;ll be able to complete anything within the next ten days, but I&amp;#39;ll give it a try anyway!&lt;/p&gt;
&lt;h1 id=&quot;a-word-game&quot;&gt;A word game&lt;/h1&gt;
&lt;p&gt;The goal of the game is to look at a bunch of letters and then, as quickly as possible, find the longest word that can be constructed by drawing from the given set of letters (without replacement). Ideally, this would be a real-time, global competition, but I doubt I&amp;#39;ll be able to get anywhere close to that within 10 days (of roughly 1 - 2 hours per day, at best, of development time).&lt;/p&gt;
&lt;p&gt;When I originally had this idea, I gave it the intentionally terrible name of &lt;strong&gt;Longle&lt;/strong&gt; (&amp;quot;long&amp;quot; + &amp;quot;Boggle&amp;quot;). Today, I&amp;#39;m thinking I&amp;#39;ll call it &lt;strong&gt;Thirteen Letters&lt;/strong&gt; (actual number subject to change).&lt;/p&gt;
&lt;h1 id=&quot;plan&quot;&gt;Plan&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s my rough plan for implementing this game:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find or create a word list&lt;/li&gt;
&lt;li&gt;Consider reducing that list (based on observed word frequencies) to a set of difficult, but reasonable, puzzles&lt;/li&gt;
&lt;li&gt;Implement a simple terminal version of the game that just records how long it takes for the player to identify the longest word&lt;/li&gt;
&lt;li&gt;If time permits, create a service to distribute puzzles and record the &lt;em&gt;actual&lt;/em&gt; time taken to get a response&lt;/li&gt;
&lt;li&gt;If time is abundant, create a service to host global competitions with 30 - 60 second rounds and resulting scoreboards&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;progress&quot;&gt;Progress&lt;/h1&gt;
&lt;p&gt;As of right now (May 26th, at least as far as UTC is concerned), I&amp;#39;m struggling with the first item. The best word lists I&amp;#39;ve found so far have been copyrighted works related to Scrabble. Other than obvious legal risks, these lists also have a cap on the length of words. Most of the other word lists I&amp;#39;ve found contain proper nouns, lack inflected nouns/verbs, or contain huge amounts of questionable &amp;quot;words&amp;quot; (for example: &amp;quot;zzzs&amp;quot;).&lt;/p&gt;
&lt;p&gt;For now, I think my best bet is to use the public domain &lt;a href=&quot;https://github.com/elasticdog/yawl&quot;&gt;YAWL&lt;/a&gt; word list, possibly filtered by some arbitrary frequency cutoff based on the Google Trillion Word Corpus via &lt;a href=&quot;http://norvig.com/ngrams/&quot;&gt;Peter Norvig&amp;#39;s web site&lt;/a&gt;. After exploring this a bit, it looks like just ensuring the word is in the top ~300,000 most frequent words may be sufficient to get a set of words that I consider to be legitimate.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Resources for learning Common Lisp</title>
<id>https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html"/>
<updated>2023-05-15T00:00:00.000Z</updated>
<summary type="text">Here are the resources I&apos;ve personally found most helpful for learning Common Lisp.</summary>
<content type="html">&lt;p&gt;In order to test out fully interactive program development (&lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html&quot;&gt;as noted previously&lt;/a&gt;), I&amp;#39;ve been learning Common Lisp. I assumed that it would take a while to catch up on nearly four decades of Common Lisp&amp;#39;s progress and... I was not wrong about that. On the plus side, given the long timeline, there &lt;em&gt;are&lt;/em&gt; a lot of resources available. On the flip side, they&amp;#39;re not always up to date.&lt;/p&gt;
&lt;p&gt;Regardless, here are the resources that I&amp;#39;ve found most helpful over the last couple of weeks. My intention is to keep this list up to date as I go.&lt;/p&gt;
&lt;h1 id=&quot;introductory-materials&quot;&gt;Introductory materials&lt;/h1&gt;
&lt;p&gt;In descending order of how much time I&amp;#39;ve spent studying them (i.e. in completely arbitrary order):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gigamonkeys.com/book/&quot;&gt;&lt;strong&gt;Practical Common Lisp&lt;/strong&gt;&lt;/a&gt; by Peter Seibel&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/cover.html&quot;&gt;&lt;strong&gt;Successful Lisp&lt;/strong&gt;&lt;/a&gt; by David B. Lamkins&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leanpub.com/lovinglisp&quot;&gt;&lt;strong&gt;Loving Common Lisp, or the Savvy Programmer&amp;#39;s Secret Weapon&lt;/strong&gt;&lt;/a&gt; by Mark Watson&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;in-depth-materials&quot;&gt;In-depth materials&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Various topics: &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/&quot;&gt;Common Lisp Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debugging: &lt;a href=&quot;https://malisper.me/debugging-lisp-part-1-recompilation/&quot;&gt;Debugging Lisp (series)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Packaging/libraries: &lt;a href=&quot;https://lispmethods.com/libraries.html&quot;&gt;Source Code Organization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The LOOP macro: &lt;a href=&quot;https://www.ai.sri.com/~pkarp/loop.html&quot;&gt;Tutorial for the Common Lisp Loop Macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON libraries: &lt;a href=&quot;https://sabracrolleton.github.io/json-review.html&quot;&gt;Review of CL JSON libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;resource-collections&quot;&gt;Resource collections:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;List of libraries/tools: &lt;a href=&quot;https://awesome-cl.com/&quot;&gt;Awesome Common Lisp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;List of books: &lt;a href=&quot;https://lisp-lang.org/books/&quot;&gt;lisp-lang.org/books&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;general-reference&quot;&gt;General reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://clhs.lisp.se/Front/index.htm&quot;&gt;Common Lisp HyperSpec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-great-but-what-have-you-been-doing&quot;&gt;That&amp;#39;s great, but what have you been &lt;em&gt;doing&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s mostly a topic for a future post. Briefly: my first project has been building a service that hosts webhooks which implement &lt;a href=&quot;https://play.battlesnake.com/&quot;&gt;Battlesnake&lt;/a&gt; clients. Surely there&amp;#39;s no more noble endeavour than programming games!&lt;/p&gt;
&lt;p&gt;Battlesnake is a competitive programming game where snakes move around a grid collecting food and trying not to collide with each other or the walls. Each snake is implemented as a webhook which is given 500 milliseconds to respond with the direction it would like to move. It&amp;#39;s a simple concept, but that just leaves lots of room for optimization. As an aside, the global leaderboard is a little bit pointless in that it can&amp;#39;t take into account hardware, so for all I know my little netbook is competing with a rack of servers, but I&amp;#39;m still having fun.&lt;/p&gt;
&lt;p&gt;Hopefully I&amp;#39;ll have more to say about Battlesnake and Common Lisp soon!&lt;/p&gt;
</content>
</entry>
<entry>
<title>It&apos;s 2023, so of course I&apos;m learning Common Lisp</title>
<id>https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html"/>
<updated>2023-04-25T00:00:00.000Z</updated>
<summary type="text">I&apos;m traveling back in time to explore an ancient development workflow that is somehow more modern than today&apos;s workflows.</summary>
<content type="html">&lt;p&gt;I&amp;#39;ve &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages.html&quot;&gt;spent&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-2.html&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/future-proof-languages-3.html&quot;&gt;time&lt;/a&gt; contemplating future-proof programming languages because I want to enusre that code I write will be usable in the future. Generally, if I want to build something and share it with others, I&amp;#39;m a pragmatist, so I&amp;#39;ll &lt;del&gt;use JavaScript&lt;/del&gt; choose a programming language that is popular, portable, and convenient.&lt;/p&gt;
&lt;p&gt;But &lt;em&gt;other times&lt;/em&gt;, I just want to have fun and experiment with other programming languages and tools. In that vein, I&amp;#39;ve been monitoring a few single-syllable, intriguing-but-maybe-not-future-proof programming languages such as &lt;a href=&quot;https://nim-lang.org/&quot;&gt;Nim&lt;/a&gt; and &lt;a href=&quot;https://ziglang.org/&quot;&gt;Zig&lt;/a&gt;. Sometimes these experiments open my eyes to new ways of programming or new tools that eventually become indispensible.&lt;/p&gt;
&lt;h1 id=&quot;janet&quot;&gt;Janet&lt;/h1&gt;
&lt;p&gt;Very recently, I ran across a newly-published (free) book about the &lt;a href=&quot;https://janet-lang.org/&quot;&gt;Janet&lt;/a&gt; programming language called &lt;a href=&quot;https://janet.guide/&quot;&gt;Janet for Mortals&lt;/a&gt; and it piqued my interest. Janet is a relatively small Lisp/Clojure-inspired scripting language that tries to fill a similar niche to Lua, but with an actual standard library (and, of course, Lisp-style metaprogramming and compile-time execution via macros).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Janet for Mortals&lt;/strong&gt; is an entertaining and informative read, and it gave me the nudge I needed to become interested in Lisps again. I had previously abandoned using Scheme because, frankly, I ran out of free time for exploratory programming. But while I was reading about Janet, I kept coming back to one question: why should I use Janet instead of an established Lisp, e.g. Scheme?&lt;/p&gt;
&lt;p&gt;For me, the most attractive qualities of Janet (other than general Lispiness) are portability, embeddability, and &lt;a href=&quot;https://janet-lang.org/docs/peg.html&quot;&gt;Parsing Expression Grammars&lt;/a&gt;. Realistically, however, I don&amp;#39;t currently have any need to embed a language, so that leaves portability and parsing. As far as portability, &lt;a href=&quot;http://www.call-cc.org/&quot;&gt;CHICKEN Scheme&lt;/a&gt;, &lt;a href=&quot;https://www.gnu.org/software/clisp/&quot;&gt;CLISP&lt;/a&gt;, and &lt;a href=&quot;http://www.sbcl.org/&quot;&gt;Steel Bank Common Lisp&lt;/a&gt; looked acceptable. For parsing, &lt;a href=&quot;https://bford.info/packrat/&quot;&gt;Packrat&lt;/a&gt; looked reasonable.&lt;/p&gt;
&lt;p&gt;At this point, I started to run out of reasons to pursue Janet instead of an established Lisp.&lt;/p&gt;
&lt;h1 id=&quot;common-lisp&quot;&gt;Common Lisp&lt;/h1&gt;
&lt;p&gt;During my research, I ran across a &lt;a href=&quot;https://mikelevins.github.io/posts/2020-12-18-repl-driven/&quot;&gt;blog post describing Common Lisp&amp;#39;s (mostly) unique REPL-driven workflow&lt;/a&gt;. In that post, the author describes handling a runtime error by just fixing the broken code--in-place, without any restarts:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Try this in your favorite repl:&lt;/p&gt;
&lt;p&gt;Define a function, foo, that calls some other function, bar, that is not yet defined. Now call foo. What happens?&lt;/p&gt;
&lt;p&gt;Obviously, the call to foo breaks, because bar is not defined. But what happens when it breaks?&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;The answer to that question is the differentiating point of repl-driven programming. In an old-fashioned Lisp or Smalltalk environment, the break in foo drops you into a breakloop.&lt;/p&gt;
&lt;p&gt;A breakloop is a full-featured repl, complete with all of the tools of the main repl, but it exists inside the dynamic environment of the broken function. From the breakloop you can roam up and down the suspended call stack, examining all variables that are lexically visible from each stack frame. In fact, you can inspect all live data in the running program.&lt;/p&gt;
&lt;p&gt;What&amp;#39;s more, you can edit all live data in the program. If you think that a break was caused by a wrong value in some particular variable or field, you can interactively change it and resume the suspended function.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;Moreover, because the entire language and development system are available, unrestricted, in the repl, you can define the missing function bar, resume foo, and get a sensible result.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I&amp;#39;ve seen various (often unreliable) &amp;quot;edit and continue&amp;quot; features over the years, but I didn&amp;#39;t realize that Common Lisp was built with this sort of workflow in mind.&lt;/p&gt;
&lt;p&gt;When I first learned to program, I used &amp;quot;printf debugging&amp;quot;, where I&amp;#39;d temporarily add in code to log values, recompile, run, and inspect the output to troubleshoot problems. Eventually, I ran into scenarios where I couldn&amp;#39;t modify the program or rerun it, so I learned to use a debugger. Using a real debugger is definitely the right thing to do, but setting up a debugging environment is often painful (and sometimes impossible).&lt;/p&gt;
&lt;p&gt;Common Lisp seems to take debugging a step further. Sure, I&amp;#39;ve modified memory in a debugger to test out potential fixes, but being able to rewrite code and patch into a live process &lt;em&gt;in a sane way&lt;/em&gt; sounds amazing--almost too good to be true.&lt;/p&gt;
&lt;p&gt;That new workflow is my motivation for learning Common Lisp. I want to try interactively building a program to see if it&amp;#39;s a pleasant way to work.&lt;/p&gt;
&lt;p&gt;Is it a good idea to learn a new programming language and standard library just to explore a new workflow? Maybe not, but I&amp;#39;m not sure there&amp;#39;s a great alternative. I&amp;#39;m sure similar REPL-editor integrations exist in other languages, but I also suspect that they&amp;#39;re buggier because they&amp;#39;ve been bolted on, rather than supported from the beginning. Additionally, if I put in the work and am not satisfied with the workflow after all, I can rest assured that I gave it the best possible chance, using standard tools.&lt;/p&gt;
&lt;p&gt;Regardless, it should be an interesting adventure!&lt;/p&gt;
</content>
</entry>
</feed>
