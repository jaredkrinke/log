<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2022-02-13T01:55:20.363Z</updated>

<entry>
<title>Future-proof programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/future-proof-languages.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/future-proof-languages.html"/>
<updated>2022-02-11T00:00:00.000Z</updated>
<summary type="text">My projects are currently on hold while I suffer from programming language analysis paralysis.</summary>
<content type="html">&lt;p&gt;After some rapid progress on projects such as &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../releases/md2blog-1.1.1.html&quot;&gt;md2blog&lt;/a&gt;, everything has come to a screeching halt while I struggle with making future-proof technology choices. This post is specifically about programming languages.&lt;/p&gt;
&lt;h1 id=&quot;why-future-proof&quot;&gt;Why future-proof?&lt;/h1&gt;
&lt;p&gt;I want code that I write to continue being useful to me in the future. Specifically, I want to be able to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run my code&lt;/li&gt;
&lt;li&gt;Recompile my code (in case I end up on a new platform)&lt;/li&gt;
&lt;li&gt;Reuse my code in other projects&lt;/li&gt;
&lt;li&gt;Do all of the above with a minimum of hassle (and no multi-gigabyte downloads!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this is why I&amp;#39;m stuck on trying to find a comfortable, future-proof programming language.&lt;/p&gt;
&lt;h1 id=&quot;indicators&quot;&gt;Indicators&lt;/h1&gt;
&lt;p&gt;Here are some ideas on what indicates that a programming language will persist well into the future:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Availability of &lt;em&gt;open source&lt;/em&gt; compilers and tooling (ideally multiple implementations that are mutually compatible)&lt;/li&gt;
&lt;li&gt;Support for many platforms&lt;/li&gt;
&lt;li&gt;Broad usage (both in open source projects and industry)&lt;/li&gt;
&lt;li&gt;Actively maintained standard library&lt;/li&gt;
&lt;li&gt;No breaking changes (ideally)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, I&amp;#39;d also like the programming language to be convenient and comfortable, so I&amp;#39;ll add to my wishlist:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No multi-gigabyte downloads just to get started&lt;/li&gt;
&lt;li&gt;Not tied to a single platform/environment/tool set&lt;/li&gt;
&lt;li&gt;Small and simple (in case I want to build my own tools)&lt;/li&gt;
&lt;li&gt;Easily cross-compiled&lt;/li&gt;
&lt;li&gt;Simple and transparent build process&lt;/li&gt;
&lt;li&gt;Readily available libraries (either with source available or from reputable contributors)&lt;/li&gt;
&lt;li&gt;Ergonomic editing&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;observations&quot;&gt;Observations&lt;/h1&gt;
&lt;p&gt;According to &lt;a href=&quot;https://insights.stackoverflow.com/survey/2021#technology-most-popular-technologies&quot;&gt;Stack Overflow&lt;/a&gt;, the most popular programming languages are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Clojure&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;li&gt;Lisp&lt;/li&gt;
&lt;li&gt;Zig (not actually on the list)&lt;/li&gt;
&lt;li&gt;Lua (also not on the list)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now it&amp;#39;s time to ruthlessly eliminate popular programming languages.&lt;/p&gt;
&lt;p&gt;Some languages are mostly tied to a particular platform, so they get cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;Dart&lt;/li&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Objective C&lt;/li&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Elixir&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java and Perl I have experience with, and frankly, they&amp;#39;re too cumbersome, so I won&amp;#39;t investigate them further.&lt;/p&gt;
&lt;h1 id=&quot;second-round&quot;&gt;Second round&lt;/h1&gt;
&lt;p&gt;After some initial pruning, here is the list with my initial thoughts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript/TypeScript&lt;/strong&gt;: lots of implementations and modern JavaScript is nice, but comes with a ton of baggage; TypeScript brings some sanity to the language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;: setting up a Python environment is a recurring nightmare of mine, but it&amp;#39;s so popular that I probably need to give it another shot&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C#&lt;/strong&gt;: a great language and standard library, but how much of it is open source? Is it portable? Can I run .NET on a Raspberry Pi?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;: terribly complex, but modern C++ is surprisingly convenient; the build systems are generally awful, though&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: probably the most portable and future-proof language ever created, but not very ergonomic&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Go&lt;/strong&gt;: &amp;quot;goroutines&amp;quot; seem great and I&amp;#39;ve heard the tooling is nice, but a garbage-collected language with C-like verbosity sounds like the worst of both worlds to me&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: new and popular, with an appealing memory model, but there&amp;#39;s really only one implementation and &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/rust-first-experience.html&quot;&gt;my first experience setting Rust up on Windows was terrible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ruby&lt;/strong&gt;: just as annoying to setup as Python, but less popular&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Haskell&lt;/strong&gt;: it&amp;#39;s been a while since I used a purely functional programming language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lisp/Clojure&lt;/strong&gt;: I love the simplicity of Lisp (namely Scheme), but I have doubts about it being convenient and portable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zig&lt;/strong&gt;: probably too new and with too many breaking changes, but I like the idea of a more sane alternative to C, and the Zig compiler is very convenient&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lua&lt;/strong&gt;: I used to love Lua, but TypeScript just seems so much more popular and productive these days&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given that this list is already too long, I&amp;#39;m going to eliminate a few options without proper due diligence (either based on prior experience or based on the belief that similar but superior options exist elsewhere on this list). Apologies to the following languages that have been cut:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;li&gt;Haskell&lt;/li&gt;
&lt;li&gt;Lua&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;third-round&quot;&gt;Third round&lt;/h1&gt;
&lt;p&gt;For the next round, I&amp;#39;ll do more research and hopefully play around with the languages I&amp;#39;m unfamiliar with.&lt;/p&gt;
&lt;p&gt;Some initial thoughts on the languages I&amp;#39;m familiar with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript: comfortable and convenient, but memory usage and (lack of) parallelism are concerns&lt;/li&gt;
&lt;li&gt;C#: can this run on a Raspberry Pi? How much of the standard library is closed source?&lt;/li&gt;
&lt;li&gt;C++: is there C++ environment that is quick and easy to setup?&lt;/li&gt;
&lt;li&gt;C: a frontrunner, despite its numerous problems&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here are the languages I need to investigate further:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Lisp/Clojure&lt;/li&gt;
&lt;li&gt;Zig&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-all-for-now&quot;&gt;That&amp;#39;s all for now&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s as far as I&amp;#39;ve gotten. My next steps are to see if C# is viable, determine if there&amp;#39;s a convenient C++ environment, give Python yet another try, and then play around with Go, Rust, Clojure (or other Lisps), and Zig.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Frameworks for porting web apps to the desktop</title>
<id>https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/web-apps-on-the-desktop.html"/>
<updated>2022-01-13T00:00:00.000Z</updated>
<summary type="text">This is my initial research into converting a web app to a desktop app.</summary>
<content type="html">&lt;p&gt;I have a browser-based application that I&amp;#39;d like to transform into a &amp;quot;normal&amp;quot; desktop application.&lt;/p&gt;
&lt;h1 id=&quot;why&quot;&gt;Why?&lt;/h1&gt;
&lt;p&gt;My situation is fairly unique, but here&amp;#39;s my motivation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My app is already web-based (using HTML, CSS, TypeScript, with a corresponding HTTP API that&amp;#39;s deployed to &lt;a href=&quot;https://functions.netlify.com/&quot;&gt;Netlify Functions&lt;/a&gt;), and I don&amp;#39;t want to rewrite any of my code&lt;/li&gt;
&lt;li&gt;I&amp;#39;m planning to use a distribution service that&amp;#39;s based on plain old desktop executables (this is probably an unusual requirement)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some more typical reasons for porting from web to desktop might be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wanting to take advantage of libraries, devices, or system APIs that aren&amp;#39;t available in the browser&lt;/li&gt;
&lt;li&gt;Wanting to integrate with native code that (probably due to performance) won&amp;#39;t be ported to WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;why-not&quot;&gt;Why not?&lt;/h1&gt;
&lt;p&gt;Some downsides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Electron (the most popular desktop framework for web technologies) produces large binaries (100+ MB) that use a lot of memory (due to bundling an entire browser engine within each application, presumably to ensure consistency across devices)&lt;ul&gt;
&lt;li&gt;This also means that copyright notices for a huge number of open source libraries Chromium uses must be included&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These frameworks typically have their own unique build processes, which adds additional complexity as compared to building a desktop app &amp;quot;the normal way&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;My research turned up the following relevant frameworks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;Electron&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nwjs.io/&quot;&gt;NW.js&lt;/a&gt; (formerly node-webkit)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tauri-apps/tauri&quot;&gt;Tauri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs&quot;&gt;Neutralinojs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here is my uneducated, subjective comparison (all of these frameworks currently support Windows, Linux, and macOS, with Tauri planning to eventually support iOS and Android):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Framework&lt;/th&gt;
&lt;th&gt;Engine&lt;/th&gt;
&lt;th&gt;Maturity&lt;/th&gt;
&lt;th&gt;License&lt;/th&gt;
&lt;th&gt;Examples&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Electron&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;Stable&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;VS Code, Slack, Discord&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NW.js&lt;/td&gt;
&lt;td&gt;Chromium&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;Many (via Chromium)&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tauri&lt;/td&gt;
&lt;td&gt;Chromium (Windows)&lt;br/&gt;WebKit (Linux/macOS)&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;Apache&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Neutralinojs&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;In development&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/neutralinojs/neutralinojs/blob/main/LICENSE&quot;&gt;Many&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Note that I&amp;#39;m ignoring native code interop because it&amp;#39;s not relevant to me, but I believe NW.js uses Node and Tauri uses Rust.&lt;/p&gt;
&lt;h1 id=&quot;my-plan&quot;&gt;My plan&lt;/h1&gt;
&lt;p&gt;For my purposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I only &lt;em&gt;need&lt;/em&gt; to support Windows (at least initially)&lt;/li&gt;
&lt;li&gt;I may not need desktop integration or native code&lt;/li&gt;
&lt;li&gt;I&amp;#39;d like to produce a minimal binary package (i.e. I don&amp;#39;t want to bundle an entire browser runtime if I don&amp;#39;t have to)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on that last requirement, Tauri (or maybe Neutralinojs) seemed like the best match, but I had concerns about reliability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tauri is built on &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt;, which is installed separately from the operating system (so not all Windows computers will have it installed)&lt;/li&gt;
&lt;li&gt;Tauri&amp;#39;s bundler produces installers on Windows that apparently &lt;a href=&quot;https://github.com/tauri-apps/tauri/issues/2452&quot;&gt;don&amp;#39;t clearly communicate this requirement&lt;/a&gt;, possibly leading to broken installs&lt;/li&gt;
&lt;li&gt;This also means that installation inherits the WebView2 runtime&amp;#39;s need for elevated privileges (avoidable by distributing the runtime as well, but that&amp;#39;s basically Electron at that point)&lt;/li&gt;
&lt;li&gt;Obviously, if I want to later expand to Linux and/or macOS (where Tauri uses WebKit) I might run into incompatibilities (although I haven&amp;#39;t heard of any with the web version of my app)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taken as a whole (and given that WebView2 is relatively new), unless I have some way to ensure the WebView2 runtime will be present, I will likely end up using Electron, despite my reservations around download size and efficiency. At least in my case, there are some mitigating factors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This isn&amp;#39;t an app I expect users to have open all the time (so memory usage is less of a concern)&lt;/li&gt;
&lt;li&gt;There is a simple fallback for anyone who wants to avoid a large download: just use the web version!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This isn&amp;#39;t the answer I had hoped for, but I&amp;#39;m trying to be pragmatic. Hopefully in the future WebView2 will be installed by default and I can switch to something more lightweight like Tauri.&lt;/p&gt;
</content>
</entry>
<entry>
<title>My first experience with Rust</title>
<id>https://log.schemescape.com/posts/programming-languages/rust-first-experience.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/rust-first-experience.html"/>
<updated>2022-01-06T00:00:00.000Z</updated>
<summary type="text">Rust is popular and I&apos;m interested in its memory safety features and build system. Here&apos;s my first experience with Rust.</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; is so popular these days that &amp;quot;written in Rust&amp;quot; is undoubtedly going to become a meme (if it hasn&amp;#39;t already). It&amp;#39;s time I give it a try!&lt;/p&gt;
&lt;h1 id=&quot;the-appeal-of-rust&quot;&gt;The appeal of Rust&lt;/h1&gt;
&lt;p&gt;I can understand the appeal of Rust. It&amp;#39;s a modern language (meaning it doesn&amp;#39;t have a ton of legacy cruft), it has a unique memory model that prevents certain classes of bugs, yet it still has manual memory management. This is a unique combination.&lt;/p&gt;
&lt;p&gt;Theoretically, this should allow Rust to be used all the way from memory-constrained embedded systems to high level apps.&lt;/p&gt;
&lt;h1 id=&quot;what-about-c&quot;&gt;What about C++?&lt;/h1&gt;
&lt;p&gt;Now, I&amp;#39;m not willing to jump to a new language and ecosystem just because it&amp;#39;s shiny and new. Rust&amp;#39;s memory model seems like an improvement over C++, but modern C++ has (in my experience) fewer memory bugs anyway, thanks to smart pointers and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;RAII&lt;/a&gt; pattern.&lt;/p&gt;
&lt;p&gt;But here are some other enticing features of Rust:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust has its own package manager, &lt;a href=&quot;https://doc.rust-lang.org/stable/cargo/&quot;&gt;Cargo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust has its own build system, which is also Cargo&lt;/li&gt;
&lt;li&gt;Rust&amp;#39;s compiler is built on LLVM, so it can trivially target WebAssembly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If I had to pick the worst part of C++ development, I&amp;#39;d say it&amp;#39;s setting up a build system and dealing with dependencies. To me, Cargo is actually the biggest differentiator for Rust as compared to C++.&lt;/p&gt;
&lt;h1 id=&quot;installing-rust&quot;&gt;Installing Rust&lt;/h1&gt;
&lt;p&gt;It might be unreasonable, but I&amp;#39;d like my programming language of choice to have a development environment that is compact and simple to setup. Aside: this is one of the reasons I enjoy &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../web-development/one-month-with-deno.html&quot;&gt;Deno&lt;/a&gt;: it ships as a single (fairly small) binary.&lt;/p&gt;
&lt;p&gt;Following Rust&amp;#39;s &lt;a href=&quot;https://www.rust-lang.org/learn/get-started&quot;&gt;getting started instructions&lt;/a&gt;, I&amp;#39;m immediately discouraged:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It looks like you’re running Windows. To start using Rust, download the installer, then run the program and follow the onscreen instructions. You may need to install the Visual Studio C++ Build tools when prompted to do so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I have to install a full C++ development environment just to use Rust? Ok, well I click the link and download ~35 MB. Not too bad until it becomes apparent that the download is &lt;em&gt;just the installer itself&lt;/em&gt;. I&amp;#39;m then presented with a huge list of options for things to install.&lt;/p&gt;
&lt;p&gt;The Rust installer indicates that I should install the Windows 10 SDK, so I select that and am horrified to see that it is 2.8 GB.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;Based on the documentation I&amp;#39;ve seen so far, it looks like you have to install nearly 3 GB of C++ tools just to get a working Rust development environment on Windows.&lt;/p&gt;
&lt;p&gt;At this point, I&amp;#39;m speechless. I was willing to tolerate a ~500 MB download for a new programming language, but I&amp;#39;m already up to about six times that size without even getting to the Rust part.&lt;/p&gt;
&lt;p&gt;A quick web search indicates that this requirement is just to provide things like a linker, but I&amp;#39;m certain these tools are much less than 3 GB in size.&lt;/p&gt;
&lt;p&gt;I was also under the impression that Rust was fully open source, so requiring closed source tools to build on Windows seems bizarre (note: MinGW might fill in this gap, but that&amp;#39;s another huge download I&amp;#39;d like to avoid, if possible).&lt;/p&gt;
&lt;h1 id=&quot;setting-this-aside-for-now&quot;&gt;Setting this aside for now...&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s enough disappointment for one day. I&amp;#39;d still like to give Rust a go, but it looks like first I&amp;#39;m going to have to figure out how to get a working environment without installing gigabytes of unrelated tooling (especially since part of my motivation to try Rust was to avoid having to setup an entire C++ toolchain!).&lt;/p&gt;
</content>
</entry>
<entry>
<title>md2blog 1.1.1 released</title>
<id>https://log.schemescape.com/posts/releases/md2blog-1.1.1.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/releases/md2blog-1.1.1.html"/>
<updated>2021-12-27T00:00:00.000Z</updated>
<summary type="text">md2blog (the zero-config static site generator powering this site) has officially been released.</summary>
<content type="html">&lt;p&gt;&lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog&lt;/a&gt; is a zero-config static site generator for dev blogs (like this one), that was created out of frustration with existing (bloated) static site generators.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/&quot;&gt;md2blog web site&lt;/a&gt; lists the key features, but here&amp;#39;s an overview:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;md2blog enables you to create a dev blog from Markdown files without getting bogged down in extraneous details (like runtime environments, plugins, and themes)&lt;/li&gt;
&lt;li&gt;md2blog respects your readers by producing a simple (and small) web site that is still fully functional&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you&amp;#39;ve been disappointed with the complexity of setting up a simple dev blog using other static site generators, I encourage you to download md2blog&amp;#39;s &lt;em&gt;single self-contained binary&lt;/em&gt; and run through the &lt;a href=&quot;https://jaredkrinke.github.io/md2blog/quick-start.html&quot;&gt;quick start&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>
<entry>
<title>One month with Deno (part 2)</title>
<id>https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/web-development/one-month-with-deno-2.html"/>
<updated>2021-12-13T00:00:00.000Z</updated>
<summary type="text">I made the switch from Node to Deno recently. Here are the problems with Deno I&apos;ve encountered.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/web-development/one-month-with-deno.html&quot;&gt;part 1&lt;/a&gt;, I gushed over Deno&amp;#39;s benefits, including sand-boxing, native TypeScript support, a simple module registry, and more. Here&amp;#39;s part 2 (which paints a less rosy picture).&lt;/p&gt;
&lt;h1 id=&quot;problems-with-deno&quot;&gt;Problems with Deno&lt;/h1&gt;
&lt;p&gt;Using Deno has come with some significant challenges. Here are the top issues I&amp;#39;ve faced using Deno for the last month. The good news is that people are working on addressing most of these.&lt;/p&gt;
&lt;h2 id=&quot;existing-typescript-modules-dont-work&quot;&gt;Existing TypeScript modules don&amp;#39;t work&lt;/h2&gt;
&lt;p&gt;Wait, I thought Deno had native TypeScript support. What do you mean TypeScript modules don&amp;#39;t work?&lt;/p&gt;
&lt;p&gt;What I mean is that most TypeScript code that wasn&amp;#39;t written specifically for Deno will (generally) not run unmodified in Deno. This is an unfortunate situation because it means that leveraging existing libraries written in TypeScript is nontrivial. The problem arises from two incompatible stances:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deno imports modules by full name (or URL), with &lt;a href=&quot;https://deno.land/manual@v1.16.4/typescript/faqs&quot;&gt;no magical resolution&lt;/a&gt;, so file extensions (or special HTTP headers) are required&lt;/li&gt;
&lt;li&gt;TypeScript &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/27481&quot;&gt;doesn&amp;#39;t change import specifiers&lt;/a&gt;, so it insists (or rather it used to insist) that file extensions be omitted (so the runtime can find and load the resulting &lt;code&gt;.js&lt;/code&gt; files)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regardless of which stance is more righteous, the fact is that existing TypeScript code doesn&amp;#39;t work in Deno unless you do work (e.g. adding &lt;code&gt;.ts&lt;/code&gt; to imports or creating an &lt;a href=&quot;https://deno.land/manual@v1.16.4/linking_to_external_code/import_maps&quot;&gt;import map&lt;/a&gt;). There isn&amp;#39;t even any agreement on the best way to work around this annoyance. The trend to Deno-ify TypeScript modules from NPM and publish them on deno.land/x is not encouraging.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s a bit sad because, other than this issue, Deno provides the best tooling for TypeScript I&amp;#39;ve encountered.&lt;/p&gt;
&lt;h2 id=&quot;node-packages-generally-require-third-party-code&quot;&gt;Node packages generally require third party code&lt;/h2&gt;
&lt;p&gt;Ok, so non-Deno TypeScript libraries are out, what about non-Node-specific JavaScript packages on NPM?&lt;/p&gt;
&lt;p&gt;First of all, Deno only supports ES modules (instead of CommonJS), so only packages that are shipped as modules could possibly work unmodified.&lt;/p&gt;
&lt;p&gt;Additionally, if you&amp;#39;re planning to publish a Deno module you don&amp;#39;t have the luxury of using Deno&amp;#39;s &lt;a href=&quot;https://deno.land/manual@v1.16.4/npm_nodejs/compatibility_mode&quot;&gt;Node compatibility mode&lt;/a&gt; or using import maps to support dependencies, so you&amp;#39;re stuck trying to bridge the gap between Deno&amp;#39;s &amp;quot;no magic&amp;quot; module resolution algorithm and Node&amp;#39;s &amp;quot;nothing &lt;em&gt;but&lt;/em&gt; magic&amp;quot; approach.&lt;/p&gt;
&lt;p&gt;Once again, I didn&amp;#39;t see a great option for handling this, especially if you want to leverage &lt;a href=&quot;https://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; declarations. The Deno documentation recommends using third party content delivery services, but I currently have no way to vet these CDNs.&lt;/p&gt;
&lt;p&gt;I won&amp;#39;t describe the approach I ended up using to work around this problem because it is, frankly, a terrible (and manual) hack.&lt;/p&gt;
&lt;h2 id=&quot;standard-library-licenses-arent-uniform&quot;&gt;Standard library licenses aren&amp;#39;t uniform&lt;/h2&gt;
&lt;p&gt;Deno has a standard library! Hooray! Now we can all use the code in whatever project we want as long as we include Deno&amp;#39;s copyright notice...&lt;/p&gt;
&lt;p&gt;...except that the library wasn&amp;#39;t entirely written by the Deno authors, so many of the modules have different copyright notices (e.g. &lt;a href=&quot;https://deno.land/std@0.117.0/encoding/yaml.ts&quot;&gt;std/encoding/yaml.ts&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;This means that you have to track down all of your dependencies and diligently duplicate their copyright notices in tools created with &lt;code&gt;deno compile&lt;/code&gt;. At least Deno restricts contributions to the permissive MIT, BSD, and Apache licenses!&lt;/p&gt;
&lt;h2 id=&quot;webassembly-isnt-seamless&quot;&gt;WebAssembly isn&amp;#39;t seamless&lt;/h2&gt;
&lt;p&gt;Deno currently loads WebAssembly using &lt;code&gt;fetch&lt;/code&gt; (just like in the browser). This sounds like a great idea except for the fact that it requires network and/or file system access. Unfortunately, this means that if you want to use WebAssembly in a library, you have two unappealing options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tell consumers that they need to pass &lt;code&gt;--allow-read&lt;/code&gt; or &lt;code&gt;--allow-net&lt;/code&gt; in when using your library (negating some of the security benefits of Deno)&lt;/li&gt;
&lt;li&gt;Or Base64-encode your module into an obnoxiously huge TypeScript file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Deno used to support statically importing WebAssembly (without requiring additional privileges), but that support was removed on the assumption that a forthcoming web standard will eventually solve this problem. Last I read, this is still an open problem.&lt;/p&gt;
&lt;h2 id=&quot;bundling-only-emits-javascript&quot;&gt;Bundling only emits JavaScript&lt;/h2&gt;
&lt;p&gt;Deno &lt;a href=&quot;https://deno.land/manual@v1.16.4/tools/bundler&quot;&gt;comes with a simple bundler&lt;/a&gt;! Unfortunately, it only emits JavaScript, so you can&amp;#39;t use it for packaging a TypeScript module into a single file (because you&amp;#39;d lose all your type information).&lt;/p&gt;
&lt;p&gt;I have yet to find a bundler for TypeScript. I really hope I won&amp;#39;t have to write one myself!&lt;/p&gt;
&lt;h2 id=&quot;theres-no-standard-way-to-specify-long-command-lines&quot;&gt;There&amp;#39;s no standard way to specify long command lines&lt;/h2&gt;
&lt;p&gt;I applaud Deno for forcing users to provide permissions on the command line, but those command lines can get pretty long. Additionally, Deno seems to be allergic to configuration files, so instead of putting commands into a configuration file, we just have no standard, cross-platform way to specify how to run code.&lt;/p&gt;
&lt;h2 id=&quot;the-formatter-produces-ugly-code&quot;&gt;The formatter produces ugly code&lt;/h2&gt;
&lt;p&gt;I like the idea of Deno having a built-in formatter, but I don&amp;#39;t actually like the output. For example, the default is to use 2 spaces for indentation. I don&amp;#39;t know anyone (outside of Deno) who prefers 2 spaces over 4 spaces. I find it makes code harder to read. Additionally, the formatter inserts spaces and newlines in surprising places (again, making the code harder to read).&lt;/p&gt;
&lt;p&gt;I appreciate that automatic code formatting is a difficult problem and that style is usually personal preference, but this is the first formatter I&amp;#39;ve seen that I don&amp;#39;t like.&lt;/p&gt;
&lt;h2 id=&quot;bugs-bugs-bugs&quot;&gt;Bugs, bugs, bugs&lt;/h2&gt;
&lt;p&gt;Deno is a remarkable project and I really enjoy it, but I have encountered several critical bugs, just in my first month of use. My favorite two examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Correct&lt;/em&gt; code &lt;em&gt;failing&lt;/em&gt; type checking (due to a caching issue)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Incorrect&lt;/em&gt; code &lt;em&gt;successfully&lt;/em&gt; type checking (due to type checking being unexpectedly skipped)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;so-will-i-keep-using-deno&quot;&gt;So will I keep using Deno?&lt;/h1&gt;
&lt;p&gt;More than once, I&amp;#39;ve wondered if working around the limitations of Deno is costing me more time than I&amp;#39;m saving by using Deno. It very well might.&lt;/p&gt;
&lt;p&gt;In the end, however, I plan to continue using Deno because it provides the best TypeScript runtime I&amp;#39;ve seen, and its features (and most of its goals) align with my needs and preferences.&lt;/p&gt;
</content>
</entry>
</feed>
