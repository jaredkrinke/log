<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Metalsmith's downsides]]></title><description><![CDATA[<p>After <a href="../comparison/">testing out a bunch of static site generators</a>, I settled on using <a href="../metalsmith/">Metalsmith</a> for this site. I like that Metalsmith has a simple design that can be easily extended with plugins (either custom or &quot;off the shelf&quot;), but that&#39;s not to say that Metalsmith is perfect.</p>
<p>Let&#39;s dive into the downsides of Metalsmith.</p>
<h1 id="is-metalsmith-being-maintained">Is Metalsmith being maintained?</h1>
<p>There&#39;s the question of ownership and maintenance. Metalsmith was created by <a href="https://segment.com/">Segment</a>, and the <a href="https://github.com/segmentio/metalsmith">main repository</a> lives under their GitHub account. Maintenance duties were <a href="https://github.com/segmentio/metalsmith/pull/324/files">transferred in 2018</a>, but there have been no nontrivial commits since then.</p>
<p><strong>A pessimistic view is that Metalsmith is a zombie project.</strong></p>
<p>It&#39;s possible that Metalsmith is simple enough that it doesn&#39;t <em>need</em> any updates, but if you do run into a problem with Metalsmith itself, you&#39;re probably going to have to fix it yourself.</p>
<p>This, to me, is probably the biggest downside of building on top of Metalsmith.</p>
<h1 id="are-the-plugins-being-maintained">Are the plugins being maintained?</h1>
<p>If you take the optimistic view that Metalsmith&#39;s core is rock-solid and not in need of updates, how about the plugins? In many cases, <strong>plugins also appear to be unmaintained</strong>.</p>
<p>For example, take the <a href="https://github.com/segmentio/metalsmith-collections">metalsmith-collections</a> plugin. Its last commit was 3 years ago, but even worse, the <a href="https://github.com/segmentio/metalsmith-collections">associated NPM package</a> was published 5 years ago. In fact, the published package <a href="https://github.com/segmentio/metalsmith-collections/issues/91">doesn&#39;t even contain the most up-to-date version of the plugin</a>. I ran into this particular issue because I wanted to use the plugin&#39;s <code>filterBy</code> option, but that functionality isn&#39;t actually present in the NPM package&#39;s version.</p>
<p>This is unfortunate, but there&#39;s nothing stopping you from forking and updating plugins yourself.</p>
<h1 id="official-forum-sign-up-requirements">Official forum sign-up requirements</h1>
<p><a href="https://metalsmith.io/">Metalsmith&#39;s home page</a> points to a <a href="https://gitter.im/">Gitter</a> community, which I interpret to be the official forum.</p>
<p>While I like the <em>idea</em> of an open source Discord alternative, I was very disappointed with my first experience using (well, attemping to use) Gitter.</p>
<p>Gitter was originally created as a way to chat about GitHub projects, so it was naturally tied to GitHub accounts. This was fine then, but even today Gitter requires one of the following accounts for login:</p>
<ul>
<li>GitHub</li>
<li>GitLab</li>
<li>Twitter</li>
</ul>
<p>I use GitHub and have a high opinion of both it and GitLab (Twitter, not so much). But Gitter&#39;s <em>default, required</em> access requests are repulsive:</p>
<ul>
<li>GitHub: &quot;This application will be able to read your ... private project boards.&quot;</li>
<li>GitLab: &quot;Grants complete read/write access ... including all groups and projects ...&quot;</li>
<li>Twitter: Requires a phone number to sign up (that I assume Twitter turns around and sells to advertisers)</li>
</ul>
<p>If I already used Twitter, that would be an acceptable option here, but I have no interest in donating my personal data to yet another gigantic advertising company. Without a Twitter account, none of the login options seem even remotely reasonable.</p>
<p>In the end, I created a dummy GitHub account just to access Gitter (which essentially negates any user benefit of using OAuth).</p>
<h1 id="plugin-ordering-and-lack-of-history">Plugin ordering and lack of history</h1>
<p>My favorite aspect of Metalsmith is its minimal design that can be easily extended with simple plugins, but I think the design is perhaps <em>too</em> minimal.</p>
<p>Internally, Metalsmith manages a mapping of files to properties, and this mapping is handed from one plugin to the next, sequentially (and asynchronously). Each plugin <em>mutates</em> the mapping however it wants, and eventually Metalsmith&#39;s <code>build()</code> function writes out the resulting files.</p>
<p>This is indeed a very simple design, but there is a subtle problem lurking: since each plugin can do whatever it wants, information can be changed or lost along the chain. This leads to numerous problems. Here are some examples:</p>
<ul>
<li><a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a> renames files from &quot;page.md&quot; to &quot;page.html&quot;<ul>
<li>Subsequent plugins can no longer distinguish which HTML files were generated from Markdown and which were just static HTML files</li>
<li>This makes supporting relative links (e.g. <code>./other-page.md</code>) fragile (e.g. <code>./static-page.html</code>, referring to a static HTML page--not generated using Markdown--is ambiguous)</li>
</ul>
</li>
<li><a href="https://github.com/segmentio/metalsmith-permalinks">metalsmith-permalinks</a> moves files into different directories<ul>
<li>This plugin has to come before <a href="https://github.com/radiovisual/metalsmith-rootpath">metalsmith-rootpath</a> to correctly construct a &quot;relative path to root&quot; property</li>
<li>Replacing paths also makes it essentially impossible to unambiguously link a source file to its destination, without adding additional plugins to the chain</li>
</ul>
</li>
</ul>
<p>The current behavior is simple to reason over, and can be solved without changing the architecture (using more plugins!), but it is initially surprising, and certainly makes the tool harder to use.</p>
<h1 id="configuring-markdown">Configuring Markdown</h1>
<p>One less prominent challenge with Metalsmith&#39;s architecture is that there is no mechanism (or convention) for communicating between plugins. Probably an uncommon scenario, but it would be nice to allow plugins to configure Metalsmith&#39;s Markdown options (without having to use an entirely separate Markdown plugin).</p>
<h1 id="so-do-i-hate-metalsmith-no">So do I hate Metalsmith? No!</h1>
<p>Honestly, this article makes a compelling case for avoiding Metalsmith--yet, I still use it. Why?</p>
<p>As someone who&#39;s familiar with JavaScript, Node, and HTML/CSS, Metalsmith is simply the easiest static site generator for me to use:</p>
<ul>
<li>It&#39;s simple enough that I know exactly what it&#39;s doing</li>
<li>It&#39;s easy to customize and extend</li>
<li>Simple plugins already exist for most of the things I want to do</li>
<li>It supports <a href="https://github.com/jstransformers">pretty much any template language</a></li>
<li>I can even debug it, just by hitting F5 in VS Code</li>
</ul>
<p>Metalsmith is really giving me the best of both using a pre-built static site generator and creating my own. It&#39;s possible that the lack of maintenance will force me to switch to something else eventually, but for now I&#39;m happy with it.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith-downsides</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith-downsides</guid><pubDate>Thu, 14 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating SVG diagrams automatically with Metalsmith]]></title><description><![CDATA[<p>Now that I&#39;ve <a href="../../webassembly/compiling-graphviz-to-webassembly/">compiled Graphviz to a WebAssembly module</a>, I&#39;m going to use it to automatically generate SVG diagrams when I build my static site using Metalsmith.</p>
<h1 id="the-plan">The plan</h1>
<p>Here&#39;s a flow chart of my general plan:</p>
<svg width="312pt" height="260pt"
 viewBox="0.00 0.00 311.67 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
<polygon class="diagram-transparent-white" points="-4,4 -4,-256 307.67,-256 307.67,4 -4,4"/>
<g id="node1" class="node">
<title>Compile Graphviz to WebAssembly</title>
<ellipse class="diagram-black-none" cx="151.84" cy="-234" rx="151.67" ry="18"/>
<text text-anchor="middle" x="151.84" y="-229.8" font-family="Times,serif" font-size="14.00">Compile Graphviz to WebAssembly</text>
</g>
<g id="node2" class="node">
<title>Generate diagrams at build time</title>
<ellipse class="diagram-black-none" cx="151.84" cy="-162" rx="134.85" ry="18"/>
<text text-anchor="middle" x="151.84" y="-157.8" font-family="Times,serif" font-size="14.00">Generate diagrams at build time</text>
</g>
<g id="edge1" class="edge">
<title>Compile Graphviz to WebAssembly&#45;&gt;Generate diagrams at build time</title>
<path class="diagram-black-none" d="M151.84,-215.7C151.84,-207.98 151.84,-198.71 151.84,-190.11"/>
<polygon class="diagram-black-black" points="155.34,-190.1 151.84,-180.1 148.34,-190.1 155.34,-190.1"/>
</g>
<g id="node3" class="node">
<title>???</title>
<ellipse class="diagram-black-none" cx="151.84" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="151.84" y="-85.8" font-family="Times,serif" font-size="14.00">???</text>
</g>
<g id="edge2" class="edge">
<title>Generate diagrams at build time&#45;&gt;???</title>
<path class="diagram-black-none" d="M151.84,-143.7C151.84,-135.98 151.84,-126.71 151.84,-118.11"/>
<polygon class="diagram-black-black" points="155.34,-118.1 151.84,-108.1 148.34,-118.1 155.34,-118.1"/>
</g>
<g id="node4" class="node">
<title>Profit!</title>
<ellipse class="diagram-black-none" cx="151.84" cy="-18" rx="36.49" ry="18"/>
<text text-anchor="middle" x="151.84" y="-13.8" font-family="Times,serif" font-size="14.00">Profit!</text>
</g>
<g id="edge3" class="edge">
<title>???&#45;&gt;Profit!</title>
<path class="diagram-black-none" d="M151.84,-71.7C151.84,-63.98 151.84,-54.71 151.84,-46.11"/>
<polygon class="diagram-black-black" points="155.34,-46.1 151.84,-36.1 148.34,-46.1 155.34,-46.1"/>
</g>
</g>
</svg>
<p>That diagram was generated using the following Markdown:</p>
<pre><code class="language-md"><span class="hljs-code">```dot2svg
digraph {
    &quot;Compile Graphviz to WebAssembly&quot; -&gt; &quot;Generate diagrams at build time&quot; -&gt; &quot;???&quot; -&gt; &quot;Profit!&quot;;
}
```</span></code></pre>
<h1 id="extending-the-marked-renderer">Extending the Marked renderer</h1>
<p>As shown in the example near the top of this post, my plan is to piggyback on Markdown code blocks, using a special language tag <code>dot2svg</code>. For all other code blocks (and on error), I simply defer to the default code block rendering function:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Generate diagrams with dot2svg</span>
<span class="hljs-keyword">const</span> baseCodeRenderer = markdownRenderer.<span class="hljs-property">code</span>;
<span class="hljs-keyword">const</span> dotConverter = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createDOTToSVGAsync</span>();
markdownRenderer.<span class="hljs-property">code</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">code, language, escaped</span>) {
    <span class="hljs-keyword">if</span> (language === <span class="hljs-string">&quot;dot2svg&quot;</span>) {
        <span class="hljs-keyword">const</span> svg = dotConverter.<span class="hljs-title function_">dotToSVG</span>(code);
        <span class="hljs-keyword">if</span> (svg) {
            <span class="hljs-keyword">return</span> svg;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// On error, just treat the code block like normal</span>
            language = <span class="hljs-string">&quot;&quot;</span>;
        }
    }
    <span class="hljs-keyword">return</span> baseCodeRenderer.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, code, language, escaped);
};</code></pre>
<h1 id="styling">Styling</h1>
<p>The above rendering code worked (and didn&#39;t break my <a href="../metalsmith-syntax-highlighting/">syntax highlighting</a>), but there were a few tweaks I had in mind:</p>
<ul>
<li>Remove the <a href="https://www.w3.org/TR/xml/#sec-prolog-dtd">XML prolog and document type declaration</a><ul>
<li>Since I&#39;m inlining my SVG in HTML, this information is redundant</li>
</ul>
</li>
<li>Replace Graphviz&#39;s default styling (annoyingly hard-coded via <code>fill</code> and <code>stroke</code> attributes on each element) with CSS classes<ul>
<li>This allows me to style the graphs using my CSS stylesheet</li>
<li>In my case, I&#39;m replacing the <code>fill=&quot;white&quot; stroke=&quot;black&quot;</code> attributes with a single CSS class: <code>class=&quot;diagram-black-white&quot;</code></li>
</ul>
</li>
</ul>
<p>Fortunately, both of these transformations can be done with regular expression replacements:</p>
<pre><code class="language-javascript">...
<span class="hljs-keyword">if</span> (svg) {
    <span class="hljs-comment">// Remove XML prolog, since we&#x27;re inlining</span>
    <span class="hljs-comment">// Also convert default styles to CSS classes, for custom styling</span>
    <span class="hljs-keyword">return</span> svg
        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^.*?&lt;svg /</span>s, <span class="hljs-string">&quot;&lt;svg &quot;</span>)
        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/fill=&quot;([^&quot;]+)&quot; stroke=&quot;([^&quot;]+)&quot;/g</span>, <span class="hljs-string">&quot;class=\&quot;diagram-$2-$1\&quot;&quot;</span>);
} <span class="hljs-keyword">else</span> {
...</code></pre>
<p>Now, I can just style everything with CSS:</p>
<pre><code class="language-css"><span class="hljs-comment">/* Diagrams */</span>
svg text { fill: <span class="hljs-number">#eee</span>; }
<span class="hljs-selector-class">.diagram-transparent-white</span> { stroke: none; fill: none; }
ellipse<span class="hljs-selector-class">.diagram-black-none</span> { stroke: <span class="hljs-number">#ccc</span>; fill: <span class="hljs-number">#444</span>; }
<span class="hljs-selector-class">.diagram-black-none</span> { stroke: <span class="hljs-number">#999</span>; fill:none; }
<span class="hljs-selector-class">.diagram-black-black</span> { stroke: <span class="hljs-number">#999</span>; fill: <span class="hljs-number">#333</span>; }</code></pre>
<h1 id="thats-it">That&#39;s it!</h1>
<p>To my surprise, this entire integration went smoothly, and only took an hour or so. It remains to be seen how useful these diagrams will be, but at least now if I ever feel the need to insert a superfluous diagram, the functionality will be there.</p>
<p>For reference, all of the code used to generate this site (along with the content) is in <a href="https://github.com/jaredkrinke/log">this repository</a>.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith-diagrams</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith-diagrams</guid><pubDate>Sun, 10 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Compiling Graphviz to WebAssembly (without Emscripten)]]></title><description><![CDATA[<p>After successfully <a href="../passing-strings-to-c/">passed strings back and forth between WebAssembly and JavaScript</a>, and <a href="../c-standard-library-example/">linked against a C standard library</a> (all without Emscripten... or Python), I felt ready to try compiling a substantial library to WebAssembly for use in Node.</p>
<h1 id="graphviz">Graphviz</h1>
<p>Specifically, I wanted to be able to automatically generate diagrams (in <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a> format) from text descriptions when building my static site using <a href="../../static-site-generators/metalsmith/">Metalsmith/Node</a>. <a href="https://graphviz.org/">Graphviz</a> is an old package of tools and libraries (written in C) that I&#39;ve successfully used in the past.</p>
<p>Graphviz diagrams are described in a language called <a href="https://graphviz.org/doc/info/lang.html">DOT</a>. Example:</p>
<pre><code class="language-dot">digraph {
    a -&gt; b;
}</code></pre>
<p>Graphviz supports multiple layout engines, but I&#39;ve only ever needed to use the default <a href="https://graphviz.org/docs/layouts/dot/">dot</a> engine (yes, it&#39;s the same name, just in lower case).</p>
<h2 id="prior-ports">Prior ports</h2>
<p>The Graphviz site <a href="https://graphviz.org/resources/">lists a number of previous ports of Graphviz</a>, including a couple that are relevant for Node:</p>
<ul>
<li><a href="https://github.com/mdaines/viz.js/">viz.js</a> (compiled to <a href="http://asmjs.org/">asm.js</a> using Emscripten; <a href="http://viz-js.com/">live editor here</a>)</li>
<li><a href="https://www.npmjs.com/package/@hpcc-js/wasm">@hpcc-js/wasm</a> (compiled to WebAssembly using Emscripten)</li>
</ul>
<p>Honestly, either one of these would have probably worked for my original purpose, but I chose to compile Graphviz myself for a few reasons:</p>
<ul>
<li>I wanted to experiment with compiling an existing C library to WebAssembly</li>
<li>I hoped that if I ripped out functionality I didn&#39;t need (e.g. export to <em>any format except SVG</em>), I might end up with a smaller WebAssembly module</li>
<li>I thought that a simple DOT-to-SVG function would avoid taking dependencies on &quot;virtual&quot; file I/O, etc. (which I assumed is how Emscripten worked)</li>
</ul>
<h1 id="dot2svgwasm">dot2svg.wasm</h1>
<p>Given that I&#39;m only interested in DOT diagram description to SVG, I decided to export a single function named <code>dot2svg</code> (along with exporting <code>malloc</code>/<code>free</code>/memory). There were a few reasons for this:</p>
<ul>
<li>The module should be smaller since it only contains the minimum essential code</li>
<li>I may be able to avoid dealing with build errors in code that I don&#39;t need</li>
<li>Theoretically, I can avoid dealing with file input/output, since everything is just strings in memory (spoiler: this didn&#39;t quite work out)</li>
</ul>
<p>The module&#39;s C code is pretty simple. Other than memory management functions, there&#39;s only one export and it takes a C string (in DOT format), renders to SVG, and returns a newly allocated string with the SVG content (the JavaScript host is responsible for freeing the string after it&#39;s been decoded).</p>
<p>Here&#39;s the C code for my module:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;gvc.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-comment">// WebAssembly exports</span>
<span class="hljs-comment">// Memory management helpers</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(allocate)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(deallocate)</span><span class="hljs-params">(<span class="hljs-type">void</span>* allocation)</span> {
    <span class="hljs-built_in">free</span>(allocation);
}

<span class="hljs-comment">// Main export</span>
<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(dot2svg)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* graphString)</span> {
    <span class="hljs-comment">// Use Graphviz for converting dot to SVG</span>
    <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* result = <span class="hljs-literal">NULL</span>;
    GVC_t* context = gvContextPlugins(lt_preloaded_symbols, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">if</span> (context) {
        Agraph_t* graph = agmemread(graphString);
        <span class="hljs-keyword">if</span> (graph) {
            <span class="hljs-keyword">if</span> (gvLayout(context, graph, <span class="hljs-string">&quot;dot&quot;</span>) == <span class="hljs-number">0</span>) {
                <span class="hljs-type">char</span> *svg;
                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> svgLength;
                gvRenderData(context, graph, <span class="hljs-string">&quot;svg&quot;</span>, &amp;svg, &amp;svgLength);
                <span class="hljs-keyword">if</span> (svg) {
                    result = strdup(svg);
                    gvFreeRenderData(svg);
                }
                gvFreeLayout(context, graph);
            }
            agfree(graph, <span class="hljs-literal">NULL</span>);
        }
        gvFreeContext(context);
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h2 id="initial-attempt-at-compiling">Initial attempt at compiling</h2>
<p>First, I cloned the Graphviz repository (actually, I added it as a submodule--anticipating the need to make changes) and ran it&#39;s &quot;autogen.sh&quot; script. For the record, I&#39;m using Debian <a href="https://www.debian.org/releases/stretch/">Stretch</a> on the <a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>.</p>
<p>Being familiar with <a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html">GNU Autotools</a>, I hoped that I&#39;d then be able to simply run Graphviz&#39;s &quot;configure&quot; script with appropriate arguments (&quot;--host=wasm32&quot;?) and environment variables (&quot;CC=/opt/wasi-sdk/bin/clang&quot;?) and everything would build fine.</p>
<p>I hit a few snags:</p>
<ul>
<li>Some of the Graphviz source code is actually C++, so I needed to set the &quot;CXX=/opt/wasi-sdk/bin/clang++&quot; variable as well</li>
<li>Graphviz defaults to building a shared library, but I needed a static one (solution: add &quot;--disable-shared&quot; to the &quot;configure&quot; command)</li>
<li>Graphviz defaults to loading plugins dynamically by enumerating directories (solution: add &quot;--disable-ltdl&quot; when running &quot;configure&quot;)</li>
<li>&quot;wasm-ld: error: ... archive has no index; run ranlib to add one&quot;</li>
</ul>
<p>That last one required some investigation.</p>
<h2 id="archive-index-error">Archive index error</h2>
<p>After searching for and finding a <a href="https://github.com/emscripten-core/emscripten/issues/9329">similar issue on GitHub</a>, I learned that that <code>wasm-ld</code> error means that you created the archive with the wrong tool set. In my case, it was using GNU <code>ar</code> instead of LLVM <code>ar</code>. That makes sense because I didn&#39;t tell the build to use a different <code>ar</code>, and GNU <code>ar</code> was on my path.</p>
<p>I thought that setting the &quot;AR&quot; environment variable would solve this, but it turned out that the Autotools in use didn&#39;t respect that environment variable. My hacky solution to this (and possibly other mismatched tools) was to just move the WASI SDK to the front of my &quot;PATH&quot; variable in my build script:</p>
<pre><code class="language-sh"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/opt/wasi-sdk/bin:<span class="hljs-variable">$PATH</span>&quot;</span></code></pre>
<h2 id="more-issues">More issues</h2>
<p>Now I started to run into more WASI-related issues. WASI is still in development and may not ever support the entire C library. That&#39;s fine, and I knew that going in, but I thought that Graphviz wouldn&#39;t be relying on some of the more obscure parts of the C library (and hopefully very few OS-specific features). Sadly, this is not the case.</p>
<p>Here are the problems I ran into:</p>
<ul>
<li>&quot;setjmp.h&quot;: apparently some Graphviz code uses one of my least favorite headers in the entire C standard library: &quot;setjmp.h&quot;<ul>
<li>This header provides non-local jumps that are sometimes used as an ugly substitute for exceptions</li>
<li>Unsurprisingly, WASI doesn&#39;t support this (I don&#39;t even think it <em>should</em>)</li>
<li>My solution was to just hope that <code>longjmp</code> never gets called and link in my own no-op versions of <code>setjmp</code> and <code>longjmp</code></li>
</ul>
</li>
<li>&quot;sys/wait.h&quot;: this is a POSIX header that Graphviz doesn&#39;t need (e.g. on Windows)<ul>
<li>My work-around was to create a dummy header that tricked Graphviz into thinking the one file including this header was on Windows</li>
<li>The contents of my dummy header: <code>#define _WIN32</code></li>
</ul>
</li>
<li>&quot;signal.h&quot;: WASI contains a header for this, but it annoyingly just reports an error<ul>
<li>My awful solution to this was to trick WASI into going into the &quot;no error&quot; fork, but without actually doing anything useful</li>
<li>All I did was add &quot;-D_WASI_EMULATED_SIGNAL -D_SIGNAL_H&quot; to my &quot;CFLAGS&quot; environment variable</li>
</ul>
</li>
<li>&quot;pwd.h&quot;: Another (missing, for me) POSIX header<ul>
<li>Hack: add a dummy header that defines <code>R_OK</code> and <code>SIGUSR1</code></li>
</ul>
</li>
</ul>
<p>At this point, I was (mostly) able to compile the libraries I needed, but not link.</p>
<p>Also, at this point, I was starting to appreciate just how much Emscripten must handle to support building stuff like this without any modifications. Maybe my main takeaway will just be to use Emscripten in the future?</p>
<h2 id="slimming-down-graphviz">Slimming down Graphviz</h2>
<p>For my purposes, I only needed to be able to parse DOT input, using the &quot;dot&quot; layout engine, and output to SVG. But Graphviz&#39;s default library has support for many outputs, including <a href="https://www.adobe.com/products/postscript.html">Adobe PostScript</a>, which I <em>definitely</em> have no plans to use. These defaults are encoded directly into &quot;graphviz/plugin/core/gvplugin_core.c&quot;.</p>
<p>In order to reduce the list down to just SVG, I needed to create my own &quot;plugin&quot; that only supported DOT and SVG. Here&#39;s what that looked like:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;gvplugin.h&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_installed_t</span> gvdevice_dot_types[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_installed_t</span> gvdevice_svg_types[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_installed_t</span> gvrender_dot_types[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_installed_t</span> gvrender_svg_types[];
<span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_installed_t</span> gvloadimage_core_types[];

<span class="hljs-keyword">static</span> <span class="hljs-type">gvplugin_api_t</span> apis[] = {
    {API_device, gvdevice_dot_types},
    {API_device, gvdevice_svg_types},
    {API_render, gvrender_dot_types},
    {API_render, gvrender_svg_types},

    {(<span class="hljs-type">api_t</span>)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>},
};

<span class="hljs-type">gvplugin_library_t</span> gvplugin_core_LTX_library = { <span class="hljs-string">&quot;core&quot;</span>, apis };

<span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPORT <span class="hljs-comment">/* nothing */</span></span>

IMPORT <span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_library_t</span> gvplugin_dot_layout_LTX_library;
IMPORT <span class="hljs-keyword">extern</span> <span class="hljs-type">gvplugin_library_t</span> gvplugin_core_LTX_library;

<span class="hljs-type">lt_symlist_t</span> lt_preloaded_symbols[] = {
    { <span class="hljs-string">&quot;gvplugin_dot_layout_LTX_library&quot;</span>, (<span class="hljs-type">void</span>*)(&amp;gvplugin_dot_layout_LTX_library) },
    { <span class="hljs-string">&quot;gvplugin_core_LTX_library&quot;</span>, (<span class="hljs-type">void</span>*)(&amp;gvplugin_core_LTX_library) },
    { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }
};</code></pre>
<p>This also had the benefit of removing a number of dependencies (including some that weren&#39;t yet building successfully for me yet).</p>
<h2 id="one-last-link-error">One last link error</h2>
<p>At this point, I was down to a final error from the linker. It turns out that, somewhere in Graphviz, it uses the <code>tmpfile</code> function. For now, I just decided to add a dummy implementation and hope that it wasn&#39;t being used for anything important:</p>
<pre><code class="language-c">FILE* <span class="hljs-title function_">tmpfile</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<h2 id="successful-build">Successful build</h2>
<p>Finally, I was able to successfully build &quot;dot2svg.wasm&quot;. The uncompressed file size ended up being around 660 KB--a bit larger than I hoped, but not huge.</p>
<p>Now I just have to run that function... right?</p>
<h1 id="javascript-side">JavaScript side</h1>
<p>Given that I already had code to pass strings back and forth, I hoped I could just call the <code>dot2svg</code> export and bask in the glorious result. But I wasn&#39;t quite there yet.</p>
<h2 id="imports">Imports</h2>
<p>On the first run, I got the following error:</p>
<pre><code><span class="hljs-symbol">TypeError:</span> WebAssembly.<span class="hljs-keyword">instantiate(): </span>Imports argument must <span class="hljs-keyword">be </span>present <span class="hljs-keyword">and </span>must <span class="hljs-keyword">be </span>an object</code></pre><p>That&#39;s too bad. I was hoping that my slimmed down Graphviz build wouldn&#39;t expect the host to provide any functions. Let&#39;s see what&#39;s missing:</p>
<pre><code class="language-sh">$ wasm2wat dot2svg.wasm|findstr /i import
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;clock_time_get&quot;</span> (func <span class="hljs-variable">$__wasi_clock_time_get</span> (<span class="hljs-built_in">type</span> 16)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_filestat_get&quot;</span> (func <span class="hljs-variable">$__wasi_fd_filestat_get</span> (<span class="hljs-built_in">type</span> 1)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;proc_exit&quot;</span> (func <span class="hljs-variable">$__wasi_proc_exit</span> (<span class="hljs-built_in">type</span> 10)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_fdstat_get&quot;</span> (func <span class="hljs-variable">$__wasi_fd_fdstat_get</span> (<span class="hljs-built_in">type</span> 1)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;path_open&quot;</span> (func <span class="hljs-variable">$__wasi_path_open</span> (<span class="hljs-built_in">type</span> 17)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;path_filestat_get&quot;</span> (func <span class="hljs-variable">$__wasi_path_filestat_get</span> (<span class="hljs-built_in">type</span> 7)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_close&quot;</span> (func <span class="hljs-variable">$__wasi_fd_close</span> (<span class="hljs-built_in">type</span> 0)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;environ_sizes_get&quot;</span> (func <span class="hljs-variable">$__wasi_environ_sizes_get</span> (<span class="hljs-built_in">type</span> 1)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;environ_get&quot;</span> (func <span class="hljs-variable">$__wasi_environ_get</span> (<span class="hljs-built_in">type</span> 1)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_seek&quot;</span> (func <span class="hljs-variable">$__wasi_fd_seek</span> (<span class="hljs-built_in">type</span> 18)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_write&quot;</span> (func <span class="hljs-variable">$__wasi_fd_write</span> (<span class="hljs-built_in">type</span> 4)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_read&quot;</span> (func <span class="hljs-variable">$__wasi_fd_read</span> (<span class="hljs-built_in">type</span> 4)))
  (import <span class="hljs-string">&quot;wasi_snapshot_preview1&quot;</span> <span class="hljs-string">&quot;fd_fdstat_set_flags&quot;</span> (func <span class="hljs-variable">$__wasi_fd_fdstat_set_flags</span> (<span class="hljs-built_in">type</span> 1)))</code></pre>
<h2 id="do-the-imports-really-matter">Do the imports really matter?</h2>
<p>That&#39;s a longer list than I expected. Ok, well let&#39;s see if they&#39;re <em>really</em> needed by providing no-op implementations:</p>
<pre><code class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./dot2svg.wasm&quot;</span>), {
        <span class="hljs-attr">wasi_snapshot_preview1</span>: {
            <span class="hljs-comment">// Not implemented</span>
            <span class="hljs-attr">clock_time_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">environ_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">environ_sizes_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_close</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_fdstat_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_fdstat_set_flags</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_filestat_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_read</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_seek</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">fd_write</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">path_filestat_get</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">path_open</span>: <span class="hljs-function">() =&gt;</span> {},
            <span class="hljs-attr">proc_exit</span>: <span class="hljs-function">() =&gt;</span> {},
        },
    });</code></pre>
<p>Unfortunately, with those no-op functions, my test script just seemed to spin.</p>
<h2 id="fd_write">fd_write</h2>
<p>Debugging showed that <code>fd_write</code> was being called repeatedly. That makes me think that WASI actually needs <code>fd_write</code> to do something. With absolutely zero context, the function name sounds like it&#39;s writing to a file descriptor.</p>
<p>After some digging, I found a helpful note in the (otherwise inscrutable) <a href="https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#-fd_writefd-fd-iovs-ciovec_array---resultsize-errno">WASI documentation</a>:</p>
<blockquote>
<p>fd_write(fd: fd, iovs: ciovec_array) -&gt; Result&lt;size, errno&gt;</p>
<p>Write to a file descriptor. Note: This is similar to writev in POSIX.</p>
</blockquote>
<h3 id="writev">writev</h3>
<p>Fortunately, <code>writev(2)</code> is <a href="https://linux.die.net/man/2/writev">extensively documented</a>.</p>
<p>The first argument is indeed a file descriptor. Debugging my test app showed that the function was being called with file descriptor 2, which is Standard Error. It&#39;s my opinion that libraries shouldn&#39;t directly write anything to Standard Output or Error, but I didn&#39;t write Graphviz. A quick scan of the Graphviz source indicated that I couldn&#39;t easily disable console logging.</p>
<p>The second argument to <code>writev</code> is an array of I/O vectors defined as follows:</p>
<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> {</span>
    <span class="hljs-type">void</span>  *iov_base;    <span class="hljs-comment">/* Starting address */</span>
    <span class="hljs-type">size_t</span> iov_len;     <span class="hljs-comment">/* Number of bytes to transfer */</span>
};</code></pre>
<p>And the return value is just the number of bytes written.</p>
<h3 id="javascript-implementation">JavaScript implementation</h3>
<p>Assuming that <code>fd_write</code> is the same (assuming 32-bit WebAssembly), this isn&#39;t too bad to implement (and I decided to forward to the console for testing purposes). The only remaining trick is that <code>fd_write</code> supplies the memory address for the return value as the third argument and directly returns a status code (zero for success).</p>
<p>Here&#39;s a simple implementation:</p>
<pre><code class="language-javascript"><span class="hljs-attr">fd_write</span>: <span class="hljs-function">(<span class="hljs-params">fileDescriptor, ioVectorsBaseAddress, ioVectorsCount, returnBytesWrittenAddress</span>) =&gt;</span> {
    <span class="hljs-comment">// Read IO vectors</span>
    <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataView</span>(memory.<span class="hljs-property">buffer</span>);
    <span class="hljs-keyword">const</span> ioVectors = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, address = ioVectorsBaseAddress; i &lt; ioVectorsCount; i++, address += <span class="hljs-number">8</span>) {
        ioVectors.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">sourceAddress</span>: view.<span class="hljs-title function_">getUint32</span>(address, <span class="hljs-literal">true</span>),
            <span class="hljs-attr">sizeInBytes</span>: view.<span class="hljs-title function_">getUint32</span>(address + <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>),
        });
    }

    <span class="hljs-comment">// Calculate total size</span>
    <span class="hljs-keyword">const</span> totalSizeInBytes = ioVectors.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, ioVector</span>) =&gt;</span> sum + ioVector.<span class="hljs-property">sizeInBytes</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// Forward STDOUT and STDERR to console</span>
    <span class="hljs-keyword">const</span> standardOutput = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> standardError = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">switch</span> (fileDescriptor) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">standardOutput</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-attr">standardError</span>:
            {
                <span class="hljs-comment">// Copy to buffer</span>
                <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(totalSizeInBytes);
                <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
                ioVectors.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">ioVector</span> =&gt;</span> {
                    buffer.<span class="hljs-title function_">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(memory.<span class="hljs-property">buffer</span>, ioVector.<span class="hljs-property">sourceAddress</span>, ioVector.<span class="hljs-property">sizeInBytes</span>), offset);
                    offset += ioVector.<span class="hljs-property">sizeInBytes</span>;
                });

                <span class="hljs-comment">// Note: Adds an extra new line...</span>
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textDecoder.<span class="hljs-title function_">decode</span>(buffer));
            }
            <span class="hljs-keyword">break</span>;

        <span class="hljs-attr">default</span>:
            <span class="hljs-comment">// Do nothing</span>
            <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-comment">// Set return value to total size of writes</span>
    view.<span class="hljs-title function_">setUint32</span>(returnBytesWrittenAddress, totalSizeInBytes, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Success</span>
},</code></pre>
<h2 id="success">Success!</h2>
<p>With the above imports, <a href="https://github.com/jaredkrinke/wasm-c-string">my string-passing library</a>, and the following code:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> dotString = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;digraph { a -&gt; b }&quot;</span>;
<span class="hljs-title function_">createCString</span>(<span class="hljs-variable language_">module</span>, dotString, <span class="hljs-function">(<span class="hljs-params">dotStringAddress</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> svgString = <span class="hljs-title function_">receiveCString</span>(<span class="hljs-variable language_">module</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">dot2svg</span>(dotStringAddress));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(svgString);
});</code></pre>
<p>I was finally able to generate the following test graph SVG:</p>
<p><img src="../../../assets/graphviz-test-graph.svg" alt="digraph { a -&gt; b }"></p>
<p>Additionally, if I deliberately insert a syntax error into the graph, I see the error logged to my console, so output forwarding is even working.</p>
<h1 id="conclusion">Conclusion</h1>
<p>There&#39;s still work I need to do around theming, packaging, and more, but as a proof of concept, it looks like compiling a C library to WebAssembly with minimal tooling beyond Clang and LLVM is certainly possible, with some perseverance.</p>
<p>Lessons learned:</p>
<ul>
<li>Always first check to see if someone has already ported the library you&#39;re interested in--if they have, and you can tolerate their dependencies, you&#39;ll save significant effort</li>
<li>You can&#39;t assume that a &quot;simple&quot; C library won&#39;t have surprising dependencies (e.g. Graphviz depending on PostScript headers by default)</li>
<li>Compiling typical C libraries to WebAssembly on Windows is painful (not discussed here, but I actually did that first, before moving to Linux for a more compiler-friendly environment)</li>
<li>Emscripten will probably save you time dealing with obscure or unsupported-by-WASI headers</li>
<li>WASI itself might require additional support code (there is a <a href="https://wasi.dev/polyfill/">poorly documented browser polyfill for WASI</a>, but I haven&#39;t tested it)</li>
</ul>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://github.com/jaredkrinke/dot2svg-wasm">Repository for this code)</a> (as an ES module)</li>
<li><a href="../../static-site-generators/metalsmith-diagrams/">Example of using this code to generate diagrams automatically for my site</a></li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/compiling-graphviz-to-webassembly</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/compiling-graphviz-to-webassembly</guid><pubDate>Sat, 09 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[WebAssembly objects, libraries, and linking (for C code)]]></title><description><![CDATA[<p>In the interest of reusing <a href="../passing-strings-to-c/">some C string handling code I wrote for use in WebAssembly</a>, I&#39;m researching how object files, libraries, and linking work in WebAssembly.</p>
<h1 id="background">Background</h1>
<p>For native C code, the following file types and concepts are used:</p>
<ul>
<li>Header files (.h) define the interfaces used between source files</li>
<li>Source files (.c) implement functionality</li>
<li>Object files (.o) each represent the compiled (using &quot;-c&quot;) output of a single source file</li>
<li>Archive files (.a) contain many object files and are used for build-time linking (static libraries)</li>
<li>Shared objects (.so) or dynamic-link libraries (.dll) support linking at run-time (shared libraries)</li>
</ul>
<p>How does the Clang/LLVM toolchain map these concepts to WebAssembly?</p>
<h1 id="webassembly-object-files">WebAssembly object files</h1>
<p>To my surprise, WebAssembly actually publishes <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md">conventions for creating and linking object files</a>.</p>
<p>I certainly didn&#39;t read that entire document, but I did note that object files are just WebAssembly modules, with custom sections (note: custom sections are only supported in binary &quot;.wasm&quot; format, and not text &quot;.wat&quot; format).</p>
<h2 id="example">Example</h2>
<p>My WebAssembly string library is very simple:</p>
<ul>
<li>It defines <code>wasm_c_string</code> which represents a string on the heap that will be return to the JavaScript host</li>
<li>It exports 2 functions:<ul>
<li><code>allocate_wasm_c_string</code> to allocate a wasm_c_string of a given length</li>
<li><code>create_wasm_c_string</code> to allocate a wasm_c_string that is a copy of any old C string</li>
</ul>
</li>
</ul>
<p>Note that this example requires consumers of the library providing <code>malloc()</code> and <code>free()</code> to the JavaScript host. I don&#39;t export these from my library because I want consumers to be able to supply their own allocator.</p>
<h3 id="c-source-code">C source code</h3>
<p>Here&#39;s the header file (&quot;wasm-c-string.h&quot;):</p>
<pre><code class="language-c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length;
    <span class="hljs-type">char</span> buffer[];
} wasm_c_string;

<span class="hljs-comment">// Allocates an empty wasm_c_string. When done, use &quot;free&quot; to release.</span>
<span class="hljs-keyword">extern</span> wasm_c_string* <span class="hljs-title function_">allocate_wasm_c_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span>;

<span class="hljs-comment">// Creates a new wasm_c_string from an existing C string. When done, use &quot;free&quot; to release.</span>
<span class="hljs-keyword">extern</span> wasm_c_string* <span class="hljs-title function_">create_wasm_c_string</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* source)</span>;</code></pre>
<p>And the source file (&quot;wasm-c-string.c&quot;):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;wasm-c-string.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

wasm_c_string* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(allocate_wasm_c_string)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span> {
    wasm_c_string* str = (wasm_c_string*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) + length);
    str-&gt;length = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)length;
    <span class="hljs-keyword">return</span> str;
}

wasm_c_string* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(create_wasm_c_string)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* source)</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-type">size_t</span> sourceLength = <span class="hljs-built_in">strlen</span>(source);
    wasm_c_string* str = allocate_wasm_c_string((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)sourceLength);
    <span class="hljs-built_in">memcpy</span>(&amp;str-&gt;buffer[<span class="hljs-number">0</span>], source, sourceLength);
    <span class="hljs-keyword">return</span> str;
}</code></pre>
<h3 id="compiling">Compiling</h3>
<p>Let&#39;s compile this to an object file (using the <a href="https://github.com/WebAssembly/wasi-sdk">WASI SDK</a>--note the &quot;-c&quot; argument that tells Clang to only output an object file and not invoke the linker):</p>
<pre><code class="language-sh">wasi-sdk\\bin\\clang -Os --sysroot wasi-sdk/share/wasi-sysroot -c wasm-c-string.c</code></pre>
<h3 id="text-format">Text format</h3>
<p>The output file defaults to &quot;wasm-c-string.o&quot; and here&#39;s the (abbreviated) corresponding text format (compliments of the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a>&#39;s <code>wasm2wat</code> tool):</p>
<pre><code class="language-wasm"><span class="hljs-punctuation">(</span><span class="hljs-keyword">module</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-comment">(;1;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__linear_memory&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">memory</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;__indirect_function_table&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">table</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-number">0</span> funcref<span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;malloc&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;0;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;strlen&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;1;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;env&quot;</span> <span class="hljs-string">&quot;memcpy&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-comment">(;2;)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$allocate_wasm_c_string</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
...
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$create_wasm_c_string</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">type</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">param</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">result</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">)</span>
...
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;allocate_wasm_c_string&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$allocate_wasm_c_string</span><span class="hljs-punctuation">))</span>
  <span class="hljs-punctuation">(</span><span class="hljs-keyword">export</span> <span class="hljs-string">&quot;create_wasm_c_string&quot;</span> <span class="hljs-punctuation">(</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">$create_wasm_c_string</span><span class="hljs-punctuation">)))</span>
</code></pre>
<p>You can see that it&#39;s importing memory, a function table, and C standard library functions, and that it&#39;s exporting my 2 functions.</p>
<h3 id="custom-sections">Custom sections</h3>
<p>But wait, the object file conventions document indicates that there are custom sections that can&#39;t be represented in the text format. So let&#39;s use <code>wasm-objdump</code> (also from WABT):</p>
<pre><code><span class="hljs-string">$</span> <span class="hljs-string">wasm-objdump</span> <span class="hljs-string">-s</span> <span class="hljs-string">wasm-c-string.o</span>

<span class="hljs-attr">wasm-c-string.o:</span>    <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">wasm</span> <span class="hljs-number">0x1</span>

<span class="hljs-string">...</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">0000119:</span> <span class="hljs-string">076c</span> <span class="hljs-string">696e</span> <span class="hljs-string">6b69</span> <span class="hljs-number">6e67</span> <span class="hljs-number">0208 </span><span class="hljs-string">be80</span> <span class="hljs-number">8080 </span><span class="hljs-number">0005</span>  <span class="hljs-string">.linking........</span>
<span class="hljs-attr">0000129:</span> <span class="hljs-string">00a4</span> <span class="hljs-number">0103 </span><span class="hljs-number">1661 </span><span class="hljs-string">6c6c</span> <span class="hljs-string">6f63</span> <span class="hljs-number">6174 </span><span class="hljs-string">655f</span> <span class="hljs-number">7761</span>  <span class="hljs-string">.....allocate_wa</span>
<span class="hljs-attr">0000139:</span> <span class="hljs-string">736d</span> <span class="hljs-string">5f63</span> <span class="hljs-string">5f73</span> <span class="hljs-number">7472 </span><span class="hljs-string">696e</span> <span class="hljs-number">6700 </span><span class="hljs-number">1000 </span><span class="hljs-string">00a4</span>  <span class="hljs-string">sm_c_string.....</span>
<span class="hljs-attr">0000149:</span> <span class="hljs-number">0104 </span><span class="hljs-number">1463 </span><span class="hljs-number">7265 </span><span class="hljs-number">6174 </span><span class="hljs-string">655f</span> <span class="hljs-number">7761 </span><span class="hljs-string">736d</span> <span class="hljs-string">5f63</span>  <span class="hljs-string">...create_wasm_c</span>
<span class="hljs-attr">0000159:</span> <span class="hljs-string">5f73</span> <span class="hljs-number">7472 </span><span class="hljs-string">696e</span> <span class="hljs-number">6700 </span><span class="hljs-number">1001 </span><span class="hljs-number">0010 </span><span class="hljs-number">02</span>         <span class="hljs-string">_string......</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">000016c:</span> <span class="hljs-string">0a72</span> <span class="hljs-string">656c</span> <span class="hljs-string">6f63</span> <span class="hljs-number">2e43</span> <span class="hljs-string">4f44</span> <span class="hljs-number">4504 </span><span class="hljs-number">0400 </span><span class="hljs-string">0b01</span>  <span class="hljs-string">.reloc.CODE.....</span>
<span class="hljs-attr">000017c:</span> <span class="hljs-number">0021 </span><span class="hljs-number">0300 </span><span class="hljs-string">2c01</span> <span class="hljs-number">0042 </span><span class="hljs-number">04</span>                   <span class="hljs-string">.!..,..B.</span>

<span class="hljs-attr">Contents of section Custom:</span>
<span class="hljs-attr">000018b:</span> <span class="hljs-number">0970 </span><span class="hljs-string">726f</span> <span class="hljs-number">6475 </span><span class="hljs-number">6365 </span><span class="hljs-number">7273 </span><span class="hljs-string">010c</span> <span class="hljs-number">7072 </span><span class="hljs-string">6f63</span>  <span class="hljs-string">.producers..proc</span>
<span class="hljs-attr">000019b:</span> <span class="hljs-number">6573 </span><span class="hljs-number">7365 </span><span class="hljs-string">642d</span> <span class="hljs-number">6279 </span><span class="hljs-number">0105 </span><span class="hljs-string">636c</span> <span class="hljs-string">616e</span> <span class="hljs-number">6756  </span><span class="hljs-string">essed-by..clangV</span>
<span class="hljs-attr">00001ab:</span> <span class="hljs-number">3131 </span><span class="hljs-number">2e30</span> <span class="hljs-number">2e30</span> <span class="hljs-number">2028 </span><span class="hljs-number">6874 </span><span class="hljs-number">7470 </span><span class="hljs-string">733a</span> <span class="hljs-string">2f2f</span>  <span class="hljs-number">11.0</span><span class="hljs-number">.0</span> <span class="hljs-string">(https://</span>
<span class="hljs-attr">00001bb:</span> <span class="hljs-number">6769 </span><span class="hljs-number">7468 </span><span class="hljs-number">7562 </span><span class="hljs-number">2e63</span> <span class="hljs-string">6f6d</span> <span class="hljs-string">2f6c</span> <span class="hljs-string">6c76</span> <span class="hljs-string">6d2f</span>  <span class="hljs-string">github.com/llvm/</span>
<span class="hljs-attr">00001cb:</span> <span class="hljs-string">6c6c</span> <span class="hljs-string">766d</span> <span class="hljs-string">2d70</span> <span class="hljs-string">726f</span> <span class="hljs-string">6a65</span> <span class="hljs-number">6374 </span><span class="hljs-number">2031 </span><span class="hljs-number">3736  </span><span class="hljs-string">llvm-project</span> <span class="hljs-number">176</span>
<span class="hljs-attr">00001db:</span> <span class="hljs-number">3234 </span><span class="hljs-number">3962 </span><span class="hljs-number">6436 </span><span class="hljs-number">3733 </span><span class="hljs-number">3261 </span><span class="hljs-number">3830 </span><span class="hljs-number">3434 </span><span class="hljs-number">6434  </span><span class="hljs-string">249bd6732a8044d4</span>
<span class="hljs-attr">00001eb:</span> <span class="hljs-number">3537 </span><span class="hljs-number">3039 </span><span class="hljs-number">3265 </span><span class="hljs-number">6439 </span><span class="hljs-number">3332 </span><span class="hljs-number">3736 </span><span class="hljs-number">3837 </span><span class="hljs-number">3234  </span><span class="hljs-string">57092ed932768724</span>
<span class="hljs-attr">00001fb:</span> <span class="hljs-number">6136 </span><span class="hljs-number">6630 </span><span class="hljs-number">3629                           </span><span class="hljs-string">a6f06)</span>
</code></pre><p>Sure enough, there are custom sections related to linking, relocation, and even a curious &quot;producers&quot; section (that apparently exists to <a href="https://github.com/WebAssembly/tool-conventions/blob/main/ProducersSection.md">allow analysis of toolchain usage in the wild</a>).</p>
<h1 id="webassembly-libraries">WebAssembly libraries</h1>
<p>For something as simple as my 20 line C library, I could probably just distribute the C header and the compiled WebAssembly object file (which is actually a WebAssembly module with custom sections) and be done. What if I have a larger library?</p>
<h2 id="dynamic-libraries">Dynamic libraries</h2>
<p>Once again, to my surprise, WebAssembly publishes <a href="https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md">conventions for dynamically loading libraries</a>, but the document notes there is no stable ABI. That&#39;s ok, I didn&#39;t really need dynamic libraries right now anyway.</p>
<h2 id="static-libraries">Static libraries</h2>
<p>Static libraries for native C code are often just archives (using the <a href="https://en.wikipedia.org/wiki/Ar_%28Unix%29"><code>ar</code></a> archiver tool), perhaps with some additional information to describe the library.</p>
<p>Can I just do the same thing for WebAssembly? It certainly appears so.</p>
<p>If I inspect the WASI SDK, in the WebAssembly sysroot, I actually see both bare objects and archives for the C standard library and friends:</p>
<pre><code class="language-sh">$ ls wasi-sdk/share/wasi-sysroot/lib/wasm32-wasi
crt1-command.o  libc++abi.a                         libdl.a       libutil.a
crt1.o          libc.imports                        libm.a        libwasi-emulated-mman.a
crt1-reactor.o  libc-printscan-long-double.a        libpthread.a  libwasi-emulated-signal.a
libc++.a        libc-printscan-no-floating-point.a  libresolv.a   libxnet.a
libc.a          libcrypt.a                          librt.a</code></pre>
<p>What&#39;s in one of these archives? <code>ar -t libc.a</code> shows a bunch of object files. If I extract an object named &quot;ccos.o&quot; with <code>ar -x libc.a ccos.o</code>, I can use <code>wasm-objdump</code> or <code>wasm2wat</code> to see that it&#39;s just a regular WebAssembly object file.</p>
<p>I&#39;m impressed that the people working on WebAssembly resisted the urge to create entirely new tools, and instead just decided to leverage existing UNIX tools that have been around for a long time.</p>
<h1 id="linking">Linking</h1>
<p>The <a href="https://lld.llvm.org/WebAssembly.html">documentation for wasm-ld</a> is brief, but it does have most of the information you need.</p>
<p>The main tricks are:</p>
<ul>
<li>Pass <code>--no-entry</code> on the command line to indicate there is no <code>_start</code> entry point</li>
<li>By default, only symbols marked with the <code>export-name</code> attribute are exported (see <code>WASM_EXPORT</code> in the C example earlier for a handy macro to add this)</li>
</ul>
<h1 id="summary">Summary</h1>
<p>It turns out that the toolchain for WebAssembly libraries in C is similar to what one would use for native compilation:</p>
<ul>
<li>Publish header files (.h) to define the library&#39;s interface</li>
<li>Compile source files (.c) to object files (.o) using <code>clang</code></li>
<li>If needed, consolidate multiple object files into an archive (.a) using <code>ar</code></li>
<li>Publish either a single object file or (more likely) an archive for users to consume</li>
<li>For an object file, users just add it to the list on their <code>wasm-ld</code> command line</li>
<li>For an archive, consumers add <code>-l&lt;name of archive without extension&gt;</code> to their <code>wasm-ld</code> command line</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/objects-libraries-and-linking</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/objects-libraries-and-linking</guid><pubDate>Wed, 06 Oct 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Passing strings to and from WebAssembly using C]]></title><description><![CDATA[<p>As a follow-up to a <a href="../trivial-example/">trivial WebAssembly example in C</a> and <a href="../c-standard-library-example/">an example of using the C standard library in WebAssembly</a>, I&#39;m now investigating passing strings back and forth between the JavaScript host and a WebAssembly module written in C (and compiled with Clang/LLVM).</p>
<p>Links to a library (<strong>new</strong>), the sample code, and a live demo are at <a href="#links">the end of the post</a>.</p>
<h1 id="passing-a-string-from-javascript-to-c">Passing a string from JavaScript to C</h1>
<p>Recall that WebAssembly <a href="https://webassembly.github.io/spec/core/syntax/types.html">doesn&#39;t have a string type</a>. How can a C function receive a string when compiled to WebAssembly?</p>
<h2 id="pass-in-by-directly-populating-linear-memory">Pass in by directly populating linear memory</h2>
<p>Also known as: failed attempt #1.</p>
<ol>
<li>Add a null character onto the end of the string</li>
<li>Use the browser&#39;s TextEncoder API to convert a string to a byte sequence</li>
<li>Write the buffer into linear memory</li>
<li>Pass the address of the null-terminated string to C code</li>
<li>C code can read the string as a null-terminated UTF-8 string</li>
</ol>
<p>Obviously, this limits strings to fit in linear memory (where I assume the maximum size is 2^32-1), and requiring a null terminator means embedded nulls aren&#39;t supported. I don&#39;t think these will be a problem for me personally.</p>
<p>I gave this approach a try, but there were several problems with it.</p>
<p>The <a href="https://lld.llvm.org/WebAssembly.html">LLVM WebAssembly documentation</a> hints at it, but inspecting the output of a trivial C program compiled to WebAssembly shows that LLVM&#39;s WebAssembly linker uses linear memory for both the stack and the heap. This makes sense, of course--memory has to come from somewhere. I couldn&#39;t find LLVM documentation to definitively confirm this, but <a href="https://surma.dev/things/c-to-webassembly/">I&#39;ve read that the WebAssembly stack grows downward and has a default size of only 64 KB</a> (customizable with the <code>-z stacksize=&lt;value&gt;</code> option). The heap follows the stack by default.</p>
<p>This means that you don&#39;t really have a place to stuff in your encoded string. I also didn&#39;t see a way to use a separate memory for passing in data to C functions.</p>
<p>The fundamental problem with this approach is that the C-based WebAssembly module needs complete control over its memory, and there doesn&#39;t appear to be a way to access a different memory from C code, as compiled with Clang and LLVM&#39;s WebAssembly linker. There are likely libraries (probably with hand-written WebAssembly) to enable this, but I&#39;d like a simple solution.</p>
<h2 id="pass-on-the-stack">Pass on the stack</h2>
<p>Also known as: very limited approach #2.</p>
<p>Probably not a good idea because you&#39;re limited based on the maximum stack size (mentioned above), but theoretically you could pass in a string on the stack by having your JavaScript code implement whatever calling convention is used by Clang/LLVM for WebAssembly (modifying the stack pointer as a <a href="https://github.com/WebAssembly/mutable-global">mutable global</a>). This seems tedious and not worth the effort unless you have strings that you know will be much smaller than the maximum stack size (or you tell LLVM&#39;s WebAssembly linker to grow the stack upwards (although then you&#39;re limiting your heap size, which is probably even more unexpected to most non-embedded C code that&#39;s laying around).</p>
<p>I won&#39;t dwell on this idea any more since I want to use the default memory layout.</p>
<h2 id="pass-in-via-the-heap">Pass in via the heap</h2>
<p>Also known as: successful attempt #3.</p>
<p>Here&#39;s a new idea: let the C code control its entire address space, but expose functions to let JavaScript allocate some memory.</p>
<ol>
<li>Expose <code>allocate</code> and <code>deallocate</code> functions (and the memory itself) to let JavaScript allocate and free memory in the heap</li>
<li>Add a null character onto the end of the string</li>
<li>Use the browser&#39;s TextEncoder API to convert a string to a byte sequence</li>
<li>Allocate a buffer (in C address space) for the string (using the exported function <code>allocate</code>)</li>
<li>Write the encoded string into the heap allocation</li>
<li>Call C code to read the string as a (normal) null-terminated UTF-8 string</li>
<li>Deallocate/free the string when it&#39;s no longer needed (using the exported function <code>deallocate</code>)</li>
</ol>
<p>This approach adds overhead in the form of allocating for every string passed in, but if the ratio of calls to time spent in each call is low enough, this could be tolerable (and you could always optimize the approach to reuse allocations when possible, if needed). Overall, this seems straight forward and robust, so I&#39;m going to try this out.</p>
<h3 id="c-implementation">C implementation</h3>
<p>As an example, I&#39;ve created a function that counts the number of occurrences of the (lower case) letter &quot;a&quot; in a string. Note that I have to export an allocator and a deallocator.</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT_AS(name) __attribute__((export_name(name)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WASM_EXPORT(symbol) WASM_EXPORT_AS(#symbol) symbol</span>

<span class="hljs-comment">// Memory management helpers</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(allocate)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(deallocate)</span><span class="hljs-params">(<span class="hljs-type">void</span>* allocation)</span> {
    <span class="hljs-built_in">free</span>(allocation);
}

<span class="hljs-comment">// Example of passing a string in</span>
<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(count_as)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-built_in">string</span>)</span> {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numberOfAs = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (*<span class="hljs-built_in">string</span> != <span class="hljs-string">&#x27;\0&#x27;</span>) {
        <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">string</span> == <span class="hljs-string">&#x27;a&#x27;</span>) {
            ++numberOfAs;
        }
        <span class="hljs-built_in">string</span>++;
    }
    <span class="hljs-keyword">return</span> numberOfAs;
}</code></pre>
<h3 id="compiling">Compiling</h3>
<p>The build command is unchanged <a href="../c-standard-library-example/#compiling">from the last post</a>:</p>
<pre><code class="language-sh">wasi-sdk/bin/clang -Os --sysroot wasi-sdk/share/wasi-sysroot -nostartfiles -Wl,--no-entry string-example.c -o string-example.wasm</code></pre>
<h3 id="javascript-caller">JavaScript caller</h3>
<p>The JavaScript wrapper is more involved than I&#39;d like, but it does work:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;

(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> testString = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;How many letter a&#x27;s are there in this string? Three!&quot;</span>;
    <span class="hljs-keyword">const</span> nullTerminatedString = testString + <span class="hljs-string">&quot;\0&quot;</span>;
    <span class="hljs-keyword">const</span> encodedString = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>()).<span class="hljs-title function_">encode</span>(nullTerminatedString);
    <span class="hljs-keyword">const</span> stringAddress = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">allocate</span>(encodedString.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> destination = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>, stringAddress);
        destination.<span class="hljs-title function_">set</span>(encodedString);
        <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">count_as</span>(stringAddress);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(stringAddress);
    }
})();</code></pre>
<h3 id="result">Result</h3>
<p>Behold the result:</p>
<pre><code class="language-sh">$ node pass-in-string.js <span class="hljs-string">&quot;a string that has lots of the letter &#x27;a&#x27; in it&quot;</span> 
4</code></pre>
<p>Looks good!</p>
<h3 id="memory-management-helper">Memory management helper</h3>
<p>Having to manually manage memory in JavaScript is error-prone, so I&#39;m going to wrap this code in a helper:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> textEncoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createCString</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, str, run</span>) =&gt; {
    <span class="hljs-keyword">const</span> nullTerminatedString = str + <span class="hljs-string">&quot;\0&quot;</span>;
    <span class="hljs-keyword">const</span> encodedString = textEncoder.<span class="hljs-title function_">encode</span>(nullTerminatedString);
    <span class="hljs-keyword">const</span> address = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">allocate</span>(encodedString.<span class="hljs-property">length</span>);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> destination = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>, address);
        destination.<span class="hljs-title function_">set</span>(encodedString);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">run</span>(address);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(address);
    }
};</code></pre>
<p>Note: it would probably be helpful to extend these helpers to support multiple strings/allocations, but I&#39;m not trying to completely reinvent wrapping/binding libraries like Emscripten right now.</p>
<p>Now, the final string passing code is simple:</p>
<pre><code class="language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> testString = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;How many letter a&#x27;s are there in this string? Three!&quot;</span>;
    <span class="hljs-title function_">createCString</span>(<span class="hljs-variable language_">module</span>, testString, <span class="hljs-function">(<span class="hljs-params">stringAddress</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">count_as</span>(stringAddress);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    });
})();</code></pre>
<h1 id="returning-a-string-from-c-to-javascript">Returning a string from C to JavaScript</h1>
<p>Here was my initial thinking for returning a dynamic string from C to JavaScript (recorded before I completed the example above):</p>
<ol>
<li>(Assuming a null-terminated UTF-8 string)</li>
<li>Write the string directly into linear memory</li>
<li>Return the address as an (&quot;unsigned&quot;) integer (&quot;unsigned&quot; in quotes because WebAssembly doesn&#39;t have a separate unsigned int type)</li>
<li>JavaScript can decode the string using <code>TextDecoder.decode()</code></li>
<li>(Also make sure to export a function to free generated strings)</li>
</ol>
<p>Given that I&#39;m already exposing allocations to JavaScript, I thought this would work, but there&#39;s one problem: <code>TextDecoder.decode()</code> doesn&#39;t have built-in support for null-terminated strings (nor should it, in my opinion). Potential solutions:</p>
<ol>
<li>Have JavaScript can for the null terminator</li>
<li>Return the string and its length, possibly by encoding the length into the top half of a 64-bit return value (note: <a href="https://github.com/WebAssembly/design/blob/main/Portability.md#assumptions-for-efficient-execution">WebAssembly is always little endian</a>)</li>
</ol>
<p>I&#39;m going to opt for the first option.</p>
<p>Note that I&#39;m assuming returned strings will be dynamically allocated, because constant strings should really just be provided directly using JavaScript. If the string <em>must</em> come from C code, all you&#39;d need to do is skip the allocation management steps (and hope that the JavaScript code doesn&#39;t decide to mutate the string!).</p>
<h2 id="c-implementation-1">C implementation</h2>
<p>Here&#39;s some simple code that creates a string with the letter &quot;b&quot; repeated a caller-supplied number of times:</p>
<pre><code class="language-c"><span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">WASM_EXPORT</span><span class="hljs-params">(write_bs)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count)</span> {
    <span class="hljs-comment">// Allocate space for the string, plus a null terminator</span>
    <span class="hljs-type">char</span>* str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(count + <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Fill in the string and null terminator</span>
    <span class="hljs-type">char</span>* c = str;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
        *c = <span class="hljs-string">&#x27;b&#x27;</span>;
        ++c;
    }
    *c = <span class="hljs-string">&#x27;\0&#x27;</span>;

    <span class="hljs-keyword">return</span> str;
}</code></pre>
<h2 id="javascript-implementation">JavaScript implementation</h2>
<p>Here&#39;s the corresponding JavaScript on the other side:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;

(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;3&quot;</span>);
    <span class="hljs-keyword">const</span> address = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">write_bs</span>(count);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>;
        <span class="hljs-keyword">const</span> encodedStringLength = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address)).<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">const</span> encodedStringBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address, encodedStringLength);
        <span class="hljs-keyword">const</span> result = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>()).<span class="hljs-title function_">decode</span>(encodedStringBuffer);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(address);
    }
})();</code></pre>
<p>Output:</p>
<pre><code class="language-sh">$ node return-string.js 5
bbbbb</code></pre>
<p>Looks good!</p>
<h2 id="helpers">Helpers</h2>
<p>Similar to above, I&#39;m going to refactor this logic into helpers (one for static strings, and one for new strings return via the heap):</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> textDecoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">readStaticCString</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, address</span>) =&gt; {
    <span class="hljs-keyword">const</span> buffer = <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">memory</span>.<span class="hljs-property">buffer</span>;
    <span class="hljs-keyword">const</span> encodedStringLength = (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address)).<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> encodedStringBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint</span>8<span class="hljs-built_in">Array</span>(buffer, address, encodedStringLength);
    <span class="hljs-keyword">return</span> textDecoder.<span class="hljs-title function_">decode</span>(encodedStringBuffer);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">receiveCString</span> = (<span class="hljs-params"><span class="hljs-variable language_">module</span>, create</span>) =&gt; {
    <span class="hljs-keyword">const</span> address = <span class="hljs-title function_">create</span>();
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readStaticCString</span>(<span class="hljs-variable language_">module</span>, address);
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">deallocate</span>(address);
    }
};</code></pre>
<p>This simplifies the calling code significantly:</p>
<pre><code class="language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(<span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./string-example.wasm&quot;</span>));

    <span class="hljs-comment">// String used for testing (from command line or hard-coded)</span>
    <span class="hljs-keyword">const</span> count = <span class="hljs-built_in">parseInt</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>] ?? <span class="hljs-string">&quot;3&quot;</span>);
    <span class="hljs-keyword">const</span> str = <span class="hljs-title function_">receiveCString</span>(<span class="hljs-variable language_">module</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-title function_">write_bs</span>(count));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
})();</code></pre>
<h1 id="strings-✔">Strings: ✔</h1>
<p>Perhaps that wasn&#39;t the most enjoyable experiment, but it does give one a new appreciation for binding generators that do all this work for you.</p>
<p>Armed with a way to pass strings between JavaScript and C, I&#39;m now ready to leverage old C code (that I don&#39;t want to rewrite) by recompiling for WebAssembly and adding appropriate JavaScript glue. Theoretically the final WebAssembly module artifact will be useful for a long time (&quot;compile once, run forever&quot;?). I have one project in mind, but I&#39;m not going to discuss it or commit to anything just yet.</p>
<p>Have fun manually managing memory with JavaScript!</p>
<h1 id="links">Links:</h1>
<ul>
<li><a href="https://github.com/jaredkrinke/wasm-c-string">Library for the string handling helpers</a> (with tests)</li>
<li><a href="https://github.com/jaredkrinke/webassembly-c-string-example">Repository with the test code</a></li>
<li><a href="https://jaredkrinke.github.io/webassembly-c-string-example/">Live demo</a></li>
</ul>
]]></description><link>https://log.schemescape.com/posts/webassembly/passing-strings-to-c</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/passing-strings-to-c</guid><pubDate>Tue, 05 Oct 2021 00:00:00 GMT</pubDate></item></channel></rss>