<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Sun, 26 Sep 2021 16:30:23 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[WebAssembly overview]]></title><description><![CDATA[<h1 id="background">Background</h1>
<h1 id="emscripten">Emscripten</h1>
<p>I first heard of <a href="https://emscripten.org/">Emscripten</a> in the mid-2010s. At the time, you could compile C code to an optimizability-focused subset of JavaScript known as <a href="http://asmjs.org/">asm.js</a>. This meant that, given the source code to a native app and appropriate implementations of system APIs, you could run <em>formerly</em> native-only programs in the browser--convenient, if you don&#39;t want to install anything.</p>
<h2 id="enter-webassembly">Enter WebAssembly</h2>
<p>In the intervening years, <a href="https://webassembly.org/">WebAssembly</a> appeared. WebAssembly is a binary format for programs that run on a portable virtual machine. This VM can be hosted in your browser, but non-browser runtimes have also sprung up (e.g. <a href="https://wasmtime.dev/">wasmtime</a>).</p>
<p>WebAssembly, to me, seems like the <a href="https://en.wikipedia.org/wiki/Holy_Grail">Holy Grail</a> of compilation targets. I wouldn&#39;t be surprised if, thanks to browser support, WebAssembly is <em>the</em> most broadly supported binary program format. What other binary format works on my desktop, phone, <a href="https://www.raspberrypi.org/">Raspberry Pi</a>?</p>
<p>Note that WebAssembly runtimes seem to be standardizing on an in-development system interface named <a href="https://wasi.dev/">WASI</a>. You probably can&#39;t write a GUI app solely with WebAssembly and WASI today, but I&#39;m sure that day is coming (in the distant future).</p>
<h2 id="one-note-on-emscripten">One note on Emscripten</h2>
<p>If you just want to port native programs to the browser, Emscripten is an environment for doing that. It even converts <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> to <a href="https://www.khronos.org/webgl/">WebGL</a> and handles the <a href="https://www.libsdl.org/">SDL</a> API. Unfortunately, just <em>installing</em> Emscripten requires Python. For now, I refuse to setup bloated software just to <em>install</em> the software I actually want, so I&#39;m skipping Emscripten.</p>
<h1 id="webassembly-concepts">WebAssembly concepts</h1>
<p>Mozilla&#39;s documentation has a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts">great overview of WebAssembly concepts</a>. There&#39;s also an <a href="https://hacks.mozilla.org/2017/07/creating-a-webassembly-module-instance-with-javascript/">approachable series of WebAssembly articles</a> on Mozilla Hacks. I&#39;ll try to summarize:</p>
<ul>
<li><strong>Module</strong>: a compiled WebAssembly binary (declaring imports and exports)</li>
<li><strong>Instance</strong>: a module along with its state (memory, table, imports)</li>
<li><strong>Memory</strong>: a read/write, resizable buffer provided to the instance</li>
<li><strong>Table</strong>: array of references that aren&#39;t directly stored in WebAssembly-accessible memory (for security reasons)<ul>
<li>The example I&#39;ve seen for this is to be able to pass function pointers into C/C++ code</li>
</ul>
</li>
</ul>
<h1 id="webassembly-formats">WebAssembly formats</h1>
<p>WebAssembly defines two formats:</p>
<ul>
<li><strong>.wasm</strong>: Binary format</li>
<li><strong>.wat</strong>: Text format (assembly)</li>
</ul>
<p>The <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> contains tools for converting between these formats. Specifically, <code>wat2wasm</code> is analogous to a very simple assembler, and <code>wasm2wat</code> to a disassembler.</p>
<h1 id="webassembly-browser-interface">WebAssembly browser interface</h1>
<p>Within the browser, WebAssembly <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running">currently needs to be loaded using JavaScript</a> (it sounds like there are plans to support loading using script tags and import statements in the future). Sadly, as of today, the recommended way to load WebAssembly (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming()</a>) is <a href="https://caniuse.com/?search=instantiateStreaming">only supported by 75% of browsers</a>. The more broadly supported <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">WebAssembly.instantiate()</a> seems cumbersome. I&#39;m hopeful that WebAssembly&#39;s ergonomics will improve, but I suppose this is just the price you pay when using new technology.</p>
<h1 id="next-steps">Next steps</h1>
<p>Armed with the above information, I think I&#39;m ready to dive in and test out WebAssembly with a trivial example. I&#39;ll report my findings in a subsequent update.</p>
]]></description><link>https://log.schemescape.com/posts/webassembly/overview</link><guid isPermaLink="true">https://log.schemescape.com/posts/webassembly/overview</guid><pubDate>Sat, 25 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 2)]]></title><description><![CDATA[<p>In the <a href="../diagrams/">last post</a>, I looked at options for generating diagrams from text descriptions at build time for my static site. Here&#39;s my (failed) attempt at integrating <a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a> into my site.</p>
<h1 id="mermaid-is-browser-based">Mermaid is browser-based</h1>
<p>Mermaid is built on top of <a href="https://d3js.org/">D3.js</a>, which is designed to be used in the browser. It exposes a <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API reminiscent of <a href="https://jquery.com/">jQuery</a>. It directly manipulates a DOM, which means you need a browser.</p>
<p>This is a problem for my scenario where I&#39;m building my site outside of any browser in Node.</p>
<p>Mermaid provides a command line interface where you can pass in the text describing a diagram and get SVG back out, but rather than doing something sensible, it uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> to spin up a headless Chromium browser DOM (enjoy that 200+ MB download!) that D3.js manipulates, and then gets everything back out. I guess this is fine for generating, say, a PNG image file, but for SVG it seems excessively wasteful. You shouldn&#39;t need a DOM or browser just to generate XML!</p>
<h1 id="sanity-check">Sanity check</h1>
<p>Just to make sure I&#39;m not missing something obvious, let&#39;s try building a Mermaid diagram in Node without doing anything special.</p>
<h2 id="module-woes">Module woes...</h2>
<p>The first problem I hit is that Mermaid 8.13.0 with D3.js 7.0.3 won&#39;t load in either a CommonJS or ES Module environment in Node 14.17.0. If, in CommonJS mode, I try to use <code>require(&quot;mermaid&quot;)</code>, Node rightly points out that D3.js is an ES Module. If, in an ES Module, I try to use <code>import &quot;mermaid&quot;;</code>, then Mermaid tries to use <code>require()</code> on D3.js, which obviously doesn&#39;t work. This seems like a bug in Webpack&#39;s &quot;universal module&quot; pattern.</p>
<h2 id="jsdom-to-the-rescue">jsdom to the rescue?</h2>
<p><a href="https://github.com/jsdom/jsdom">jsdom</a> provides a fake DOM implementation for use in Node. Sounds promising!</p>
<p>Unfortunately, Mermaid&#39;s dependencies require some SVG functionality that jsdom doesn&#39;t implement, e.g. <a href="https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox">SVGGraphicsElement.getBBox()</a>. Alright, now it&#39;s making more sense why Mermaid has this dependency on a browser--it&#39;s using the browser&#39;s SVG API to measure text, compute transformations, and so on. I&#39;m still not thrilled with this design, but I can see how one might need to measure text when generating diagrams (althoug embedding a full Chromium engine seems like overkill).</p>
<p>I did a bit of searching to see if anyone has implemented the SVG API for use in Node, but I couldn&#39;t find anything that looked promising. There was a library for the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">Canvas</a> API that can be used in Node, which probably solved many similar problems (related to CSS and measuring fonts), but implementing SVG just so I can generate diagrams without downloading Chrome is beyond the amount of effort I&#39;m willing to put into this endeavor.</p>
<h1 id="taking-a-step-back">Taking a step back</h1>
<p>It&#39;s looking like using Mermaid on the back end is probably going to require either a significant amount of effort or a willingness to settle for using Chromium behind the scenes.</p>
<p>Rather than start investigating the performance characteristics of mermaid-cli, I think I&#39;m going to take a step back and evaluate which of Mermaid, Graphviz, and <a href="https://github.com/microsoft/automatic-graph-layout">MSAGL</a> (which I just found) has syntax I find most comfortable (while still supporting the features I&#39;m interested in). Honestly, this should have been the first step, but I was hoping that one option would be clearly easier to integrate, at which point I&#39;d probably just make do with whatever syntax and features were available.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams-mermaid</guid><pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Generating diagrams when building a static site (part 1)]]></title><description><![CDATA[<h1 id="background">Background</h1>
<p>As described in a <a href="../overview/">previous post</a>, I&#39;d like to have a static site that requires no JavaScript whatsoever to view the site in full fidelity. I&#39;d also like to be able to embed diagrams into my posts, ideally by inserting a textual description of the diagram.</p>
<p>Given how huge the NPM ecosystem is, I thought this would be trivial to setup. I might have been wrong.</p>
<h1 id="diagramming-software">Diagramming software</h1>
<p>In the past, I&#39;ve used <a href="https://graphviz.org/">Graphviz</a> for generating diagrams, with some success. That was almost 15 years ago, so I assumed today there&#39;d be something newer and more Node-friendly that I could easily integrate into my workflow.</p>
<p>After scouring the web for an hour or so, I found a couple of patterns:</p>
<ul>
<li>There were several libraries that aggregate diagramming libraries under a unified API<ul>
<li>But the component libraries were written in a wide variety of languages (Python, C, etc.), so deployment would be a huge hassle (<a href="https://kroki.io/">Kroki</a> even went so far as to recommend <em>against</em> trying to deploy your own instance)</li>
</ul>
</li>
<li>Many of the libraries were written in Java (a language I&#39;d like to avoid, if possible)</li>
<li>Most of the libraries didn&#39;t have a convenient text-based input format</li>
<li>Most of the libraries were designed to run <em>on the client</em></li>
</ul>
<p>I definitely don&#39;t want to have to install multiple programming language environments, and it seems silly to have each client re-render the same diagram on every view. I also don&#39;t want to depend on a service that is currently free, but could potentially disappear overnight.</p>
<p>My research led me to two candidate tools:</p>
<ul>
<li><a href="https://mermaid-js.github.io/mermaid/#/">Mermaid</a>: Markdown-inspired JavaScript-based tool</li>
<li><a href="https://graphviz.org/">Graphviz</a>: Super old (originally created by AT&amp;T!), C-based diagramming tool</li>
</ul>
<p>Neither of these is perfect for my environment. Will they work? Probably, but how inconvenient will it be?</p>
<h2 id="mermaid">Mermaid</h2>
<p>Mermaid is written in JavaScript, so I should just be able to install it via NPM, call an API, and be done, right? Actually, no.</p>
<p>Remember, I want to insert the source code of a diagram directly into my Markdown files, but then have that rendered to SVG at build time. <a href="https://mermaid-js.github.io/mermaid/#/n00b-gettingStarted">Mermaid&#39;s deployment model</a> is to have the client parse the source code from within the page, render an image, and insert it into the DOM.</p>
<p>Ok, so I can just run that same code in Node at build time, right? Then I can skip all the client-side JavaScript? Not according to <a href="https://github.com/mermaid-js/mermaid/issues/146">an issue in Mermaid&#39;s issue tracker</a>!</p>
<p>From reading that thread, it sounds like Mermaid interacts directly with the web page&#39;s DOM when rendering. Someone created a command line tool (<a href="https://github.com/mermaidjs/mermaid.cli">mermaid.cli</a>) that apparently uses <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a>&#39;s headless Chromium environment to supply a functioning DOM. Apparently, this is the normal workaround for using D3.js-based graphics on the back end. I find this implementation slightly appalling.</p>
<p>I&#39;m a little bit worried about the performance of building my site when each diagram has to spin up a new process which hosts a headless Chromium browser, just to spit out SVG. I suspect it will <em>work</em>, but it seems wasteful.</p>
<p>Let&#39;s see if I can find a better option.</p>
<h2 id="graphviz">Graphviz</h2>
<p>Graphviz is old and originated at AT&amp;T, so of course it is written in C. I love C, but compiling anything with dependencies beyond the standard library is a chore. Part of what attracted me to the Node ecosystem was that most everything is written in JavaScript and, since JavaScript compilers are so fast these days, performance is surprisingly adequate most of the time.</p>
<p>Anyway, so my first thought for integration is to just make sure Graphviz is installed and then spin up a process to render diagrams. I don&#39;t want to have to start a new process each time, but it&#39;s native code, so it&#39;s probably fast enough for my needs. Taking a dependency on a binary is highly unusual in Node land, however, so I&#39;d like to find some way to avoid doing that.</p>
<p>But wait, someone already solved this problem! <a href="https://github.com/JosephusPaye/node-graphviz">node-graphviz</a> is a theoretically Node-compatible version of Graphviz. According to the package, they compiled Graphviz to a <a href="https://webassembly.org/">Web Assembly</a> module, which can be hosted and run within Node.js. No C compiler needed (for users of the library, that is)!</p>
<p>Embedding Graphviz directly seems like a very promising solution, but I haven&#39;t vetted the library to ensure it works as advertised. The code certainly is not what I was expecting to see (it&#39;s enormous!), so I&#39;m a bit skeptical.</p>
<h1 id="mermaidcli-or-node-graphviz">mermaid.cli or node-graphviz?</h1>
<p>Unfortunately, neither of the two most promising solutions appears obviously better than the other.</p>
<p>Mermaid seems nice because it appears to be broadly used and, by virtue of being newer and web-focused, likely has better support for integrating into web pages (and supporting dark mode, etc.). But I&#39;m having a difficult time getting over the idea of it requiring direct access to a DOM. That just doesn&#39;t seem like a good fit for my &quot;local build&quot; scenario. I&#39;m afraid that, even if I use the command line tool or cook up some way to avoiding handing Mermaid a DOM, it will be fragile.</p>
<p>Graphviz doesn&#39;t seem to support as many diagram types, and I&#39;m a little bit worried to take on a Web Assembly dependency, but on the other hand I&#39;ve been meaning to learn more about Web Assembly anyway. This project might be a good way to learn what goes into integrating a Web Assembly module into Node.</p>
<h1 id="next-steps">Next steps</h1>
<p>Hopefully I don&#39;t regret this decision, but I think I&#39;m going to first try integrating Mermaid. If I hit any snags or if performance is abysmal, I&#39;ll see if node-graphviz is actually what I&#39;m looking for.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/diagrams</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/diagrams</guid><pubDate>Thu, 23 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Finding the cheapest hosting for my hobby projects]]></title><description><![CDATA[<p>I like playing around with software, so I frequently have hobby projects in development or &quot;production&quot; (scare quotes because they&#39;re hobbies after all). Since I don&#39;t like wasting money, I&#39;m always on the lookout for cheap project hosting.</p>
<p>Here&#39;s how I went from cheap hosting to free hosting.</p>
<h1 id="background">Background</h1>
<p>Just for fun, I made a couple of computer games (best played on a desktop/laptop):</p>
<ul>
<li><a href="https://jaredkrinke.itch.io/sic-1">SIC-1</a>: A single-instruction (<a href="https://esolangs.org/wiki/Subleq">subleq</a>) programming game, with a global leader board</li>
<li><a href="https://jaredkrinke.itch.io/fbgp8">Falling Block Game</a>: Block-stacking game for <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a> with a global high scores list</li>
</ul>
<p>Both of these require services with a small amount of storage. Since there are no ads or monetization, I&#39;d like to run the services as cheaply as possible.</p>
<h1 id="first-attempt-120month">First attempt: $1.20/month</h1>
<p>I inherited a first generation <a href="https://www.raspberrypi.org/">Raspberry Pi</a> and already had a $10/year domain, so why not just host my site locally?</p>
<p>Because I was curious about Node, I decided to use the following very simple tech stack:</p>
<ul>
<li>Software<ul>
<li><a href="https://nodejs.org/en/">Node</a> JavaScript environment</li>
<li><a href="http://expressjs.com/">Express</a> web server framework</li>
<li><a href="https://sqlite.org/index.html">SQLite</a> (via <a href="https://www.npmjs.com/package/sqlite3">sqlite3</a>) in-process, single file-based database</li>
<li><a href="https://github.com/zapty/forever-service">forever-service</a> service monitoring</li>
<li><a href="https://letsencrypt.org/">Let&#39;s Encrypt</a> certificate service</li>
</ul>
</li>
<li>Hardware/connectivity<ul>
<li>Raspberry Pi (first generation), running <a href="https://www.raspbian.org/">Raspbian</a></li>
<li>My home Internet connection and router, with appropriate holes in the firewall</li>
<li>$10/year .com domain name</li>
</ul>
</li>
</ul>
<p>There was very little traffic, so the Raspberry Pi could service requests fine and my (cheapest tier) cable Internet was sufficient.</p>
<h2 id="cost">Cost</h2>
<p>The Raspberry Pi drew roughly 3 watts, so the electricity plus domain meant I was hosting a service for roughly $1.20 per month. Very affordable! Additionally, as long as I didn&#39;t have a lot of traffic, I could run multiple services without increasing the cost.</p>
<h2 id="concerns">Concerns</h2>
<p>I was a bit wary of poking a hole in my firewall and, within a few days, I decided that my concern was justified.</p>
<p>The log for my web server was almost immediately flooded by TCP scanning requests from <a href="https://github.com/robertdavidgraham/masscan">masscan</a>. I also saw 404 errors to common vulnerable paths (namely phpMyAdmin- and WordPress-related paths).</p>
<p>I know there are a lot of people who enjoy having their own &quot;<a href="https://haydenjames.io/home-lab-beginners-guide-hardware/">home lab</a>&quot;, and I&#39;m sure many of these people keep up on the latest security recommendations, but I was more interested in hosting a service than attracting unwanted attention to my home network&#39;s external IP address.</p>
<p>I would strongly advise against hosting any site this way, especially since it turns out to not even be the cheapest option!</p>
<h1 id="second-attempt-433month">Second attempt: $4.33/month</h1>
<p>Wait, my hosting cost went up!? Yes, and it was money well spent.</p>
<p>After getting slightly alarmed at all of the nefarious traffic flowing through my router, I was happy to pay for a virtual private server. This way it&#39;s at least not my own personal network that&#39;s at risk when something goes wrong.</p>
<p>I selected <a href="https://www.vultr.com/">Vultr</a> as the host because they <a href="https://www.vultr.com/products/cloud-compute/#pricing">offered a decent server for $2.50/month</a>... except that server is <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> only, and it turns out that much of the Internet is stuck in the address-constrained dark age of IPv4. So I had to pay a $1/month premium for an IPv4 address.</p>
<p>The tech stack was the same except for the host. Both the VPS&#39;s Internet connection and CPU were light years beyond what I had with my Raspberry Pi on &quot;cheap&quot; cable Internet.</p>
<h2 id="cost-1">Cost</h2>
<p>Adding in the domain name, my total cost was $4.33/month. A little more than I&#39;d like to spend on silly hobby projects, but this setup came with the peace of mind of not broadcasting my home IP address everywhere. Again, I could add more services to my server at no additional cost to me.</p>
<h2 id="concerns-1">Concerns</h2>
<p>Other than costing me roughly $50/year, this setup worked great. But it wasn&#39;t as robust as I&#39;d like:</p>
<ul>
<li>The database was a single file sitting on the server&#39;s drive, with no backup, so I could theoretically lose it due to hardware failure</li>
<li>Configuring the server was a manual process, so if there was a crash, I&#39;d have to spend time setting a new server up</li>
</ul>
<p>At the time, I wasn&#39;t aware, but there are solutions to both of these problems:</p>
<ul>
<li>Use <a href="https://litestream.io/">Litestream</a> to continuously backup the SQLite database to cloud storage</li>
<li>Use <a href="https://www.docker.com/">Docker</a> to package everything up, enabling rapid recreation of the server</li>
</ul>
<p>There are actually many other solutions, but these are two simple approaches I plan on testing out in the future.</p>
<h1 id="third-attempt-free">Third attempt: FREE!</h1>
<p>While chatting with a friend who does web development for a living, he told me that I could probably host my site for free. That magic phrase led to several follow-up questions from me, and a lot more information from him.</p>
<p>It turns out that many cloud providers have free tiers to try and hook you into their ecosystems, in hopes that you&#39;ll eventually become a paying customer. I&#39;m pretty sure all the major cloud providers have free tiers, and some of them are quite generous. My uninformed opinion is that it seems like the less popular the platform, the more generous the free tier.</p>
<p>The annoying part of all of this is that the best free offers vary substantially, so you&#39;ll likely end up having to use multiple different providers. In my case, the tech stack looks like this:</p>
<ul>
<li>Node JavaScript environment</li>
<li><a href="https://koajs.com/">Koa</a> web framework</li>
<li><a href="https://cloud.google.com/firestore/">Firestore</a> document database</li>
<li><a href="https://www.netlify.com/products/functions/">Netlify Functions</a> &quot;<a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless</a>&quot; end point<ul>
<li>Hosted on the (free) &quot;netlify.app&quot; domain</li>
</ul>
</li>
</ul>
<p>Since everything is in the cloud, I&#39;m also less concerned about hardware failure. I haven&#39;t thoroughly investigated whether I should backup my Firestore data or if their architecture seems robust enough for my needs.</p>
<h2 id="cost-2">Cost</h2>
<p>Zero cost, since I didn&#39;t need to use a custom domain. I didn&#39;t even have to provide a credit card.</p>
<h2 id="concerns-2">Concerns</h2>
<p>This setup is free, which is great, but when I last checked, both of the free offerings I&#39;m using were actually fairly expensive if you end up with enough traffic to need to start paying. You&#39;re also locked into their systems unless you want to start rewriting code.</p>
<p>I also found that Firestore wasn&#39;t a great fit for my needs, since it&#39;s a &quot;<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>&quot; document database that basically requires me to build and maintain my own aggregations. But I&#39;m not paying anything, so I shouldn&#39;t complain.</p>
<h1 id="what-about-the-future">What about the future?</h1>
<p>I succeeded in finding free hosting for my hobby projects. Great! But I&#39;m not perfectly happy being locked into specific vendors and libraries.</p>
<p>Cloud services are great, but I&#39;d really like something more portable, in case I ever create a project that ends up getting a significant amount of traffic. There may be better approaches, but I think I&#39;d like to use containers hosted on a VPS (with backup to commodity cloud storage), just for portability reasons.</p>
<p>I have heard that Oracle&#39;s cloud has a <a href="https://www.oracle.com/cloud/free/#always-free">free tier that even includes your own virtual private servers</a>, so I may look into that eventually. Planning to use Oracle is something I never thought I&#39;d be doing as a hobbyist, but these are interesting times.</p>
<p>The future might look like this:</p>
<ul>
<li>Node environment</li>
<li>Koa web framework</li>
<li>SQLite database<ul>
<li>Backed up to commodity store (e.g. <a href="https://www.backblaze.com/">Backblaze</a>) via Litestream</li>
</ul>
</li>
<li>Forever-service monitoring</li>
<li>Let&#39;s encrypt certificate</li>
<li>All in a Docker container</li>
<li>Hosed on Oracle&#39;s free compute VM</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/services/cheap-hosting</link><guid isPermaLink="true">https://log.schemescape.com/posts/services/cheap-hosting</guid><pubDate>Wed, 22 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Embedding images directly into Markdown posts -- terrible idea?]]></title><description><![CDATA[<p>This might turn out to be a terrible idea, but in pursuit of self-contained Markdown-based blog posts, I&#39;m going to try embedding images (and, maybe later, other assets) directly into my Markdown posts.</p>
<h1 id="background">Background</h1>
<p>Most blogging platforms I&#39;ve looked at support inserting images into posts as follows:</p>
<ul>
<li>Images are uploaded to a specific location</li>
<li>Output HTML files reference the images (ideally using relative links)</li>
</ul>
<p>This is great if an image needs to be shared between posts, but that&#39;s not the typical use case. In the usual case, I see images used once in a single post.</p>
<p>As a <em>viewer</em> I like this setup because the images can be loaded lazily, I can open the image link in a new tab, etc.</p>
<h1 id="gripes">Gripes</h1>
<p>As an author, however, I have some complaints about this setup because posts and images become coupled:</p>
<ul>
<li>I have to add multiple files to build a particular post</li>
<li>If I want to remove a post, I have to also remove the images it contains</li>
<li>Probably not common, but if I want to duplicate a post elsewhere, I have to grab the images as well</li>
</ul>
<h1 id="my-previous-solution">My previous solution</h1>
<p>In the past, my solution to this problem was to build a directory for each post and the directory contained both the post content as well as any associated images and files.</p>
<p>This is, in my opinion, a pretty reasonable solution because now the entire post is contained in a single location. If my crazy new idea doesn&#39;t work, I&#39;ll probably revert to this tried and true solution.</p>
<h1 id="directly-embedding-images">Directly embedding images</h1>
<p>So here&#39;s my crazy idea: what if I embed images directly into their source Markdown files using <a href="https://en.wikipedia.org/wiki/Base64">Base64-encoded</a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URLs</a>?</p>
<p>Data URLs are only recommended for small files (ideally &lt; 1 KB), but my research indicates that this recommendation is based on:</p>
<ol>
<li>Separating essential HTML/text content from slightly less important image content</li>
<li>Some HTML/XML implementations arbitrarily limiting the size of an element and its attributes</li>
</ol>
<p>I happen to agree with #1, so when compiling my site I do plan to split out images into their own files. But #2 feels like a vestigial limitation from the days of allocating fixed size buffers on the stack in C code. That&#39;s not to say #2 won&#39;t cause me trouble--I just don&#39;t think it&#39;s a good enough reason on its own to discard my idea.</p>
<h2 id="prototype-encoder">Prototype encoder</h2>
<p>Here&#39;s the code for my prototype encoder (side note: I don&#39;t know why Node refused to accept the clearly documented &quot;base64url&quot; encoding):</p>
<pre><code>const path = require(&quot;path&quot;);
const fs = require(&quot;fs/promises&quot;);

// TODO: Use a more comprehensive library
const fileExtensionToMimeType = {
    &quot;.jpg&quot;: &quot;image/jpeg&quot;,
    &quot;.png&quot;: &quot;image/png&quot;,
};

(async () =&gt; {
    try
    {
        const filePath = process.argv[2];
        if (!filePath) throw &quot;No path specified!&quot;;

        const fileExtension = path.extname(filePath);
        const mimeType = fileExtensionToMimeType[fileExtension];
        if (!mimeType) throw `Could not determine MIME type for extension &quot;${fileExtension}&quot;!`;

        const buffer = await fs.readFile(filePath);
        const base64UrlEncoded = encodeURI(buffer.toString(&quot;base64&quot;));

        const dataUrl = `data:${mimeType};base64,${base64UrlEncoded}`;
        console.log(dataUrl);
    }
    catch (err) {
        console.error(`ERROR: ${err}`);
    }
})();</code></pre><h2 id="exhibit-a">Exhibit A</h2>
<p>Here&#39;s a very small (in terms of number of bytes) PNG file that&#39;s been directly embedded (this is the ~600 byte <a href="https://en.wikipedia.org/wiki/Favicon">Favicon</a> for my site):</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC" alt="Small embedded PNG file"></p>
<p>Here&#39;s what the Markdown input looks like, for reference:</p>
<pre><code>![Small embedded PNG file](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC)</code></pre><p>I also tested a much larger image file and it worked just as well, but I decided to omit that file from this post because I didn&#39;t want to bloat up this file (and repository) for no good reason.</p>
<h2 id="observations-in-vs-code">Observations in VS Code</h2>
<p>Well, the images render fine in Visual Studio Code&#39;s Markdown Preview window. Syntax highlighting in the Markdown file I&#39;m editing is ok, too. But there is one problem.</p>
<p>I&#39;ve been happily using word-wrapping when editing Markdown files and, unsurprisingly, these enormous strings make word-wrapping pretty much impossible to use. This could end up being fairly annoying. I&#39;ll let this issue marinate in the back of my mind for a bit.</p>
<h2 id="observations-in-githubs-markdown-viewer">Observations in GitHub&#39;s Markdown viewer</h2>
<p>To my surprise, the image did not display at all in GitHub&#39;s Markdown viewer--it just showed a &quot;broken image link&quot; icon. That&#39;s unfortunate because I&#39;d like my site to be as functional as possible when viewed directly on GitHub.</p>
<h2 id="observations-compiling-with-marked">Observations compiling with Marked</h2>
<p>The Markdown appears to have compiled fine using <a href="https://marked.js.org/">Marked</a> (via <a href="https://metalsmith.io/">Metalsmith</a>). It wasn&#39;t noticeably slow or anything either. Great!</p>
<h2 id="observations-viewing-the-resulting-html-in-chromium-based-edge">Observations viewing the resulting HTML in Chromium-based Edge</h2>
<p>Note: as I noted earlier, I&#39;m not normally planning on uploading my static site in this format, but out of sheer curiosity, would this work unmodified?</p>
<p>The images display just fine in my site on Chromium-based Edge. Good to know!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, while I like the idea of having completely self-contained Markdown files, the fact that the images don&#39;t work on GitHub&#39;s Markdown viewer and that the incredibly long text blobs effectively break word-wrapping in VS Code lead me to believe that this was a failed experiment. I don&#39;t think I&#39;ll pursue this method any further.</p>
<p>I&#39;m still happy that I gave it a shot. You never really know until you try!</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/embedded-images</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/embedded-images</guid><pubDate>Tue, 21 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>