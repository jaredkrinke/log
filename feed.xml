<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2023-08-26T20:06:35.924Z</updated>

<entry>
<title>Porting a browser-based game to Steam, on Linux (part 2)</title>
<id>https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux-2.html"/>
<updated>2023-08-26T00:00:00.000Z</updated>
<summary type="text">I finally ported my browser-based Steam game to Linux. It was mostly straight-forward.</summary>
<content type="html">&lt;p&gt;In &lt;a href=&quot;https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux.html&quot;&gt;a previous post&lt;/a&gt; I outlined a plan to (finally) port &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../game-development/sic-1.html&quot;&gt;my browser-based Steam game&lt;/a&gt; to Linux. (The original Windows-only release used WebView2.) The port mostly went according to plan and only took a week or two, working in my spare time.&lt;/p&gt;
&lt;h1 id=&quot;original-plan&quot;&gt;Original plan&lt;/h1&gt;
&lt;p&gt;The simplest way to run a browser-based game using Steam on Linux was to use Electron, but there was one problem: &lt;a href=&quot;https://github.com/greenheartgames/greenworks&quot;&gt;Greenworks&lt;/a&gt; (a Steam integration library) didn&amp;#39;t support friend leaderboards (an important feature of my game). My plan (which optimized for having to learn the fewest new libraries/concepts) was to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Port the Steam release to Electron&lt;/li&gt;
&lt;li&gt;Refactor Steam integration code into a flat C interface&lt;/li&gt;
&lt;li&gt;Consume the Steam integration code using one of Node&amp;#39;s FFI libraries&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Hope&lt;/em&gt; that this new version works acceptably via Proton&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;porting-to-electron&quot;&gt;Porting to Electron&lt;/h1&gt;
&lt;p&gt;Porting to Electron was fairly straightforward. I was able to use Electron&amp;#39;s tutorials to get a mostly working game pretty quickly. There were a few issues I had to iron out:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Electron Forge doesn&amp;#39;t have an easy way to add binaries (e.g. the Steamworks binary) to the root of the output folder, so I had to &lt;a href=&quot;https://github.com/jaredkrinke/sic1/commit/c953e7adb63a43022102dbf434123c400ac507a2#diff-4c2d32d0a0906dd3108b9ce9d29178bc2e8e3eae8d82f0b735a73e1f2b23ee5e&quot;&gt;hack in an &lt;code&gt;afterExtract&lt;/code&gt; callback to copy the files&lt;/a&gt; and switch from using &lt;code&gt;electron-forge start&lt;/code&gt; (which &lt;em&gt;doesn&amp;#39;t&lt;/em&gt; run &lt;code&gt;afterExtract&lt;/code&gt;) to &lt;code&gt;electron-forge package&lt;/code&gt; (which does) for testing&lt;/li&gt;
&lt;li&gt;Electron allows &amp;quot;Ctrl+R&amp;quot; to reload the page by default (fix: &lt;a href=&quot;https://github.com/jaredkrinke/sic1/commit/0459f8c1bd7efd55095936fd1d5350bd27b6eab8&quot;&gt;remove the menu&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, &lt;a href=&quot;https://github.com/jaredkrinke/sic1/commit/ef4d99f517f227ba7755bb67cb7abf962d18be0b&quot;&gt;adding crash reporting&lt;/a&gt; was trivially easy.&lt;/p&gt;
&lt;h1 id=&quot;refactoring-steam-integration-for-electron-andor-linux&quot;&gt;Refactoring Steam integration for Electron and/or Linux&lt;/h1&gt;
&lt;p&gt;My original Steam integration code used the Win32 API, so I had to rewrite it using only the C++11 standard library. I then exposed that code in a flat, synchronous C interface (which I dubbed &lt;a href=&quot;https://github.com/jaredkrinke/ez-steam-api&quot;&gt;ez-steam-api&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;To support calling the C API from Electron, I used &lt;a href=&quot;https://koffi.dev/&quot;&gt;Koffi&lt;/a&gt; (which was great, other than one bug I hit--which has since been fixed). The wrapper is documented &lt;a href=&quot;https://github.com/jaredkrinke/ez-steam-api/tree/main/js&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;hoping-that-electron-runs-on-proton&quot;&gt;&lt;em&gt;Hoping&lt;/em&gt; that Electron runs on Proton&lt;/h1&gt;
&lt;p&gt;In the previous post, I acknowledged that &lt;em&gt;hoping&lt;/em&gt; Electron ran acceptably on Proton was a risk. It turns out this risk was well founded.&lt;/p&gt;
&lt;p&gt;In addition to &lt;a href=&quot;https://github.com/jaredkrinke/sic1/issues/270#issuecomment-1636918488&quot;&gt;wasting a lot of time testing out different Electron and Proton combinations&lt;/a&gt;, I ran into one insurmountable bug that was only &lt;em&gt;just annoying enough&lt;/em&gt; to make me give up: the mouse cursor is off by about 25 pixels on Ubuntu, when windowed (no idea why or how to investigate it, although I wonder if it&amp;#39;s related to the system bar at the top of the screen). In fullscreen, Electron-on-Proton worked great! But having windowed mode be broken was unacceptable for my programming game (for other genres, this bug might be acceptable).&lt;/p&gt;
&lt;p&gt;So I ended up having to do a native Linux port anyway.&lt;/p&gt;
&lt;h1 id=&quot;native-linux-port-on-steam&quot;&gt;Native Linux port on Steam&lt;/h1&gt;
&lt;p&gt;Building an Electron app for Linux is trivial. Getting it to run on Steam was a bit frustrating, however, because the game would fail to launch. But &lt;em&gt;only&lt;/em&gt; when run from Steam! Even &lt;a href=&quot;https://gitlab.steamos.cloud/steamrt/scout/sdk/-/blob/steamrt/scout/README.md#testing-software-that-runs-in-scout&quot;&gt;Steam&amp;#39;s test script&lt;/a&gt; launched the game fine.&lt;/p&gt;
&lt;p&gt;I don&amp;#39;t recall how I discovered the solution, but the issue was related to Electron&amp;#39;s sandboxing. Given my game only loads its own code (and not anything from the web), the workaround was just to &lt;a href=&quot;https://steamcommunity.com/groups/steamworks/discussions/13/3801651941320989565/#c3801651941326097085&quot;&gt;add &lt;code&gt;--no-sandbox&lt;/code&gt; to the list of command line arguments&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And just like that, I had a working Linux port!&lt;/p&gt;
&lt;h1 id=&quot;summary-and-statistics&quot;&gt;Summary and statistics&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ve said it before, but I&amp;#39;ll say it again: I should have just used Electron from the beginning. It&amp;#39;s inefficient, but it&amp;#39;s known to work fine on Steam, across platforms (cf. Vampire Survivors). If I had just used Electron originally, porting to Linux would have been trivial. Fortunately, porting to Electron and then Linux wasn&amp;#39;t too onerous.&lt;/p&gt;
&lt;p&gt;This Linux port also resolved &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html#should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;one of my open questions&lt;/a&gt; around what to do with SIC-1. And, of course, now people on a free OS can play my game, &lt;em&gt;with friend leaderboards&lt;/em&gt;. I think the peak number of concurrent Linux players was roughly 3, which is pretty high for a game that only ever peaked at 10 concurrent players on Windows.&lt;/p&gt;
&lt;h1 id=&quot;up-next&quot;&gt;Up next...&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s all for the Linux port! Next, I&amp;#39;m planning to provide an update on how SIC-1&amp;#39;s release has been going. Spoiler: it finally met my own internal bar for success!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Porting a browser-based game to Steam... on Linux</title>
<id>https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/web-game-on-steam-for-linux.html"/>
<updated>2023-07-10T00:00:00.000Z</updated>
<summary type="text">I ported a web game to Steam, but it only works on Windows. Can I get it to run on Linux?</summary>
<content type="html">&lt;p&gt;Last year, I &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html&quot;&gt;ported my single-instruction programming game to Steam&lt;/a&gt;, but I &lt;a href=&quot;https://log.schemescape.com/posts/game-development/sic-1-retrospective.html#should-i-port-the-steam-version-of-the-game-to-linux&quot;&gt;felt bad that it didn&amp;#39;t run on Linux&lt;/a&gt; (because I chose to use Windows-only &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/webview2/&quot;&gt;WebView2&lt;/a&gt; to avoid using Electron). I&amp;#39;d like to rectify this situation, but it&amp;#39;s testing my patience.&lt;/p&gt;
&lt;h1 id=&quot;original-plan&quot;&gt;Original plan&lt;/h1&gt;
&lt;p&gt;From the beginning, I wanted to avoid using Electron because it&amp;#39;s inherently inefficient (it basically ships an entire Node+Chromium browser runtime alongside the app)... but for games it&amp;#39;s probably fine. No one is going to notice or care that a game on Steam is 100 MB instead of 10 MB.&lt;/p&gt;
&lt;p&gt;So my original plan was to port my game to Electron, add &lt;a href=&quot;https://github.com/greenheartgames/greenworks&quot;&gt;Greenworks&lt;/a&gt; (a Steam integration library), and release a native Linux version on Steam.&lt;/p&gt;
&lt;h1 id=&quot;but&quot;&gt;But...&lt;/h1&gt;
&lt;p&gt;Unfortunately, it turns out that Greenworks is no longer maintained and (more importantly) it doesn&amp;#39;t support friend leaderboards. Given that friend leaderboards are arguably the most enticing integration point with Steam for a zachlike, this is a big problem.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not opposed to learning new technologies for educational purposes, but learning about &lt;a href=&quot;https://nodejs.org/api/addons.html&quot;&gt;Node native addons&lt;/a&gt; (which version of the API? I have no idea) and &lt;a href=&quot;https://www.electronjs.org/docs/latest/tutorial/using-native-node-modules&quot;&gt;rebuilding them for Electron&amp;#39;s incompatible ABI&lt;/a&gt; does not sound &lt;em&gt;at all&lt;/em&gt; enjoyable to me at the moment. If I have to patch Greenworks, I&amp;#39;ll do it, but I&amp;#39;d prefer a solution that is better aligned with my current interests.&lt;/p&gt;
&lt;h1 id=&quot;options&quot;&gt;Options&lt;/h1&gt;
&lt;p&gt;Speaking of solutions, what other options do I have to bring SIC-1 to Linux on Steam? The game is implemented in TypeScript, using HTML+CSS for the UI, all bundled using Parcel.&lt;/p&gt;
&lt;p&gt;A few potential approaches and some commentary follow.&lt;/p&gt;
&lt;h2 id=&quot;electron&quot;&gt;Electron&lt;/h2&gt;
&lt;p&gt;Electron is nice because it works consistently across operating systems (and Linux distributions). Some initial testing also indicates that Electron-based games on Windows can run on Linux via Proton.&lt;/p&gt;
&lt;p&gt;The biggest downside to Electron (other than its immense size) is that it&amp;#39;s completely unnecessary (all Steam-supported operating systems already contain a native browser). I also suspect that as Electron adds more script isolation features it will become even more unwieldy for simple web games.&lt;/p&gt;
&lt;p&gt;As far as interfacing with Steam&amp;#39;s API, there are a few options:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Extend Greenworks to support friend leaderboards (pros: probably the least new code; cons: requires learning about a new platform I don&amp;#39;t have any interest in, Node native addons)&lt;/li&gt;
&lt;li&gt;Create a shared library that exposes necessary Steam API functionality as simple C functions and then use one of Node&amp;#39;s foreign function interfaces to call those functions from the Windows build, using Proton on Linux (pros: might be able to reuse existing C++ code from the WebView2 version; cons: translating WebView2&amp;#39;s Windows Runtime/VARIANT structure-based API into plain C functions could get tricky)&lt;/li&gt;
&lt;li&gt;Implement the existing Steam integration code on Linux, ideally using a unifying cross-platform synchronization library (pros: native Linux binaries; cons: requires rewriting the entire Steam integration library)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;native-webview&quot;&gt;Native WebView&lt;/h2&gt;
&lt;p&gt;I could shrink the disk and memory footprint by using native WebViews, of course (via &lt;a href=&quot;https://tauri.app/&quot;&gt;Tauri&lt;/a&gt;, &lt;a href=&quot;https://neutralino.js.org/&quot;&gt;Neutralino.js&lt;/a&gt;, or &lt;a href=&quot;https://github.com/webview/webview&quot;&gt;webview&lt;/a&gt;). Steam integration would likely require a full rewrite, however.&lt;/p&gt;
&lt;p&gt;This feels like The Right Thing To Do because it removes Electron-related bloat, but then I&amp;#39;m just trading efficiency for limited functionality and a compatibility can of worms. Notably, Steam&amp;#39;s Linux Runtime doesn&amp;#39;t include a native WebView library, so I&amp;#39;d have to package one with the game, which defeats the entire purpose of using a native library.&lt;/p&gt;
&lt;p&gt;In the long term, I like this approach because it would enable efficiently shipping the game in downloadable form on other operating systems (outside of Steam).&lt;/p&gt;
&lt;p&gt;Overall, this approach aligns with my interests better, but it isn&amp;#39;t a great fit for my immediate goal of supporting Steam on Linux.&lt;/p&gt;
&lt;h2 id=&quot;new-ui-framework&quot;&gt;New UI framework&lt;/h2&gt;
&lt;p&gt;Originally, I created SIC-1 to run in the browser because it&amp;#39;s convenient and doesn&amp;#39;t require downloading anything. Since it&amp;#39;s web-native, it also starts up pretty much instantly. However, as I fleshed out the game (adding music, save data, etc.), the browser became more of a hassle than a convenience (Local Storage is unreliable, looping music basically doesn&amp;#39;t work correctly on most browsers, styling native UI elements is tricky). I absolutely want to support playing in the browser, but playing outside the browser might produce a more reliable experience.&lt;/p&gt;
&lt;p&gt;Here are a few approaches I&amp;#39;m considering:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Refactor into &lt;a href=&quot;https://reactnative.dev/&quot;&gt;React Native&lt;/a&gt; (shared across desktop and web versions)&lt;/li&gt;
&lt;li&gt;Rewrite for a real game engine that supports web export (e.g. &lt;a href=&quot;https://godotengine.org/&quot;&gt;Godot 3&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Rewrite as a terminal game, just because it sounds fun&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All of these would solve portability and Steam-related issues, but they&amp;#39;re also all a lot of work. Maybe I&amp;#39;ll tackle them &lt;em&gt;someday&lt;/em&gt;, but I don&amp;#39;t think I want to rewrite my game &lt;em&gt;today&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id=&quot;current-plan&quot;&gt;Current plan&lt;/h1&gt;
&lt;p&gt;Unfortunately, there&amp;#39;s no clear winner amongst all these options. The shortest path to Linux support on Steam probably involves Electron and either extending Greenworks or repackaging my existing Steam integration code.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m still trying to decide how important it is to me to leave the door open to non-Steam downloadable releases (on various platforms). I&amp;#39;ve always had a dream of getting a piece of software incorporated into a popular Linux distribution, and I assume using Electron would make that very unlikely (because bloat).&lt;/p&gt;
&lt;p&gt;For now, I will likely pursue the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Port the Steam release to Electron&lt;/li&gt;
&lt;li&gt;Refactor Steam integration code into a flat C interface&lt;/li&gt;
&lt;li&gt;Consume the Steam integration code using one of Node&amp;#39;s FFI libraries&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Hope&lt;/em&gt; that this new version works acceptably via Proton&lt;/li&gt;
&lt;li&gt;Consider porting (again) to a native WebView library, for use in downloadable releases on Windows, Linux, and maybe even elsewhere&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That&amp;#39;s more work than I had anticipated and the next to last step (&amp;quot;hoping&amp;quot; Proton supports it) is questionable, but I think it&amp;#39;s the simplest option that is best aligned with my interests.&lt;/p&gt;
&lt;p&gt;Hopefully I don&amp;#39;t regret this decision!&lt;/p&gt;
</content>
</entry>
<entry>
<title>Retrospective: Lisp Game Jam (Spring 2023)</title>
<id>https://log.schemescape.com/posts/game-development/lisp-game-jam-2.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/lisp-game-jam-2.html"/>
<updated>2023-06-13T00:00:00.000Z</updated>
<summary type="text">I managed to implement a multiplayer browser-based game in Common Lisp!</summary>
<content type="html">&lt;p&gt;This is a follow-up to &lt;a href=&quot;https://log.schemescape.com/posts/game-development/lisp-game-jam.html&quot;&gt;my previous post about discovering Lisp Game Jame (Spring 2023)&lt;/a&gt;. In the previous post, I described my word game and implementation approach. This post covers how it all went, along with some lessons learned and general thoughts about Common Lisp.&lt;/p&gt;
&lt;p&gt;You can play the game here (but note that it&amp;#39;s designed for multiplayer):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaredkrinke.itch.io/13l/&quot;&gt;https://jaredkrinke.itch.io/13l/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source code is &lt;a href=&quot;https://github.com/jaredkrinke/thirteen-letters/&quot;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;recap&quot;&gt;Recap&lt;/h1&gt;
&lt;p&gt;I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Common Lisp&lt;/a&gt; and &lt;a href=&quot;https://itch.io/jam/spring-lisp-game-jam-2023&quot;&gt;Lisp Game Jam (Spring 2023)&lt;/a&gt; was an appropriate motivator. I wanted to make a simple word scramble game that was played in real time against other players, inside the browser.&lt;/p&gt;
&lt;h1 id=&quot;the-challenge&quot;&gt;The challenge&lt;/h1&gt;
&lt;p&gt;I set a challenge for myself to write &lt;em&gt;the entire game&lt;/em&gt; in Common Lisp. Specifically, I was going to use various domain-specific/template languages to produce HTML, CSS, and JavaScript for use in the browser. (Running Common Lisp on the back end was, and is, trivial.)&lt;/p&gt;
&lt;p&gt;After some searching, I settled on the following tools/libraries:&lt;/p&gt;
&lt;h2 id=&quot;front-end&quot;&gt;Front end&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://parenscript.common-lisp.dev/&quot;&gt;Parenscript&lt;/a&gt; for translating Common Lisp to JavaScript&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ruricolist/spinneret&quot;&gt;Spinneret&lt;/a&gt; for creating HTML from s-expressions and CL code&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Inaimathi/cl-css&quot;&gt;cl-css&lt;/a&gt; for creating CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;back-end&quot;&gt;Back end&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://edicl.github.io/hunchentoot/&quot;&gt;Hunchentoot&lt;/a&gt; as a base web server&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/joaotavora/hunchensocket&quot;&gt;Hunchensocket&lt;/a&gt; for handling WebSockets on the server side&lt;/li&gt;
&lt;li&gt;&lt;del&gt;&lt;a href=&quot;https://github.com/hankhero/cl-json&quot;&gt;cl-json&lt;/a&gt; for encoding/decoding JSON&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://phmarek.github.io/yason/&quot;&gt;YASON&lt;/a&gt; for encoding/decoding JSON (cl-json doesn&amp;#39;t support non-BMP Unicode)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sbcl.org/&quot;&gt;SBCL&lt;/a&gt; for running the server (sitting behind nginx for TLS support)  and compiling everything&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;day-by-day-progress&quot;&gt;Day-by-day progress&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;May 26: Generated a word list (most frequent words from the YAWL corpus)&lt;/li&gt;
&lt;li&gt;May 27: Implemented command line game loop&lt;/li&gt;
&lt;li&gt;May 28: Investigated binary distribution options (static SBCL/ECL builds, AppImages), eventually giving up&lt;/li&gt;
&lt;li&gt;May 29: Prepared backup submission (the command line version)&lt;/li&gt;
&lt;li&gt;May 30: Investigated libraries for browser-based version (Hunchensocket, Lisp in Parallel, Parenscript, Spinneret, cl-json, cl-css)&lt;/li&gt;
&lt;li&gt;May 31: Partially implemented WebSocket-based server&lt;/li&gt;
&lt;li&gt;June 1: Completed server (mostly)&lt;/li&gt;
&lt;li&gt;June 2: Discovered ngrok free tier couldn&amp;#39;t support public WebSockets, settling on standing up a simple VPS instead&lt;/li&gt;
&lt;li&gt;June 3: Implemented basic HTML+JavaScript front end&lt;/li&gt;
&lt;li&gt;June 4: Added a countdown timer, hall of fame, and mobile formatting&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(After the jam ended: bug fixes, WebSocket reconnecting, input validation, code cleanup.)&lt;/p&gt;
&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;Playing the completed entry myself confirmed my original suspicion that the game is really only fun when there&amp;#39;s someone else to compete against.&lt;/p&gt;
&lt;p&gt;I had hoped that the time-limited nature of the voting period would mean that people would end up connecting at the same time as others, but that ended up being wishful thinking. With 30 submissions, each game probably only got a few minutes of playing time, so there were only a handful of times when players overlapped and actually got to compete (often against me, since I connected very frequently). It &lt;em&gt;did&lt;/em&gt; sound like those players had fun, though!&lt;/p&gt;
&lt;p&gt;Even worse, when someone was streaming their playthroughs of all the submissions, I was sitting and waiting to hop in and give the streamer some competition, but they ended up breezing through my game in the 5 minutes I happened to be away from my computer! Very poor timing on my part...&lt;/p&gt;
&lt;p&gt;Despite the lack of ideal (multiplayer) conditions, my entry had generally positive feedback, with most praise being related to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making a real-time multiplayer game that runs in the browser&lt;/li&gt;
&lt;li&gt;Using Common Lisp everywhere&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I was going to be happy with an overall placement in the middle, but Thirteen Letters actually managed to end up in the top third. Not too bad!&lt;/p&gt;
&lt;h1 id=&quot;lessons-learned&quot;&gt;Lessons learned&lt;/h1&gt;
&lt;h2 id=&quot;multiplayer-games-need-multiple-players&quot;&gt;Multiplayer games need multiple players&lt;/h2&gt;
&lt;p&gt;I knew this intuitively going into the jam. I even had a plan to pop up a notification on my phone whenever someone connected, so that I could hop in and play against them, but I wasn&amp;#39;t able to implement it in time.&lt;/p&gt;
&lt;p&gt;In retrospect, implementing notifications should have been my top priority after getting the game working. Instead, I focused on creating a &amp;quot;hall of fame&amp;quot; so that players could compete asynchronously on the leaderboard, but this wasn&amp;#39;t actually interesting because it was just about play time (how many rounds they sat through by themself) and not skill.&lt;/p&gt;
&lt;p&gt;If I ever make another multipler game jam entry, I&amp;#39;ll focus on ensuring people are able to actually play against an opponent (even if I have to secretly create a bot or just play the game &lt;em&gt;all day long&lt;/em&gt;).&lt;/p&gt;
&lt;h2 id=&quot;repl-driven-developmentdeveloping-in-production&quot;&gt;REPL-driven development/developing in production&lt;/h2&gt;
&lt;p&gt;Given that my entire motivation to learn Common Lisp was to experiment with REPL-driven development, I decided to try and develop and test as much as possible using Emacs SLIME (over a Swank connection).&lt;/p&gt;
&lt;p&gt;Overall, having a direct connection to the server was helpful for monitoring activity, enabling/disabling logging, and making small tweaks (e.g. changing formatting or adding alerts).&lt;/p&gt;
&lt;p&gt;Notably, as the deadline for the jam approached, I decided to take advantage of the client-server architecture and make it possible to &amp;quot;cheat&amp;quot; the deadline a bit: I added a channel for pushing raw HTML from the server to the client. Since the server could be modified at any time, this would theoretically allow for updating part of the game post-deadline. I didn&amp;#39;t end up needing to use this facility, but it &lt;em&gt;did&lt;/em&gt; end up becoming the &amp;quot;hall of fame&amp;quot; section at the bottom of the page. (I also planned to use it as an easter egg while someone was streaming the game, but as noted above, I missed that opportunity.)&lt;/p&gt;
&lt;p&gt;Unfortunately, I also hit a couple of snags with REPL-driven development:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Obviously, you have to &lt;em&gt;plan&lt;/em&gt; if you want to keep your code and your live service in sync&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Sometimes I&amp;#39;d modify a function or add a parameter and then forget to send it to the live service, leading to errors in the production service&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Even worse, one time I connected to the live service via Swank, modified a few things, and then suspended my laptop--this then caused &lt;em&gt;every&lt;/em&gt; HTTP request to hang while Swank was trying to log to my unresponsive laptop--oops!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On the whole, &amp;quot;developing in production&amp;quot; isn&amp;#39;t generally a good idea, but just having the ability to connect and inspect things every now and then was invaluable. This was my first time having deep, read/write access to a running service, and it&amp;#39;s something I&amp;#39;d like to use again in the future--at least for hobby projects! Connecting a REPL to an important/income-generating service would require careful planning.&lt;/p&gt;
&lt;h2 id=&quot;ngrok-for-websockets-or-not&quot;&gt;ngrok for WebSockets (or not)&lt;/h2&gt;
&lt;p&gt;Despite ngrok (a service for exposing local endpoints publicly) officially supporting WebSockets, I&amp;#39;ve come to the conclusion that their &lt;em&gt;free tier&lt;/em&gt; has no such support. The reason for this is that it appears to sniff the browser user agent string and then add an interstitial HTML page to the HTTP Upgrade request. Obviously, the WebSocket client doesn&amp;#39;t understand HTML, and just bails out with an error.&lt;/p&gt;
&lt;p&gt;ngrok is great, but in this case I ended up having to spin up a VPS in short order to get my WebSocket server working properly (an unwelcome surprise during a short game jam!).&lt;/p&gt;
&lt;h2 id=&quot;parenscript&quot;&gt;Parenscript&lt;/h2&gt;
&lt;p&gt;Parenscript seems like a great tool for:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;People who are very familiar with Common Lisp and want to translate idioms/code into JavaScript&lt;/li&gt;
&lt;li&gt;People targeting very old versions of JavaScript (back before &lt;code&gt;let&lt;/code&gt; was added, for instance)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given that I&amp;#39;m new to Common Lisp and have a lot of experience with JavaScript and TypeScript, I wasn&amp;#39;t really the target market for Parenscript. I was able to stumble through it, but the resulting code make it obvious I was thinking in JavaScript and writing in Parenscript.&lt;/p&gt;
&lt;p&gt;The most interesting part of Parenscript for me was the ability to define macros. For instance, I added a macro to wrap code in a try-catch that logged to HTML (so I could find errors even when no JavaScript debugger was available). (Note that &lt;code&gt;@&lt;/code&gt; in function position is used for accessing object properties in Parenscript, e.g. &lt;code&gt;(@ window onerror)&lt;/code&gt; would translate to &lt;code&gt;window.onerror&lt;/code&gt;.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(&lt;span class=&quot;hljs-name&quot;&gt;ps&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:defpsmacro&lt;/span&gt; watch (&lt;span class=&quot;hljs-name&quot;&gt;&amp;amp;body&lt;/span&gt; body)
  `(ps&lt;span class=&quot;hljs-symbol&quot;&gt;:try&lt;/span&gt; (progn ,@body) (:catch (e) (error (+ (@ e message) &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot; (&amp;quot;&lt;/span&gt; (@ e line-number) &lt;span class=&quot;hljs-string&quot;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously, this could be done in plain JavaScript with a regular function that takes an anonymous function for the body, but I might as well use macros while they&amp;#39;re available!&lt;/p&gt;
&lt;h2 id=&quot;generating-html-and-css&quot;&gt;Generating HTML and CSS&lt;/h2&gt;
&lt;p&gt;Being able to use concise s-expressions for generating HTML and CSS felt comfortable (and much more productive than writing HTML in Notepad, as I&amp;#39;d done 20 years prior). But HTML and CSS tooling have come a &lt;em&gt;long&lt;/em&gt; way and these days I pretty much expect context-sensitive auto-complete.&lt;/p&gt;
&lt;p&gt;In the end, I like the look of s-expressions, but I don&amp;#39;t think they actually made me more productive than I&amp;#39;d be in, say VS Code.&lt;/p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h1&gt;
&lt;p&gt;The recurring theme I&amp;#39;m noticing with Common Lisp is that it&amp;#39;s easy to mold into new workflows, and these workflows would have been life-changing 20 years ago (and arguably still are notable for their simplicity), but some of the non-Lisp tooling has caught up to (and sometimes surpassed) Common Lisp in the last 5 - 10 years. Not in all cases or in all aspects, but in most of the ones that are important to me (auto-complete, documentation, static checks, debugging).&lt;/p&gt;
&lt;p&gt;Of course, modern tools come with &amp;quot;modern&amp;quot; system requirements (i.e. unbelievable bloat), so it&amp;#39;s possible that Common Lisp with SLIME is a happy middle ground, with powerful features, and minimal bloat. It doesn&amp;#39;t matter if VS Code can do everything I need with TypeScript if I can&amp;#39;t even get VS Code to run on my laptop!&lt;/p&gt;
&lt;p&gt;Regardless, I&amp;#39;m still having fun learning Common Lisp and have no plans to abandon it, so I guess in that sense this experiment has been a success.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Lisp Game Jam (Spring 2023)</title>
<id>https://log.schemescape.com/posts/game-development/lisp-game-jam.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/game-development/lisp-game-jam.html"/>
<updated>2023-05-26T00:00:00.000Z</updated>
<summary type="text">Might as well try and make a game in Common Lisp, right?</summary>
<content type="html">&lt;p&gt;Recently, I&amp;#39;ve been &lt;a href=&quot;https://log.schemescape.com/posts/game-development/../programming-languages/learning-lisp-in-2023.html&quot;&gt;learning Common Lisp&lt;/a&gt; and so I&amp;#39;ve been keeping an eye out for practice projects. Fortunately, as I&amp;#39;m writing this, the &lt;a href=&quot;https://itch.io/jam/spring-lisp-game-jam-2023&quot;&gt;Lisp Game Jam (Spring 2023)&lt;/a&gt; is just about to start, so I guess I&amp;#39;m doing that now.&lt;/p&gt;
&lt;p&gt;For the time being, I&amp;#39;ll just describe the (tiny) game I have in mind.  I&amp;#39;m not terribly confident that I&amp;#39;ll be able to complete anything within the next ten days, but I&amp;#39;ll give it a try anyway!&lt;/p&gt;
&lt;h1 id=&quot;a-word-game&quot;&gt;A word game&lt;/h1&gt;
&lt;p&gt;The goal of the game is to look at a bunch of letters and then, as quickly as possible, find the longest word that can be constructed by drawing from the given set of letters (without replacement). Ideally, this would be a real-time, global competition, but I doubt I&amp;#39;ll be able to get anywhere close to that within 10 days (of roughly 1 - 2 hours per day, at best, of development time).&lt;/p&gt;
&lt;p&gt;When I originally had this idea, I gave it the intentionally terrible name of &lt;strong&gt;Longle&lt;/strong&gt; (&amp;quot;long&amp;quot; + &amp;quot;Boggle&amp;quot;). Today, I&amp;#39;m thinking I&amp;#39;ll call it &lt;strong&gt;Thirteen Letters&lt;/strong&gt; (actual number subject to change).&lt;/p&gt;
&lt;h1 id=&quot;plan&quot;&gt;Plan&lt;/h1&gt;
&lt;p&gt;Here&amp;#39;s my rough plan for implementing this game:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find or create a word list&lt;/li&gt;
&lt;li&gt;Consider reducing that list (based on observed word frequencies) to a set of difficult, but reasonable, puzzles&lt;/li&gt;
&lt;li&gt;Implement a simple terminal version of the game that just records how long it takes for the player to identify the longest word&lt;/li&gt;
&lt;li&gt;If time permits, create a service to distribute puzzles and record the &lt;em&gt;actual&lt;/em&gt; time taken to get a response&lt;/li&gt;
&lt;li&gt;If time is abundant, create a service to host global competitions with 30 - 60 second rounds and resulting scoreboards&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;progress&quot;&gt;Progress&lt;/h1&gt;
&lt;p&gt;As of right now (May 26th, at least as far as UTC is concerned), I&amp;#39;m struggling with the first item. The best word lists I&amp;#39;ve found so far have been copyrighted works related to Scrabble. Other than obvious legal risks, these lists also have a cap on the length of words. Most of the other word lists I&amp;#39;ve found contain proper nouns, lack inflected nouns/verbs, or contain huge amounts of questionable &amp;quot;words&amp;quot; (for example: &amp;quot;zzzs&amp;quot;).&lt;/p&gt;
&lt;p&gt;For now, I think my best bet is to use the public domain &lt;a href=&quot;https://github.com/elasticdog/yawl&quot;&gt;YAWL&lt;/a&gt; word list, possibly filtered by some arbitrary frequency cutoff based on the Google Trillion Word Corpus via &lt;a href=&quot;http://norvig.com/ngrams/&quot;&gt;Peter Norvig&amp;#39;s web site&lt;/a&gt;. After exploring this a bit, it looks like just ensuring the word is in the top ~300,000 most frequent words may be sufficient to get a set of words that I consider to be legitimate.&lt;/p&gt;
</content>
</entry>
<entry>
<title>Resources for learning Common Lisp</title>
<id>https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/common-lisp-resources.html"/>
<updated>2023-05-15T00:00:00.000Z</updated>
<summary type="text">Here are the resources I&apos;ve personally found most helpful for learning Common Lisp.</summary>
<content type="html">&lt;p&gt;In order to test out fully interactive program development (&lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/learning-lisp-in-2023.html&quot;&gt;as noted previously&lt;/a&gt;), I&amp;#39;ve been learning Common Lisp. I assumed that it would take a while to catch up on nearly four decades of Common Lisp&amp;#39;s progress and... I was not wrong about that. On the plus side, given the long timeline, there &lt;em&gt;are&lt;/em&gt; a lot of resources available. On the flip side, they&amp;#39;re not always up to date.&lt;/p&gt;
&lt;p&gt;Regardless, here are the resources that I&amp;#39;ve found most helpful over the last couple of weeks. My intention is to keep this list up to date as I go.&lt;/p&gt;
&lt;h1 id=&quot;introductory-materials&quot;&gt;Introductory materials&lt;/h1&gt;
&lt;p&gt;In descending order of how much time I&amp;#39;ve spent studying them (i.e. in completely arbitrary order):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gigamonkeys.com/book/&quot;&gt;&lt;strong&gt;Practical Common Lisp&lt;/strong&gt;&lt;/a&gt; by Peter Seibel&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/cover.html&quot;&gt;&lt;strong&gt;Successful Lisp&lt;/strong&gt;&lt;/a&gt; by David B. Lamkins&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leanpub.com/lovinglisp&quot;&gt;&lt;strong&gt;Loving Common Lisp, or the Savvy Programmer&amp;#39;s Secret Weapon&lt;/strong&gt;&lt;/a&gt; by Mark Watson&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;in-depth-materials&quot;&gt;In-depth materials&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Various topics: &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/&quot;&gt;Common Lisp Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debugging: &lt;a href=&quot;https://malisper.me/debugging-lisp-part-1-recompilation/&quot;&gt;Debugging Lisp (series)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Packaging/libraries: &lt;a href=&quot;https://lispmethods.com/libraries.html&quot;&gt;Source Code Organization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The LOOP macro: &lt;a href=&quot;https://www.ai.sri.com/~pkarp/loop.html&quot;&gt;Tutorial for the Common Lisp Loop Macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON libraries: &lt;a href=&quot;https://sabracrolleton.github.io/json-review.html&quot;&gt;Review of CL JSON libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;resource-collections&quot;&gt;Resource collections:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;List of libraries/tools: &lt;a href=&quot;https://awesome-cl.com/&quot;&gt;Awesome Common Lisp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;List of books: &lt;a href=&quot;https://lisp-lang.org/books/&quot;&gt;lisp-lang.org/books&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;general-reference&quot;&gt;General reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://clhs.lisp.se/Front/index.htm&quot;&gt;Common Lisp HyperSpec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;thats-great-but-what-have-you-been-doing&quot;&gt;That&amp;#39;s great, but what have you been &lt;em&gt;doing&lt;/em&gt;?&lt;/h1&gt;
&lt;p&gt;That&amp;#39;s mostly a topic for a future post. Briefly: my first project has been building a service that hosts webhooks which implement &lt;a href=&quot;https://play.battlesnake.com/&quot;&gt;Battlesnake&lt;/a&gt; clients. Surely there&amp;#39;s no more noble endeavour than programming games!&lt;/p&gt;
&lt;p&gt;Battlesnake is a competitive programming game where snakes move around a grid collecting food and trying not to collide with each other or the walls. Each snake is implemented as a webhook which is given 500 milliseconds to respond with the direction it would like to move. It&amp;#39;s a simple concept, but that just leaves lots of room for optimization. As an aside, the global leaderboard is a little bit pointless in that it can&amp;#39;t take into account hardware, so for all I know my little netbook is competing with a rack of servers, but I&amp;#39;m still having fun.&lt;/p&gt;
&lt;p&gt;Hopefully I&amp;#39;ll have more to say about Battlesnake and Common Lisp soon!&lt;/p&gt;
</content>
</entry>
</feed>
