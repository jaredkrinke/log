<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Schemescape]]></title><description><![CDATA[Development log of a life-long coder]]></description><link>https://log.schemescape.com/</link><generator>metalsmith-feed</generator><lastBuildDate>Wed, 22 Sep 2021 23:02:41 GMT</lastBuildDate><atom:link href="https://log.schemescape.com/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Finding the cheapest hosting for my hobby projects]]></title><description><![CDATA[<p>I like playing around with software, so I frequently have hobby projects in development or &quot;production&quot; (scare quotes because they&#39;re hobbies after all). Since I don&#39;t like wasting money, I&#39;m always on the lookout for cheap project hosting.</p>
<p>Here&#39;s how I went from cheap hosting to free hosting.</p>
<h1 id="background">Background</h1>
<p>Just for fun, I made a couple of computer games (best played on a desktop/laptop):</p>
<ul>
<li><a href="https://jaredkrinke.itch.io/sic-1">SIC-1</a>: A single-instruction (<a href="https://esolangs.org/wiki/Subleq">subleq</a>) programming game, with a global leader board</li>
<li><a href="https://jaredkrinke.itch.io/fbgp8">Falling Block Game</a>: Block-stacking game for <a href="https://www.lexaloffle.com/pico-8.php">PICO-8</a> with a global high scores list</li>
</ul>
<p>Both of these require services with a small amount of storage. Since there are no ads or monetization, I&#39;d like to run the services as cheaply as possible.</p>
<h1 id="first-attempt-120month">First attempt: $1.20/month</h1>
<p>I inherited a first generation <a href="https://www.raspberrypi.org/">Raspberry Pi</a> and already had a $10/year domain, so why not just host my site locally?</p>
<p>Because I was curious about Node, I decided to use the following very simple tech stack:</p>
<ul>
<li>Software<ul>
<li><a href="https://nodejs.org/en/">Node</a> JavaScript environment</li>
<li><a href="http://expressjs.com/">Express</a> web server framework</li>
<li><a href="https://sqlite.org/index.html">SQLite</a> (via <a href="https://www.npmjs.com/package/sqlite3">sqlite3</a>) in-process, single file-based database</li>
<li><a href="https://github.com/zapty/forever-service">forever-service</a> service monitoring</li>
<li><a href="https://letsencrypt.org/">Let&#39;s Encrypt</a> certificate service</li>
</ul>
</li>
<li>Hardware/connectivity<ul>
<li>Raspberry Pi (first generation), running <a href="https://www.raspbian.org/">Raspbian</a></li>
<li>My home Internet connection and router, with appropriate holes in the firewall</li>
<li>$10/year .com domain name</li>
</ul>
</li>
</ul>
<p>There was very little traffic, so the Raspberry Pi could service requests fine and my (cheapest tier) cable Internet was sufficient.</p>
<h2 id="cost">Cost</h2>
<p>The Raspberry Pi drew roughly 3 watts, so the electricity plus domain meant I was hosting a service for roughly $1.20 per month. Very affordable! Additionally, as long as I didn&#39;t have a lot of traffic, I could run multiple services without increasing the cost.</p>
<h2 id="concerns">Concerns</h2>
<p>I was a bit wary of poking a hole in my firewall and, within a few days, I decided that my concern was justified.</p>
<p>The log for my web server was almost immediately flooded by TCP scanning requests from <a href="https://github.com/robertdavidgraham/masscan">masscan</a>. I also saw 404 errors to common vulnerable paths (namely phpMyAdmin- and WordPress-related paths).</p>
<p>I know there are a lot of people who enjoy having their own &quot;<a href="https://haydenjames.io/home-lab-beginners-guide-hardware/">home lab</a>&quot;, and I&#39;m sure many of these people keep up on the latest security recommendations, but I was more interested in hosting a service than attracting unwanted attention to my home network&#39;s external IP address.</p>
<p>I would strongly advise against hosting any site this way, especially since it turns out to not even be the cheapest option!</p>
<h1 id="second-attempt-433month">Second attempt: $4.33/month</h1>
<p>Wait, my hosting cost went up!? Yes, and it was money well spent.</p>
<p>After getting slightly alarmed at all of the nefarious traffic flowing through my router, I was happy to pay for a virtual private server. This way it&#39;s at least not my own personal network that&#39;s at risk when something goes wrong.</p>
<p>I selected <a href="https://www.vultr.com/">Vultr</a> as the host because they <a href="https://www.vultr.com/products/cloud-compute/#pricing">offered a decent server for $2.50/month</a>... except that server is <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> only, and it turns out that much of the Internet is stuck in the address-constrained dark age of IPv4. So I had to pay a $1/month premium for an IPv4 address.</p>
<p>The tech stack was the same except for the host. Both the VPS&#39;s Internet connection and CPU were light years beyond what I had with my Raspberry Pi on &quot;cheap&quot; cable Internet.</p>
<h2 id="cost-1">Cost</h2>
<p>Adding in the domain name, my total cost was $4.33/month. A little more than I&#39;d like to spend on silly hobby projects, but this setup came with the peace of mind of not broadcasting my home IP address everywhere. Again, I could add more services to my server at no additional cost to me.</p>
<h2 id="concerns-1">Concerns</h2>
<p>Other than costing me roughly $50/year, this setup worked great. But it wasn&#39;t as robust as I&#39;d like:</p>
<ul>
<li>The database was a single file sitting on the server&#39;s drive, with no backup, so I could theoretically lose it due to hardware failure</li>
<li>Configuring the server was a manual process, so if there was a crash, I&#39;d have to spend time setting a new server up</li>
</ul>
<p>At the time, I wasn&#39;t aware, but there are solutions to both of these problems:</p>
<ul>
<li>Use <a href="https://litestream.io/">Litestream</a> to continuously backup the SQLite database to cloud storage</li>
<li>Use <a href="https://www.docker.com/">Docker</a> to package everything up, enabling rapid recreation of the server</li>
</ul>
<p>There are actually many other solutions, but these are two simple approaches I plan on testing out in the future.</p>
<h1 id="third-attempt-free">Third attempt: FREE!</h1>
<p>While chatting with a friend who does web development for a living, he told me that I could probably host my site for free. That magic phrase led to several follow-up questions from me, and a lot more information from him.</p>
<p>It turns out that many cloud providers have free tiers to try and hook you into their ecosystems, in hopes that you&#39;ll eventually become a paying customer. I&#39;m pretty sure all the major cloud providers have free tiers, and some of them are quite generous. My uninformed opinion is that it seems like the less popular the platform, the more generous the free tier.</p>
<p>The annoying part of all of this is that the best free offers vary substantially, so you&#39;ll likely end up having to use multiple different providers. In my case, the tech stack looks like this:</p>
<ul>
<li>Node JavaScript environment</li>
<li><a href="https://koajs.com/">Koa</a> web framework</li>
<li><a href="https://cloud.google.com/firestore/">Firestore</a> document database</li>
<li><a href="https://www.netlify.com/products/functions/">Netlify Functions</a> &quot;<a href="https://en.wikipedia.org/wiki/Serverless_computing">serverless</a>&quot; end point<ul>
<li>Hosted on the (free) &quot;netlify.app&quot; domain</li>
</ul>
</li>
</ul>
<p>Since everything is in the cloud, I&#39;m also less concerned about hardware failure. I haven&#39;t thoroughly investigated whether I should backup my Firestore data or if their architecture seems robust enough for my needs.</p>
<h2 id="cost-2">Cost</h2>
<p>Zero cost, since I didn&#39;t need to use a custom domain. I didn&#39;t even have to provide a credit card.</p>
<h2 id="concerns-2">Concerns</h2>
<p>This setup is free, which is great, but when I last checked, both of the free offerings I&#39;m using were actually fairly expensive if you end up with enough traffic to need to start paying. You&#39;re also locked into their systems unless you want to start rewriting code.</p>
<p>I also found that Firestore wasn&#39;t a great fit for my needs, since it&#39;s a &quot;<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>&quot; document database that basically requires me to build and maintain my own aggregations. But I&#39;m not paying anything, so I shouldn&#39;t complain.</p>
<h1 id="what-about-the-future">What about the future?</h1>
<p>I succeeded in finding free hosting for my hobby projects. Great! But I&#39;m not perfectly happy being locked into specific vendors and libraries.</p>
<p>Cloud services are great, but I&#39;d really like something more portable, in case I ever create a project that ends up getting a significant amount of traffic. There may be better approaches, but I think I&#39;d like to use containers hosted on a VPS (with backup to commodity cloud storage), just for portability reasons.</p>
<p>I have heard that Oracle&#39;s cloud has a <a href="https://www.oracle.com/cloud/free/#always-free">free tier that even includes your own virtual private servers</a>, so I may look into that eventually. Planning to use Oracle is something I never thought I&#39;d be doing as a hobbyist, but these are interesting times.</p>
<p>The future might look like this:</p>
<ul>
<li>Node environment</li>
<li>Koa web framework</li>
<li>SQLite database<ul>
<li>Backed up to commodity store (e.g. <a href="https://www.backblaze.com/">Backblaze</a>) via Litestream</li>
</ul>
</li>
<li>Forever-service monitoring</li>
<li>Let&#39;s encrypt certificate</li>
<li>All in a Docker container</li>
<li>Hosed on Oracle&#39;s free compute VM</li>
</ul>
]]></description><link>https://log.schemescape.com/posts/services/cheap-hosting</link><guid isPermaLink="true">https://log.schemescape.com/posts/services/cheap-hosting</guid><pubDate>Wed, 22 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Embedding images directly into Markdown posts -- terrible idea?]]></title><description><![CDATA[<p>This might turn out to be a terrible idea, but in pursuit of self-contained Markdown-based blog posts, I&#39;m going to try embedding images (and, maybe later, other assets) directly into my Markdown posts.</p>
<h1 id="background">Background</h1>
<p>Most blogging platforms I&#39;ve looked at support inserting images into posts as follows:</p>
<ul>
<li>Images are uploaded to a specific location</li>
<li>Output HTML files reference the images (ideally using relative links)</li>
</ul>
<p>This is great if an image needs to be shared between posts, but that&#39;s not the typical use case. In the usual case, I see images used once in a single post.</p>
<p>As a <em>viewer</em> I like this setup because the images can be loaded lazily, I can open the image link in a new tab, etc.</p>
<h1 id="gripes">Gripes</h1>
<p>As an author, however, I have some complaints about this setup because posts and images become coupled:</p>
<ul>
<li>I have to add multiple files to build a particular post</li>
<li>If I want to remove a post, I have to also remove the images it contains</li>
<li>Probably not common, but if I want to duplicate a post elsewhere, I have to grab the images as well</li>
</ul>
<h1 id="my-previous-solution">My previous solution</h1>
<p>In the past, my solution to this problem was to build a directory for each post and the directory contained both the post content as well as any associated images and files.</p>
<p>This is, in my opinion, a pretty reasonable solution because now the entire post is contained in a single location. If my crazy new idea doesn&#39;t work, I&#39;ll probably revert to this tried and true solution.</p>
<h1 id="directly-embedding-images">Directly embedding images</h1>
<p>So here&#39;s my crazy idea: what if I embed images directly into their source Markdown files using <a href="https://en.wikipedia.org/wiki/Base64">Base64-encoded</a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">Data URLs</a>?</p>
<p>Data URLs are only recommended for small files (ideally &lt; 1 KB), but my research indicates that this recommendation is based on:</p>
<ol>
<li>Separating essential HTML/text content from slightly less important image content</li>
<li>Some HTML/XML implementations arbitrarily limiting the size of an element and its attributes</li>
</ol>
<p>I happen to agree with #1, so when compiling my site I do plan to split out images into their own files. But #2 feels like a vestigial limitation from the days of allocating fixed size buffers on the stack in C code. That&#39;s not to say #2 won&#39;t cause me trouble--I just don&#39;t think it&#39;s a good enough reason on its own to discard my idea.</p>
<h2 id="prototype-encoder">Prototype encoder</h2>
<p>Here&#39;s the code for my prototype encoder (side note: I don&#39;t know why Node refused to accept the clearly documented &quot;base64url&quot; encoding):</p>
<pre><code>const path = require(&quot;path&quot;);
const fs = require(&quot;fs/promises&quot;);

// TODO: Use a more comprehensive library
const fileExtensionToMimeType = {
    &quot;.jpg&quot;: &quot;image/jpeg&quot;,
    &quot;.png&quot;: &quot;image/png&quot;,
};

(async () =&gt; {
    try
    {
        const filePath = process.argv[2];
        if (!filePath) throw &quot;No path specified!&quot;;

        const fileExtension = path.extname(filePath);
        const mimeType = fileExtensionToMimeType[fileExtension];
        if (!mimeType) throw `Could not determine MIME type for extension &quot;${fileExtension}&quot;!`;

        const buffer = await fs.readFile(filePath);
        const base64UrlEncoded = encodeURI(buffer.toString(&quot;base64&quot;));

        const dataUrl = `data:${mimeType};base64,${base64UrlEncoded}`;
        console.log(dataUrl);
    }
    catch (err) {
        console.error(`ERROR: ${err}`);
    }
})();</code></pre><h2 id="exhibit-a">Exhibit A</h2>
<p>Here&#39;s a very small (in terms of number of bytes) PNG file that&#39;s been directly embedded (this is the ~600 byte <a href="https://en.wikipedia.org/wiki/Favicon">Favicon</a> for my site):</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC" alt="Small embedded PNG file"></p>
<p>Here&#39;s what the Markdown input looks like, for reference:</p>
<pre><code>![Small embedded PNG file](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhWlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9TpSpVByuKOGSoThbELxylikWwUNoKrTqYXD+hSUOS4uIouBYc/FisOrg46+rgKgiCHyBubk6KLlLi/5JCixgPjvvx7t7j7h0g1EpMMdrGAUU19XgkLKbSq6LvFZ3oxwB6MC0xQ4smFpNwHV/38PD1LsSz3M/9ObozWYMBHpF4jmm6SbxBPLNpapz3iQOsIGWIz4nHdLog8SPXZYffOOdtFnhmQE/G54kDxGK+heUWZgVdIZ4iDmYUlfKFlMMZzluclVKFNe7JX+jPqisJrtMcRgRLiCIGETIqKKIEEyFaVVIMxGk/7OIfsv0xcsnkKoKRYwFlKJBsP/gf/O7WyE1OOEn+MND+YlkfI4BvF6hXLev72LLqJ4D3GbhSm/5yDZj9JL3a1IJHQO82cHHd1OQ94HIHGHzSJF2yJS9NIZcD3s/om9JA3y3Qteb01tjH6QOQpK6Wb4CDQ2A0T9nrLu/uaO3t3zON/n4AuI1yw2D/uDMAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQflCRUXDwx3zQBcAAAAbElEQVQ4y81TMRLAIAgTjzH8/6E8wE52oBDbY2kmz2gSEQTAGg3oXrj7gzSzIycAlrvfG2+x72hGsATRSDPVKm52ZrKIrD5UILqYWSkyRxM/FYhvZn1SJohFPLZy5vy5kSo3lkD2NLaGqfMLF2xqO0/W9QaIAAAAAElFTkSuQmCC)</code></pre><p>I also tested a much larger image file and it worked just as well, but I decided to omit that file from this post because I didn&#39;t want to bloat up this file (and repository) for no good reason.</p>
<h2 id="observations-in-vs-code">Observations in VS Code</h2>
<p>Well, the images render fine in Visual Studio Code&#39;s Markdown Preview window. Syntax highlighting in the Markdown file I&#39;m editing is ok, too. But there is one problem.</p>
<p>I&#39;ve been happily using word-wrapping when editing Markdown files and, unsurprisingly, these enormous strings make word-wrapping pretty much impossible to use. This could end up being fairly annoying. I&#39;ll let this issue marinate in the back of my mind for a bit.</p>
<h2 id="observations-in-githubs-markdown-viewer">Observations in GitHub&#39;s Markdown viewer</h2>
<p>To my surprise, the image did not display at all in GitHub&#39;s Markdown viewer--it just showed a &quot;broken image link&quot; icon. That&#39;s unfortunate because I&#39;d like my site to be as functional as possible when viewed directly on GitHub.</p>
<h2 id="observations-compiling-with-marked">Observations compiling with Marked</h2>
<p>The Markdown appears to have compiled fine using <a href="https://marked.js.org/">Marked</a> (via <a href="https://metalsmith.io/">Metalsmith</a>). It wasn&#39;t noticeably slow or anything either. Great!</p>
<h2 id="observations-viewing-the-resulting-html-in-chromium-based-edge">Observations viewing the resulting HTML in Chromium-based Edge</h2>
<p>Note: as I noted earlier, I&#39;m not normally planning on uploading my static site in this format, but out of sheer curiosity, would this work unmodified?</p>
<p>The images display just fine in my site on Chromium-based Edge. Good to know!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Overall, while I like the idea of having completely self-contained Markdown files, the fact that the images don&#39;t work on GitHub&#39;s Markdown viewer and that the incredibly long text blobs effectively break word-wrapping in VS Code lead me to believe that this was a failed experiment. I don&#39;t think I&#39;ll pursue this method any further.</p>
<p>I&#39;m still happy that I gave it a shot. You never really know until you try!</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/embedded-images</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/embedded-images</guid><pubDate>Tue, 21 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Metalsmith for a simple dev blog]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> to see which is closest to <a href="../overview/">my ideal setup</a>. Next up is <a href="https://metalsmith.io/">Metalsmith</a>.</p>
<p>Spoiler: I really like Metalsmith&#39;s modular design, so much so that I&#39;m now using Metalsmith for this blog.</p>
<h1 id="metalsmith">Metalsmith</h1>
<p>Metalsmith is a Node-based static site generator with a modular architecture that relies on many small plugins (similar in style to <a href="https://gulpjs.com/">gulp</a>). Installation is done via NPM (but note that you&#39;ll likely need to track down and install many plugins).</p>
<h2 id="architecture">Architecture</h2>
<p>Metalsmith is configured using plain old JavaScript code and building the site is just a matter of running your script, which is especially nice for debugging issues. See their &quot;elevator pitch&quot; on the <a href="https://metalsmith.io/">Metalsmith home page</a> for an example. It&#39;s refreshingly simple and transparent, but you&#39;ll need to install plugins and write some code to get a test server with live reloading (unlike many other modern static site generators that support this out the box).</p>
<p>While vetting and adding plugins is tedious, I like the fact that Metalsmith doesn&#39;t install 500+ packages by default (... like Eleventy).</p>
<p>Thanks to <a href="https://github.com/jstransformers/jstransformer">jstransformer</a>, Metalsmith supports a wide variety of template languages. I&#39;m not a fan of <a href="https://liquidjs.com/">Liquid</a> or <a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>, but I&#39;m trying out <a href="https://handlebarsjs.com/">Handlebars</a> because I find it more intuitive and less verbose. So far, it seems easier to maintain than the plain JavaScript templates I used with <a href="../eleventy-2/">Eleventy</a>.</p>
<h2 id="themes">Themes?</h2>
<p>If you don&#39;t want to author your own HTML templates, Metalsmith honestly doesn&#39;t seem like a good choice. It&#39;s possible to construct a Metalsmith &quot;theme&quot; by combining plugins, configuration, and templates, but really what you&#39;re providing is an entire skeleton project (with a <code>package.json</code> file, build scripts, and so on). This means the result is less portable and more difficult to integrate (unless you&#39;re starting from scratch and don&#39;t have any opinions or constraints).</p>
<p>Other static site generators (e.g. Hugo) abstract out the concept of a theme (along with standard metadata that themes can leverage), so you don&#39;t have to mix code and configuration together with HTML templates and CSS styling. This seems better for people who don&#39;t want total control of every character in their final HTML output.</p>
<h2 id="setup">Setup</h2>
<p><a href="https://metalsmith.io/#introduction">Metalsmith&#39;s home page</a> has a sample script right at the top you can look at, but you&#39;ll end up with a bunch of <code>require(...)</code>s followed by something like this:</p>
<pre><code>Metalsmith(__dirname)
    .metadata({
        site: {
            title: &quot;Schemescape&quot;,
            url: &quot;https://log.schemescape.com/&quot;,
            description: &quot;Development log of a life-long coder&quot;,
        },
    })
    .source(&quot;./content&quot;)
    .destination(&quot;./out&quot;)
    .use(collections({
        posts: {
            pattern: &quot;posts/**/*.md&quot;,
            sortBy: &quot;date&quot;,
            reverse: true,
        }
    }))
    .use(markdown())
    .use(layouts({
        directory: &quot;templates&quot;,
        default: &quot;default.hbs&quot;,
    }))
    ...
    .build(err =&gt; { if (err) throw err; });</code></pre><p>If you just want to build a dev blog like everyone else, it does feel like a lot of boilerplate code, but I like that it forces you to consider and understand each step of the process. Some of the other static site generators were too proactive and did things I didn&#39;t expect or understand (or want). With Metalsmith, it only does exactly what you tell it.</p>
<p>But there&#39;s a dark side to Metalsmith&#39;s simple model, and that&#39;s that Metalsmith has to be taught to do even the most basic things. For example, I&#39;m building my site on Windows, which has the unfortunate property of using backslashes for path separators. Metalsmith doesn&#39;t seem to know or care about this detail, so I had to actually write code to switch to web-friendly forward slashes when creating links between files in different directories.</p>
<h3 id="plugins-plugins-plugins">Plugins, plugins, plugins</h3>
<p>Metalsmith&#39;s modular architecture with a very simple core library means you need plugins--a lot of plugins. Fortunately, most of the functionality I was interested in already existed in the form of published plugins (some official, some third party). Here are the ones I used:</p>
<table>
<thead>
<tr>
<th>Plugin (* = official)</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/segmentio/metalsmith-markdown">metalsmith-markdown</a>*</td>
<td>Translates Markdown to HTML (using <a href="https://marked.js.org/">Marked</a>)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-drafts">metalsmith-drafts</a>*</td>
<td>Excludes files marked &quot;draft: true&quot; in YAML front matter (yep, you need a plugin for this)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-collections">metalsmith-collections</a>*</td>
<td>Groups and sorts files by path (e.g. for listing blog posts)</td>
</tr>
<tr>
<td><a href="https://github.com/segmentio/metalsmith-permalinks">metalsmith-permalinks</a>*</td>
<td>Creates a directory for each HTML file (so links only specify directories and not files)</td>
</tr>
<tr>
<td><a href="https://github.com/metalsmith/metalsmith-layouts">metalsmith-layouts</a>*</td>
<td>Adds support for templates using <a href="https://github.com/jstransformers">jstransformers</a></td>
</tr>
<tr>
<td><a href="https://github.com/jstransformers/jstransformer-handlebars">jstransformer-handlebars</a>*</td>
<td>Adds support for <a href="https://handlebarsjs.com/">Handlebars</a></td>
</tr>
<tr>
<td><a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a></td>
<td>Copies static assets (e.g. CSS and my &quot;CNAME&quot; file)</td>
</tr>
<tr>
<td><a href="https://github.com/radiovisual/metalsmith-rootpath">metalsmith-rootpath</a></td>
<td>Computes the path to root of each page (allowing you to use relative links to CSS, etc.)</td>
</tr>
<tr>
<td><a href="https://github.com/timdp/metalsmith-discover-partials">metalsmith-discover-partials</a></td>
<td>Registers <a href="https://handlebarsjs.com/guide/partials.html">Handlebar partials</a> (for reusing/nesting templates)</td>
</tr>
<tr>
<td><a href="https://github.com/hurrymaplelad/metalsmith-feed">metalsmith-feed</a></td>
<td>Creates an RSS feed from a collection</td>
</tr>
<tr>
<td><a href="https://github.com/davidxmoody/metalsmith-broken-link-checker">metalsmith-broken-link-checker</a></td>
<td>Validates relative links in the final site</td>
</tr>
<tr>
<td><a href="https://github.com/chiefy/metalsmith-express">metalsmith-express</a></td>
<td>Runs a test server for local testing (with live reloading)</td>
</tr>
<tr>
<td><a href="https://github.com/FWeinb/metalsmith-watch">metalsmith-watch</a></td>
<td>Triggers rebuilds when files are updated (needed for live reloading)</td>
</tr>
</tbody></table>
<p>Note that some of the plugins I installed had dependencies flagged by NPM as having vulnerabilities. I reviewed the notices and none seemed concerning for my use case (e.g. all of the input is code/content I wrote and I don&#39;t plan on targeting myself for a regular expression denial of service attack).</p>
<h3 id="missing-plugins">Missing plugins</h3>
<p>Despite all these great plugins, I did end up needing to add a little extra functionality. Theoretically, these could be packaged into plugins.</p>
<ul>
<li>Translate relative <code>*.md</code> links to point to the corresponding output directories</li>
<li>Compute relative link paths, with forward slashes only (Metalsmith only provides the source path by default)</li>
<li>A &quot;no-op&quot; plugin for conditional inclusion of plugins without breaking up the giant configuration chain</li>
</ul>
<h2 id="issues">Issues</h2>
<p>Here are a couple of snags I hit while integrating Metalsmith into my site.</p>
<h3 id="inflexible-directory-structure">Inflexible directory structure</h3>
<p>For how simple Metalsmith is, I figured it would allow for a flexible directory structure, but Metalsmith actually only allows a single source directory by default. This is a problem for my directory structure because I separated all of my content (Markdown files) from files needed to build the web site (scripts, templates, but also CSS). Fortunately, the <a href="https://github.com/TheHydroImpulse/metalsmith-static">metalsmith-static</a> plugin handle this scenario:</p>
<pre><code>const assets = require(&quot;metalsmith-static&quot;);

Metalsmith
...
    .use(assets({
        src: &quot;static&quot;,
        dest: &quot;.&quot;,
    }))</code></pre><h3 id="destination-paths-arent-available">Destination paths aren&#39;t available</h3>
<p>Somewhere in Metalsmith&#39;s pipeline, it knows where a file is going to end up, but for some inexplicable reason, this information isn&#39;t available to templates or plugins. In my case, it&#39;s easy to infer the destination (although I had to deal with Windows&#39; annoying path-separating backslashes), so it wasn&#39;t a big deal, but this really isn&#39;t something I should have had to think about.</p>
<h3 id="plugin-ordering">Plugin ordering</h3>
<p>Since plugins enrich and mutate files and metadata along the way, the ordering of plugins matters. One annoying interaction was between the &quot;layouts&quot; (templating) and &quot;feed&quot; (RSS) plugins:</p>
<ul>
<li>&quot;Feed&quot; then &quot;layouts&quot;: the RSS feed gets wrapped in HTML (&quot;layouts&quot; is run on <em>every</em> file by default)</li>
<li>&quot;Layouts&quot; then &quot;feed&quot;: the RSS content for each post is now a full HTML page, because templates were already applied</li>
</ul>
<p>The fix in this case was to run &quot;layouts&quot; after &quot;feed&quot; but tell &quot;layouts&quot; to only process HTML files (and not &quot;feed.xml&quot;).</p>
<p>This all makes sense if you think about how Metalsmith plugins receive a set of files, manipulate them, and then pass them on to the next plugin, but other generators do a good job of insulating me from mistakes like this.</p>
<h3 id="handling-internal-links">Handling internal links</h3>
<p>I&#39;m still surprised that using relative links to Markdown files for internal linking between posts isn&#39;t well supported by the static site generators I&#39;ve tried so far (Metalsmith included). I ended up having to extend the <a href="https://marked.js.org/using_pro#renderer">Marked renderer</a> to enable internal links:</p>
<pre><code>const marked = require(&quot;marked&quot;);
...
// Translate relative Markdown links to point to corresponding HTML output files
const markdownRenderer = new marked.Renderer();
const baseLinkRenderer = markdownRenderer.link;
markdownRenderer.link = function (href, title, text) {
    return baseLinkRenderer.call(this,
        href.replace(/^([^/][^:]*)\.md(#[^#]+)?$/, &quot;../$1/$2&quot;),
        title,
        text);
};
...
Metalsmith
...
    .use(markdown({ renderer: markdownRenderer }))
    .use(permalinks())</code></pre><p><strong>Update</strong>: I realized I also want to be able to link to a heading <em>within</em> another post (examples: <a href="#architecture">link to Architecture heading in this post</a>; <a href="../comparison/#metalsmith">link to my initial impression of Metalsmith in a different post</a>). The code above has been updated to handle this case.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Overall, I really liked that Metalsmith just did exactly what I asked, even if I didn&#39;t initially know what, precisely, I wanted. I was able to find plugins for almost everything to get started (including local testing with live reloading). Importantly, I also feel like I fully understand what Metalsmith is doing, so I don&#39;t have to worry about later discovering that it was processing files multiple times (something that did happen with Eleventy).</p>
<p>Additionally, because Metalsmith is so simple to extend, I can actually foresee myself writing a plugin to, say, add inline diagrams that are automatically converted to SVG at build time (a feature that&#39;s part of my <a href="../overview/">my ideal workflow</a>).</p>
<p>One comment on Handlebars: this isn&#39;t a review of Handlebars, but I did find Handlebars to be a surprisingly agreeable template language. This is actually high praise coming from me, since I find most template languages to be hideous and verbose. Only annoyance is that the automatic indentation isn&#39;t always what you want (e.g. in the case of <code>&lt;pre&gt;</code> blocks).</p>
<p>Overall, I&#39;m very happy with Metalsmith, and it&#39;s likely that I will be using it moving forward. <strong>Update</strong>: I switched from Eleventy to Metalsmith.</p>
<p>For reference, all of my code is here:
<a href="https://github.com/jaredkrinke/log">https://github.com/jaredkrinke/log</a></p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/metalsmith</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/metalsmith</guid><pubDate>Sat, 18 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[How to benchmark disk drives on Windows]]></title><description><![CDATA[<p>My computer (running Windows) has multiple drives in it and I was wondering which drive is actually the fastest. Fortunately, there&#39;s an app for that.</p>
<h1 id="background">Background</h1>
<p>In the past, I kept up to date on computer hardware (because, let&#39;s be honest, games), but I&#39;ve been lazy for the past decade or so.</p>
<p>I recently inherited some new parts and now I&#39;ve got 3 drives:</p>
<ol>
<li>Cheapo solid state drive I bought off Newegg a few years back</li>
<li>1 TB rotational drive I salvaged from a discarded Western Digital My Book</li>
<li>Fancy new non-volatile memory (NVMe) drive</li>
</ol>
<p>My limited understanding tells me that the NVMe drive should be the fastest and that the rotational drive should be incredibly slow in comparison.</p>
<h1 id="benchmarking-with-diskspd">Benchmarking with DiskSpd</h1>
<p>Enter <a href="https://github.com/Microsoft/diskspd/wiki">DiskSpd</a>, an official disk benchmarking tool from Microsoft. It&#39;s just an executable that you download and run (as administrator).</p>
<p>It has <a href="https://github.com/Microsoft/diskspd/wiki/Command-line-and-parameters">a lot of command line options</a>, but <a href="https://www.windowscentral.com/how-test-hard-drive-performance-diskspd-windows-10">a random article I found directed me to the most relevant ones</a>.</p>
<p>In my case, I&#39;m just interested in read performance, so I ran the following two commands (the first, <code>-s</code>, is for sequential reads and the second, <code>-r</code>, is for random reads):</p>
<pre><code>diskspd -d10 -c128M -t1 -o1 -Sh -w0 -s d:\tmp.dat
diskspd -d10 -c128M -t1 -o1 -Sh -w0 -r d:\tmp.dat</code></pre><p>These tests run:</p>
<ul>
<li>For 10 seconds</li>
<li>On a 128 MB test file (which DiskSpd leaves behind after it finishes)</li>
<li>On a single thread</li>
<li>With one operation outstanding</li>
<li>Without write caching (probably unnecessary for read tests)</li>
<li>0% of operations are writes</li>
<li>In sequential or random access, as indicated</li>
<li>On a file named d:\tmp.dat (I change the drive letter for each drive, obviously)</li>
</ul>
<h1 id="results">Results</h1>
<table>
<thead>
<tr>
<th>Drive</th>
<th align="right">Sequential (MB/s)</th>
<th align="right">Random (MB/s)</th>
</tr>
</thead>
<tbody><tr>
<td>SATA SSD</td>
<td align="right">190</td>
<td align="right">130</td>
</tr>
<tr>
<td>Rotational</td>
<td align="right">55</td>
<td align="right">8</td>
</tr>
<tr>
<td>NVMe</td>
<td align="right">550</td>
<td align="right">530</td>
</tr>
</tbody></table>
<p>As expected, the NVMe drive was the fastest and the rotational drive was the slowest (especially for random reads)... but the actual gaps are enormous!</p>
<p>I guess if I ever get to a point where I have a project that is big enough that disks become the bottleneck, I can just throw everything over onto the NVMe and enjoy a ~3x speedup. Good to know!</p>
]]></description><link>https://log.schemescape.com/posts/hardware/benchmarking-drives</link><guid isPermaLink="true">https://log.schemescape.com/posts/hardware/benchmarking-drives</guid><pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate></item><item><title><![CDATA[Test-driving Eleventy for a simple dev blog, part 2]]></title><description><![CDATA[<p>I&#39;m testing out <a href="../comparison/">the most promising static site generators</a> for my blog. In <a href="../eleventy/">part 1</a>, I recorded my initial impression of Eleventy; in this post, I describe my experience fully integrating Eleventy into my dev blog (<a href="https://github.com/jaredkrinke/log/tree/eleventy">final code here</a>).</p>
<h1 id="background">Background</h1>
<p>I <a href="../overview/">already covered my ideal dev blog setup in detail</a>, but here&#39;s the gist of it:</p>
<ul>
<li>Content is written using <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> (because it&#39;s succinct and ubiquitous)</li>
<li>Each post is a separate file, with YAML front matter for title, date, description, keywords</li>
</ul>
<p>And the corresponding directory structure:</p>
<ul>
<li><code>content/</code>: Root directory of all blog content<ul>
<li><code>posts/</code>: Root of all blog posts<ul>
<li><code>topic1/</code>: Blog posts organized by topics<ul>
<li><code>post1.md</code>: Blog post 1</li>
<li><code>post2.md</code></li>
<li>etc.</li>
</ul>
</li>
<li><code>topic2/</code></li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
<li><code>static/</code>: Static files (namely CSS)</li>
<li><code>templates/</code>: Template/layout files</li>
</ul>
<h1 id="configuration">Configuration</h1>
<p>My initial <code>.eleventy.js</code> configuration file looked something like this:</p>
<pre><code>module.exports = function(eleventyConfig) {
    // Copy everything under &quot;static&quot; to the root of the built site (note: this is relative to this config file)
    eleventyConfig.addPassthroughCopy({ &quot;static&quot;: &quot;./&quot; });

    return {
        // Don&#39;t process Markdown first with a template language
        markdownTemplateEngine: false,

        dir: {
            input: &quot;content&quot;,
            output: &quot;out&quot;,
            includes: &quot;../templates&quot; // Note: this is relative to the input directory
        }
    }
};</code></pre><p>Note: the <code>markdownTemplateEngine: false</code> setting is to prevent Eleventy from using Liquid to process my Markdown (I don&#39;t want this step because it tries to process all instances of <code>{%</code>, etc., when I actually want to be able to use those tokens in my blog post content).</p>
<h1 id="javascript-templates-easy-to-write-hard-to-maintain">JavaScript templates: easy to write, hard to maintain</h1>
<p>After spending the last few posts railing against &quot;unintuivie&quot;, &quot;verbose&quot;, and &quot;ugly&quot; template languages like Liquid and EJS, <a href="https://www.11ty.dev/docs/languages/javascript/">Eleventy&#39;s JavaScript templates</a> felt like a shining beacon of familiarity and simplicity -- it&#39;s just JavaScript! Sure, JavaScript used to be a terrible language (what do you expect for a language that was <a href="https://web.archive.org/web/20160305202500/http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf">originally created in 10 days</a>?), but modern JavaScript is pleasant to write, especially with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a>.</p>
<p>I was able to easily dive in and create a bare bones page template (I put this in a shared library, <code>templates\shared.js</code>):</p>
<pre><code>    renderPage: (data, content) =&gt; `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;Schemescape${data.title?.length &gt; 0 ? `: ${escapeHTML(data.title)}` : &quot;&quot;}&lt;/title&gt;
        ${data.description ? `&lt;meta name=&quot;description&quot; content=&quot;${escapeHTML(data.description)}&quot; /&gt;` : &quot;&quot;}
        ${data.keywords?.length &gt; 0 ? `&lt;meta name=&quot;keywords&quot; content=&quot;${escapeHTML(data.keywords.join(&quot;,&quot;))}&quot; /&gt;` : &quot;&quot;}
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;${getPagePathToRoot(data)}/css/style.css&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;main&gt;
            &lt;header&gt;&lt;h1&gt;&lt;a href=&quot;${getPagePathToRoot(data)}/&quot;&gt;Schemescape&lt;/a&gt;&lt;/h1&gt;&lt;/header&gt;
            ${content}
        &lt;/main&gt;
    &lt;/body&gt;
&lt;/html&gt;`,</code></pre><p>This probably took me 10 minutes to create. But there are a few problems I&#39;ve noticed along the way:</p>
<ul>
<li>It&#39;s hard to read because it&#39;s constant switching back and forth between strings and code (and the code would balloon if I started pulling code out of the template)</li>
<li>There&#39;s no syntax validation because it&#39;s just plain text<ul>
<li>At one point, after moving some HTML around, I forgot to delete an opening tag -- Node doesn&#39;t care because it&#39;s just opaque text! I felt bad that the browser had to try and make sense of my malformed HTML</li>
</ul>
</li>
<li>You always have to add code to escape text that might contain quotation marks, etc.<ul>
<li>Granted, other template languages can be too overzealous about escaping text, leading to mistakes I see all over the web that look like &quot;I&amp;apos;m double-escaped!&quot;</li>
</ul>
</li>
<li>As noted in a previous post, &quot;themes&quot; become JavaScript code, which seems like a security issue for anyone who wants to just download and try random themes off the web</li>
</ul>
<p>Given that I already know JavaScript, for a simple web site like mine, JavaScript templates are quick and easy. I&#39;m not sure I&#39;d want to maintain a large list of such templates, however, because they&#39;re a bit messy and error-prone.</p>
<p>Note: the template above uses some helpers defined elsewhere in the file, e.g. to compute the path to the root of the site (so I can use relative links and view my HTML directly from the file system). The full code is in <a href="https://github.com/jaredkrinke/log/blob/eleventy/templates/shared.js">my GitHub repository, on the eleventy branch</a>.</p>
<h1 id="blog-post-pages">Blog post pages</h1>
<p>Setting up blog post pages was pretty simple:</p>
<h2 id="1-create-the-html-template">1. Create the HTML template</h2>
<p>I called it <code>templates/post.11ty.js</code>:</p>
<pre><code>const escapeHTML = require(&quot;escape-html&quot;)
const { renderPage } = require(&quot;./shared&quot;);

const formatDateAsTimeElement = date =&gt; `&lt;time datetime=&quot;${date.toISOString().replace(/T.*$/, &quot;&quot;)}&quot;&gt;${dateFormatter.format(date)}&lt;/time&gt;`;

const renderArticle = data =&gt; `
&lt;article&gt;
    &lt;header&gt;
        &lt;h1&gt;&lt;a href=&quot;./&quot;&gt;${escapeHTML(data.title)}&lt;/a&gt;&lt;/h1&gt;
        &lt;p&gt;${formatDateAsTimeElement(data.page.date)}&lt;/p&gt;
    &lt;/header&gt;
    ${data.content}
&lt;/article&gt;`;

module.exports = data =&gt; renderPage(data, renderArticle(data))</code></pre><h2 id="2-inject-data-into-all-posts">2. Inject data into all posts</h2>
<p>Add <code>content/posts.json</code> to inject data to all files under the <code>content/posts</code> directory:</p>
<pre><code>{
    &quot;layout&quot;: &quot;post.11ty.js&quot;,
    &quot;tags&quot;: &quot;post&quot;
}</code></pre><p>The first setting selects the template and the second tags all the files as part of the &quot;post&quot; collection (for later iteration).</p>
<p>With those two simple steps, Eleventy will generate directories with an HTML file for each Markdown source file I write.</p>
<h1 id="adding-a-home-page">Adding a home page</h1>
<p>For now, I&#39;m just aggregating all my posts in reverse chronological order on the home page. Also pretty simple:</p>
<h2 id="1-create-the-html-template-1">1. Create the HTML template</h2>
<p>Along with my generic page template above, the template is pretty simple (note the <code>data.collections.post.slice().reverse().map(...)</code> part):</p>
<p><code>templates/index.11ty.js</code>:</p>
<pre><code>const { renderPage } = require(&quot;./shared&quot;);

const renderArticleShort = data =&gt; `
&lt;article&gt;
    &lt;header&gt;
        &lt;h1&gt;&lt;a href=&quot;.${data.page.url}&quot;&gt;${data.title}&lt;/a&gt;&lt;/h1&gt;
        &lt;p&gt;${formatDateAsTimeElement(data.page.date)}&lt;/p&gt;
    &lt;/header&gt;
    &lt;summary&gt;&lt;p&gt;${data.description}&lt;/p&gt;&lt;/summary&gt;
&lt;/article&gt;`;

module.exports = data =&gt; renderPage(data,
`&lt;ul&gt;
    ${data.collections.post.slice().reverse().map(post =&gt; `&lt;li&gt;${renderArticleShort(post.data)}&lt;/li&gt;`).join(&quot;\n&quot;)}
&lt;/ul&gt;`);</code></pre><p>Note: the <code>.slice()</code> is needed because JavaScript&#39;s <code>reverse()</code> function mutates the array (<a href="https://www.11ty.dev/docs/collections/#array-reverse">as Eleventy&#39;s documentation notes</a>).</p>
<h2 id="2-add-a-source-file">2. Add a source file</h2>
<p>The <code>content\index.md</code> file just points to the template:</p>
<pre><code>---
layout: index.11ty.js
---</code></pre><p>Eleventy will now build my <code>index.html</code> file at the root of the output directory.</p>
<h1 id="enabling-links-between-pages">Enabling links between pages</h1>
<p>I use relative links between my Markdown files for internal links. For example, the post you&#39;re reading is <a href="../eleventy-2/"><code>eleventy-2.md</code></a> and my previous post on Eleventy is <a href="../eleventy/"><code>eleventy.md</code></a>. Here&#39;s how I made that second link:</p>
<pre><code>[`eleventy.md`](eleventy.md)</code></pre><p>This setup feels natural and works great for Markdown, both in <a href="https://code.visualstudio.com/Docs/languages/markdown">Visual Studio Code&#39;s Markdown preview mode</a>, and when <a href="https://github.com/jaredkrinke/log/blob/main/content/posts/static-site-generators/eleventy-2.md">viewing Markdown files in my repository directly on GitHub</a>.</p>
<p>I was <em>hoping</em> that many static site generators would translate these links into ones that worked on the HTML web site, but so far it&#39;s seeming like that was just wishful thinking.</p>
<p>Fortunately, since I&#39;m not tweaking output locations, this translation is just a simple mechanical process (prepend &quot;../&quot; and remove the &quot;.md&quot; suffix). Even better, there is a markdown-it plugin named <a href="https://www.npmjs.com/package/markdown-it-replace-link">markdown-it-replace-link</a> for making such changes. This plugin can be integrated into Eleventy&#39;s pipeline via the <code>.eleventy.js</code> config file (after <code>npm install --save-dev markdown-it-replace-link</code>, of course):</p>
<pre><code>module.exports = function(eleventyConfig) {
    // Convert relative Markdown file links to relative post links
    const customMarkdownIt = require(&quot;markdown-it&quot;)({
            html: true,
            replaceLink: link =&gt; link.replace(/^([^/][^:]*)\.md$/, &quot;../$1&quot;),
        })
        .use(require(&quot;markdown-it-replace-link&quot;));

    eleventyConfig.setLibrary(&quot;md&quot;, customMarkdownIt);
...</code></pre><p>The regular expression just checks for relative links (not starting with &quot;/&quot; or containing a &quot;:&quot;) that end with &quot;.md&quot; and then prepends &quot;../&quot; and omits the &quot;.md&quot; suffix, to instead point to the source Markdown file&#39;s corresponding output directory (which contains an <code>index.html</code>).</p>
<h1 id="adding-an-rss-feed">Adding an RSS feed</h1>
<p>Many of the static site generators I tested out automagically generate an RSS news feed. Eleventy does not do this.</p>
<p>Eleventy&#39;s documentation points to an <a href="https://www.11ty.dev/docs/plugins/rss/">official plugin</a> for generating an <a href="https://en.wikipedia.org/wiki/Atom_(Web_standard)">Atom</a> feed.</p>
<p>But if you read the documentation, it becomes apparent that the plugin is just a couple of helpers and the actual Atom template is something you&#39;ll be copy-pasting into your repository. Interestingly, I don&#39;t see any logic in the sample template to limit the number of posts.</p>
<p>This feels like a shortcoming of Eleventy (and one that probably wouldn&#39;t be difficult to fix). I shouldn&#39;t have to maintain my own template for a standard format.</p>
<h1 id="validating-links">Validating links</h1>
<p>In the interest of catching mistakes before sharing them with the entire Internet, I&#39;d like to at least validate all of the internal links between my pages at build time.</p>
<p>My ideal implementation would be a tool that I unleash on the output HTML files, crawling relative links to ensure they&#39;re all valid and that all pages are reachable. It would also ensure that any links to anchors within pages exist. Such a tool probably exists, but I haven&#39;t found it yet.</p>
<p>For now, I&#39;m just using a quick and dirty hack that validates Markdown files exist in the process of updating the relative links noted previously. The code is fragile and slow enough that I won&#39;t advertise it anymore here, but it is in the repository linked below, if you&#39;re curious.</p>
<h1 id="and-thats-it">And that&#39;s it!</h1>
<p>It took a little while to sort out some of the above details, but since I was able to leverage my existing JavaScript knowledge, Eleventy ended up being pretty easy to integrate. As proof, this page exists, and you&#39;re reading it.</p>
<p>All of the actual code used to generate this page is <a href="https://github.com/jaredkrinke/log/tree/eleventy">up on GitHub under the &quot;eleventy&quot; branch</a>.</p>
<p><strong>Update</strong>: I ended up <a href="../metalsmith/">switching from Eleventy to Metalsmith</a> because Metalsmith has a simpler design and is easier to extend with plugins.</p>
]]></description><link>https://log.schemescape.com/posts/static-site-generators/eleventy-2</link><guid isPermaLink="true">https://log.schemescape.com/posts/static-site-generators/eleventy-2</guid><pubDate>Thu, 16 Sep 2021 00:00:00 GMT</pubDate></item></channel></rss>