<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2025-01-17T23:21:56.282Z</updated>

<entry>
<title>I apologize to the Python ecosystem</title>
<id>https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html"/>
<updated>2025-01-17T00:00:00.000Z</updated>
<summary type="text">I shouldn&apos;t disparage Python or, really, any programming language. Let me try and right my wrongs.</summary>
<content type="html">&lt;p&gt;Today, I discovered that my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html&quot;&gt;Python is the new BASIC&lt;/a&gt; post had been discussed on a popular site. It&amp;#39;s always a joy when people take an interest in your work, right? Well...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In the comments, I was rightly roasted.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider this post an apology and a promise to do better.&lt;/p&gt;
&lt;p&gt;(Note: I went back and edited the post in question. This commentary applies to the original content.)&lt;/p&gt;
&lt;h1 id=&quot;problems-with-my-post&quot;&gt;Problems with my post&lt;/h1&gt;
&lt;p&gt;First off, &lt;strong&gt;the overall tone of the post crossed the line from criticism to snark--or maybe even scorn&lt;/strong&gt;. In my head, some of the jabs were just good-natured ribbing, but upon re-reading from the perspective of an internet stranger, it&amp;#39;s just oozing with derision. If I&amp;#39;m going to post something publicly, I should remember that &lt;strong&gt;the audience is not myself, but just anyone who happens to come along&lt;/strong&gt; (except AI scrapers, per robots.txt).&lt;/p&gt;
&lt;p&gt;Additionally, I didn&amp;#39;t clearly articulate my complaints with Python. I think some them are legitimate but, besides being better explained elsewhere, &lt;strong&gt;my issues are not even that relevant&lt;/strong&gt;. The things I like about Python outweigh the things I dislike. And &lt;strong&gt;there is a huge advantage to having a common programming language that everyone understands&lt;/strong&gt; (even if only the basics). I like keeping posts short, and a good way to do that is to stay on topic and cut out (most of) the snark.&lt;/p&gt;
&lt;h1 id=&quot;not-just-python&quot;&gt;Not just Python&lt;/h1&gt;
&lt;p&gt;And it&amp;#39;s not just Python. I&amp;#39;ve also whined about perceived bloat on, ahem, more than one occasion. I&amp;#39;ve complained about compilers not working on the first try. And so on. &lt;strong&gt;There isn&amp;#39;t any value in posting shallow dismissals of projects that took enormous amounts of work to produce&lt;/strong&gt;. I&amp;#39;ll try to stop doing that. &lt;strong&gt;Even if I can&amp;#39;t always make the world better, I can at least try to not make it worse&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Mea culpa.&lt;/p&gt;
</content>
</entry>
<entry>
<title>New year, new programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-14.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-14.html"/>
<updated>2025-01-16T00:00:00.000Z</updated>
<summary type="text">I finished my dumb project.</summary>
<content type="html">&lt;p&gt;I just finished &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;solving the first 100 Project Euler problems using 100 different programming languages&lt;/a&gt;. For reference: &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;here is all the code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I&amp;#39;m planning to write up a summary post at some point&lt;/strong&gt;, but this is just my last throwaway post with brief notes on the languages I&amp;#39;ve tried since &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-13.html&quot;&gt;the last update&lt;/a&gt;. Rye and Nelua were the stars of this round.&lt;/p&gt;
&lt;h1 id=&quot;notes&quot;&gt;Notes&lt;/h1&gt;
&lt;h2 id=&quot;ats&quot;&gt;ATS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I didn&amp;#39;t understand some of the syntax, e.g. &lt;code&gt;:&amp;lt;cloref1&amp;gt;&lt;/code&gt; and &lt;code&gt;t@ype&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Error messages were sometimes surprising, e.g. &lt;code&gt;the syntactic entity [impqi0de] is needed.&lt;/code&gt; -- what is &lt;code&gt;[impqi0de]&lt;/code&gt;???&lt;/li&gt;
&lt;li&gt;Another example: copy-pasting &lt;code&gt;fn square (x: double): double = x * x&lt;/code&gt; from the official documentation yields &lt;code&gt;error: ‘PMVtmpltcstmat’ undeclared (first use in this function)&lt;/code&gt; -- solutiong was to put &lt;code&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;&lt;/code&gt; at the top of the file (my mistake--but the error was unhelpful)&lt;/li&gt;
&lt;li&gt;I didn&amp;#39;t attempt to include any proofs in my code, so I didn&amp;#39;t really leverage ATS to its fullest (or, really, any) extent&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;pre-scheme&quot;&gt;Pre-Scheme&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using the built-in &lt;code&gt;errors&lt;/code&gt; enum resulted in compilation errors&lt;/li&gt;
&lt;li&gt;Static typing in Scheme is awkward because I couldn&amp;#39;t find a clean way to not return anything&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t find an example of asserting types&lt;/li&gt;
&lt;li&gt;Unstripped solution binary was ~50 KB (C is great!)&lt;/li&gt;
&lt;li&gt;Didn&amp;#39;t actually bother deallocating memory (C is great!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;common-lisp&quot;&gt;Common Lisp&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive development is helpful (and fun)&lt;/li&gt;
&lt;li&gt;So many cryptic/inconsistent names, e.g. &lt;code&gt;fmakunbound&lt;/code&gt;, &lt;code&gt;mapcon&lt;/code&gt;, &lt;code&gt;clrhash&lt;/code&gt;, &lt;code&gt;prin1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; vs. &lt;code&gt;equalp&lt;/code&gt; vs. &lt;code&gt;equal&lt;/code&gt; vs. &lt;code&gt;eql&lt;/code&gt; vs. &lt;code&gt;eq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SBCL is fast, but a trivial stand-alone binary can be big and uses more memory than I would like&lt;/li&gt;
&lt;li&gt;Common Lisp isn&amp;#39;t as elegant as Scheme, but the implementations are more mutually compatible than in the Scheme world&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mouse-83&quot;&gt;Mouse-83&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finally, a programming language with less syntax than Forth!&lt;/li&gt;
&lt;li&gt;Single-letter variables names make it hard to convey their meaning&lt;/li&gt;
&lt;li&gt;Overall, if I wanted a language that was easy to implement, I&amp;#39;d probably opt for Forth, Pascal, or Lisp -- a small increase in complexity is worth unlocking greater readability (easy to say in 2025, I know)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cyber&quot;&gt;Cyber&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Once mature, this could be a fast Lua replacement with more Python-like syntax (and zero-based indexing!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;varyx&quot;&gt;Varyx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; loop only works if there&amp;#39;s a blank line before it&lt;/li&gt;
&lt;li&gt;Arrays appear to be lists under the hood, with slow (O(n)) access&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rye&quot;&gt;Rye&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Very compact code&lt;/li&gt;
&lt;li&gt;Surprisingly fast&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rexx&quot;&gt;Rexx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Logical operator for &amp;quot;exclusive or&amp;quot; is unfortunately the same as C&amp;#39;s &amp;quot;logical and&amp;quot;: &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;And &lt;code&gt;%&lt;/code&gt; is integer division, with &lt;code&gt;//&lt;/code&gt; being remainder (the opposite of what I&amp;#39;ve seen elsewhere)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;nelua&quot;&gt;Nelua&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Always nice to see my code compile down to &amp;lt; 100 KB executables!&lt;/li&gt;
&lt;li&gt;It&amp;#39;s like a smaller Nim, but using Lua syntax&lt;/li&gt;
&lt;li&gt;Mostly &amp;quot;just worked&amp;quot; for me -- very easy to pick up&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Yet more programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-13.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-13.html"/>
<updated>2024-12-29T00:00:00.000Z</updated>
<summary type="text">Another throwaway post with brief notes about programming languages.</summary>
<content type="html">&lt;p&gt;I&amp;#39;m still &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;solving the first 100 Project Euler problems using 100 different programming languages&lt;/a&gt;. For reference: &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;here is code for all my solutions so far&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is basically a throwaway post with brief notes on the languages I&amp;#39;ve tried since &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-12.html&quot;&gt;the last update&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;notes&quot;&gt;Notes&lt;/h1&gt;
&lt;h2 id=&quot;odin&quot;&gt;Odin&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Standard library has a lot of depth&lt;/li&gt;
&lt;li&gt;Yet another capable C successor&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;qbasic&quot;&gt;QBasic&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Honestly, the IDE and integrated help are pretty good!&lt;/li&gt;
&lt;li&gt;Have to use a &lt;code&gt;LONG&lt;/code&gt; to get a 32-bit integer type&lt;/li&gt;
&lt;li&gt;Despite having written many QBasic programs in the 90s, this was the first time I used QBasic &lt;code&gt;FUNCTION&lt;/code&gt;s&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;python&quot;&gt;Python&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python has a standard library function that essentially solves Project Euler problem 80&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;8080-assembly-altair-8800&quot;&gt;8080 assembly (Altair 8800)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To my surprise, this is the first time I&amp;#39;ve heard of binary-coded decimals!&lt;/li&gt;
&lt;li&gt;Actually found a bug in &lt;a href=&quot;https://github.com/simh/simh&quot;&gt;SIMH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Solution easily fits in the 256 bytes of a non-upgraded Altair 8800&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;janet&quot;&gt;Janet&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Having non-list syntax was inconvenient when I wanted to splice into a struct literal&lt;/li&gt;
&lt;li&gt;Very impressive Clojure-like scripting language for less than 1 MB!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hazel&quot;&gt;Hazel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Nice not having to worry about whitespace&lt;/li&gt;
&lt;li&gt;Very slow (50,000+ slower than a trivial native code solution), no random-access data structures&lt;/li&gt;
&lt;li&gt;Hard-coded 20-second time limit on evaluation -- I ended up modifying the time limit in the minified JavaScript source file, as a work around&lt;/li&gt;
&lt;li&gt;I like the mix of ML and C-style syntax&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ada&quot;&gt;Ada&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Seems like a lot of boilerplate, but that might be intentional&lt;/li&gt;
&lt;li&gt;I wasn&amp;#39;t sure how big Ada.Containers.Count_Type could be and it turns out it&amp;#39;s implementation defined -- not what I expected!&lt;/li&gt;
&lt;li&gt;Structure and syntax is similar to Pascal&lt;/li&gt;
&lt;li&gt;Can only have one top-level procedure per file?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;shen&quot;&gt;Shen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lots of details are in the &amp;quot;Shen Book&amp;quot;, but it only seems to be available in a scanned, non-OCR&amp;#39;d JPEG format&lt;/li&gt;
&lt;li&gt;None of the implementations I tried seemed to  include the standard library...?&lt;/li&gt;
&lt;li&gt;Having Prolog embedded in a Lisp sounded great, but I found it awkward to use since it&amp;#39;s lacking Prolog&amp;#39;s standard library&lt;/li&gt;
&lt;li&gt;I was skeptical of the lack of quote/quasiquote in a Lisp, but I didn&amp;#39;t actually end up needing either of them!&lt;/li&gt;
&lt;li&gt;I feel like there are some intriguing ideas in Shen, but overall I found Shen somewhat impenetrable&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kitten&quot;&gt;Kitten&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I liked the idea of a simple, functional, statically typed concatenative language&lt;/li&gt;
&lt;li&gt;Switching between Forth-style syntax and C (or Python) syntax feels odd (and I don&amp;#39;t like all the commas)&lt;/li&gt;
&lt;li&gt;Seemed to use a lot of memory&lt;/li&gt;
&lt;li&gt;Logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; have no special meaning, so short-circuiting is implemented using (explicit) anonymous functions&lt;/li&gt;
&lt;li&gt;Fun to play with!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lo&quot;&gt;LO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dislike &lt;code&gt;0 as i32&lt;/code&gt; for a signed integer type zero (but I discovered that &lt;code&gt;+0&lt;/code&gt; is equivalent)&lt;/li&gt;
&lt;li&gt;Vectors return pointers, so the underlying element can change!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;bend&quot;&gt;Bend&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Number types are only 24-bit (probably normal for GPU work, but pretty small for Project Euler!)&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t seem to run anything on a VM with &amp;lt; 8 GB of memory&lt;/li&gt;
&lt;li&gt;Have to be &lt;em&gt;very&lt;/em&gt; careful about data types -- there is &lt;em&gt;no&lt;/em&gt; type-checking at all!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;v&quot;&gt;V&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fast to compile and run&lt;/li&gt;
&lt;li&gt;Easy to pick up if you&amp;#39;ve used a C-like language&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;futhark&quot;&gt;Futhark&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Just by using &lt;code&gt;map&lt;/code&gt;, I was able to get a parallel program with no extra effort&lt;/li&gt;
&lt;li&gt;Confirmed the &lt;code&gt;multicore&lt;/code&gt; build ran twice as fast on my dual-core laptop!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lobster&quot;&gt;Lobster&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy to write code, thanks to simple and terse syntax&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t get &amp;quot;exceptions&amp;quot; working -- never figured out why&lt;/li&gt;
&lt;li&gt;Didn&amp;#39;t have to specify any types, which was convenient&lt;/li&gt;
&lt;li&gt;I was excited to see how fast a static, compiled solution was, but for some reason it was slower than Python&lt;/li&gt;
&lt;li&gt;Overall, it felt a bit like Nim&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dylan&quot;&gt;Dylan&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Building a &amp;quot;hello world&amp;quot; program the first time took minutes and required creating multiple text files&lt;/li&gt;
&lt;li&gt;Multiple dispatch, macros, etc. make this feel like Common Lisp, but with conventional syntax -- I&amp;#39;m surprised Dylan wasn&amp;#39;t more popular, honestly!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;quackery&quot;&gt;Quackery&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ancillary stacks are a nice addition to stack-based languages&lt;/li&gt;
&lt;li&gt;Feels like a cross between Forth and Lisp, but with arrays instead of lists&lt;/li&gt;
&lt;li&gt;Quackery doesn&amp;#39;t have variables... but I kind of wish it did&lt;/li&gt;
&lt;li&gt;The foreword from The Book of Quackery was a fun read&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Python is the new BASIC</title>
<id>https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html"/>
<updated>2024-11-20T00:00:00.000Z</updated>
<summary type="text">What makes Python the BASIC of today?</summary>
<content type="html">&lt;p&gt;(Note: This post has been &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html&quot;&gt;updated to remove irrelevant snark&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;As far as programming languages go, &lt;a href=&quot;https://en.wikipedia.org/wiki/BASIC&quot;&gt;BASIC&lt;/a&gt; (&amp;quot;Beginners&amp;#39; All-purpose Symbolic Instruction Code&amp;quot;) is... &lt;strong&gt;not a language I would choose today&lt;/strong&gt;. Granted, when it was originally developed in the 60s, line numbers and single-character identifiers were &lt;em&gt;an improvement&lt;/em&gt;. But in its heyday (which I&amp;#39;m going to claim, without evidence, was in the late 70s and early 80s), there were other options I like better (Pascal, Lisp, Forth, even C!). Yet, &lt;strong&gt;BASIC was everywhere! It &lt;em&gt;was&lt;/em&gt; the interface for many old computers, like the Commodore 64.&lt;/strong&gt; Why? I&amp;#39;d say (again, without evidence) it&amp;#39;s because BASIC was designed to be usable by anyone--not just experienced programmers.&lt;/p&gt;
&lt;p&gt;Today, there&amp;#39;s a &lt;em&gt;different&lt;/em&gt; language which enjoys a strong following, often as a first language. That language is Python.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python is the new BASIC.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;back-to-basic&quot;&gt;Back to BASIC&lt;/h1&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;BASIC was created at Dartmouth College in 1963 by John G. Kemeny and Thomas E. Kurtz (see &lt;a href=&quot;https://computerhistory.org/blog/in-memoriam-thomas-e-kurtz-1928-2024/&quot;&gt;In Memoriam: Thomas E. Kurtz, 1928–2024&lt;/a&gt;). If you want a historical account, there is an &lt;a href=&quot;https://podcasts.apple.com/us/podcast/keeping-things-basic/id1459202600?i=1000502282724&quot;&gt;Advent of Computing podcast episode about BASIC&lt;/a&gt; that is excellent (as is the entire podcast).&lt;/p&gt;
&lt;h2 id=&quot;commodore-basic&quot;&gt;Commodore BASIC&lt;/h2&gt;
&lt;p&gt;My personal history with BASIC goes back to &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../vintage-computing/40-year-old-dev-environment.html&quot;&gt;the first computer I ever used, the Commodore 64&lt;/a&gt;. That computer booted directly into BASIC. Although I didn&amp;#39;t realize it at the time, to launch programs, you had to type in BASIC code. &lt;strong&gt;Every user was secretly a programmer!&lt;/strong&gt; I don&amp;#39;t think I wrote any programs beyond &lt;code&gt;10 PRINT &amp;quot;HAHA&amp;quot;&lt;/code&gt;; &lt;code&gt;20 GOTO 10&lt;/code&gt;, but I suppose I at least learned about commands and quotation marks.&lt;/p&gt;
&lt;h2 id=&quot;qbasic&quot;&gt;QBasic&lt;/h2&gt;
&lt;p&gt;At some point, I decided that I wanted to make a computer do whatever I wanted, so I needed to learn how to program. Fortunately, my &lt;a href=&quot;https://en.wikipedia.org/wiki/MS-DOS&quot;&gt;MS-DOS&lt;/a&gt; computer included a development environment--impressively fully-featured, in retrospect--named &lt;a href=&quot;https://en.wikipedia.org/wiki/QBasic&quot;&gt;QBasic&lt;/a&gt;. Yes, BASIC (specifically QBasic) was the first programming language I attempted to learn. I don&amp;#39;t think I ever discovered subroutines in QBasic, but I did at least learn about conditionals, loops, and arrays.&lt;/p&gt;
&lt;p&gt;Regardless, BASIC served its purpose. I, with no prior experience, learned how to write some simple programs without throwing up my hands in despair and swearing off computers forever. &lt;strong&gt;I guess I&amp;#39;m a BASIC success story!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As an aside, I recently found an old box of floppy disks, including one &amp;quot;double density&amp;quot; disk with my first name written on the label. That disk contained several programs I had written using QBasic, circa 1997. The code was... not good--again, I hadn&amp;#39;t discovered subroutines yet.&lt;/p&gt;
&lt;h1 id=&quot;back-to-python&quot;&gt;Back to Python&lt;/h1&gt;
&lt;p&gt;Although not perfect, Python has a lot going for it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;#39;s &lt;strong&gt;ubiquitous&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It comes with &amp;quot;batteries included&amp;quot;&lt;/strong&gt;, i.e. a comprehensive standard library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It&amp;#39;s simple&lt;/strong&gt; (or, at least, you can pretend it is, for casual use)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Python is often good enough.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;why-python-is-the-new-basic&quot;&gt;Why Python is the new BASIC&lt;/h2&gt;
&lt;p&gt;But why is Python the new BASIC? The answer is simple: &lt;strong&gt;Python is the new BASIC because Python is the language that new programmers always seem to use&lt;/strong&gt;. It&amp;#39;s reached critical mass. Python has won!&lt;/p&gt;
&lt;p&gt;Of course, that is more of an observation than a reason. I honestly have no idea why people originally gravitated to Python (apologies for implying otherwise), but if I had to guess it would be some combination of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python emerged when the world desperately needed a scripting language that was more approachable than &lt;a href=&quot;https://www.perl.org/&quot;&gt;Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python often includes everything you need, right in the standard library&lt;/li&gt;
&lt;li&gt;Python was math-friendly enough to gain a foothold in physics, finance, etc. research, thus broadening its ecosystem and influence&lt;/li&gt;
&lt;li&gt;Python smartly borrowed convenient features from more complex languages, while retaining a simple look&lt;/li&gt;
&lt;li&gt;Python was never owned by a litigious corporation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words: &lt;strong&gt;some combination of smart design, community management, and happenstance&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;definitive-proof-of-pythons-dominance&quot;&gt;Definitive proof of Python&amp;#39;s dominance&lt;/h2&gt;
&lt;p&gt;Despite preferred other programming languages for my entire adult life, &lt;strong&gt;I recently gave in and wrote a personal utility program in Python&lt;/strong&gt; because I knew Python would have everything I needed and I had confidence that Python was entrenched enough that I&amp;#39;d still be able to use my program for the foreseeable future.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If even a Python-avoider like me defaults to using Python, then I think it&amp;#39;s pretty clear that Python has taken over the world, just as BASIC once did.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One parting thought: how long will Python&amp;#39;s reign last?&lt;/p&gt;
</content>
</entry>
<entry>
<title>Three quarters of the way to 100 programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-12.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-12.html"/>
<updated>2024-10-31T00:00:00.000Z</updated>
<summary type="text">Just some more notes on programming languages. And also my first failure!</summary>
<content type="html">&lt;p&gt;I recently resumed &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;solving the first 100 Project Euler problems using 100 different programming languages&lt;/a&gt;. For reference: &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;here is code for all my solutions so far&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of note, &lt;strong&gt;I failed to solve a problem using Micro-Lisp on the Commodore 64&lt;/strong&gt;. I think it would have been &lt;em&gt;possible&lt;/em&gt; to solve the problem (even despite the lack of cons cell mutation), but the Commodore 64 keyboard design can lead to two different space characters being emitted when you hit the space bar, depending on timing, and Micro-Lisp only handled one of those characters. The result is that I&amp;#39;d have code that looked correct, but wouldn&amp;#39;t compile. I gave up.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I also finally decided to solve a problem in C&lt;/strong&gt;. On the surface, this might seem pointless since I already know C, but &lt;strong&gt;it gave me an excuse to try calling C code from Zig&lt;/strong&gt; (a language I hadn&amp;#39;t tried before). Overall, the Zig toolchain is extremely impressive! It&amp;#39;s probably the most convenient C (and C++) compiler in existence. And Zig seemed fine, too.&lt;/p&gt;
&lt;p&gt;Lastly, &lt;strong&gt;I got around to solving a problem using Prolog. It was worth the wait!&lt;/strong&gt; Expect a post on it eventually.&lt;/p&gt;
&lt;p&gt;Without further rambling, here are my notes:&lt;/p&gt;
&lt;h1 id=&quot;notes&quot;&gt;Notes&lt;/h1&gt;
&lt;h2 id=&quot;g-pascal-on-a-commodore-64&quot;&gt;G-Pascal (on a Commodore 64)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Only two types: integer and character (&amp;quot;char&amp;quot;)&lt;/li&gt;
&lt;li&gt;No pointers or references -- instead use &lt;code&gt;addr := address(array)&lt;/code&gt; and index memory directly with &lt;code&gt;mem[addr]&lt;/code&gt; (integer) or &lt;code&gt;memc[addr]&lt;/code&gt; (char)&lt;/li&gt;
&lt;li&gt;Docs for newer iteration: &lt;a href=&quot;http://www.gammon.com.au/G-Pascal/pascal_compiler.htm&quot;&gt;http://www.gammon.com.au/G-Pascal/pascal_compiler.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;Note that arrays grow downwards in memory, not upwards.&amp;quot;&lt;/li&gt;
&lt;li&gt;Does &lt;em&gt;not&lt;/em&gt; compile to machine code!&lt;/li&gt;
&lt;li&gt;Built-in line-based editor includes multi-line insert, search and replace, etc. -- a big step up from Commodore BASIC!&lt;/li&gt;
&lt;li&gt;Without native compilation or an interactive environment, this wouldn&amp;#39;t be my first choice for programming on a Commodore 64 (but still better than BASIC, thanks to named procedures and functions!)&lt;/li&gt;
&lt;li&gt;Roughly 7x slower than equivalent C, for my solution (N.B. G-Pascal uses a VM and C compiles to native code)&lt;/li&gt;
&lt;li&gt;I didn&amp;#39;t notice a way to enter blank lines, so the resulting code looks cluttered.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;micro-lisp-on-a-commodore-64&quot;&gt;Micro-Lisp (on a Commodore 64)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Shift+space &lt;em&gt;looks like&lt;/em&gt; a regular space, but is treated as a different character, leading to confusing errors on lines that look correct&lt;/li&gt;
&lt;li&gt;No built-in macros&lt;/li&gt;
&lt;li&gt;No way to modify cons cells&lt;/li&gt;
&lt;li&gt;Line-based editing of Lisp on a 40 column screen was unpleasant (unclear if worse than BASIC editing?)&lt;/li&gt;
&lt;li&gt;Indentation was getting lost on input&lt;/li&gt;
&lt;li&gt;Functions aren&amp;#39;t first class objects&lt;/li&gt;
&lt;li&gt;Unfortunately, you have to choose between image-based development or entering source code in lines (a la Commodore BASIC) -- you can&amp;#39;t easily develop interactively &lt;em&gt;and still save your source code&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Sadly, I gave up on C64 Micro-Lisp due to the issues and missing features noted above -- that&amp;#39;s not to say I wasn&amp;#39;t impressed to be using Lisp on a Commodore 64!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;scheme&quot;&gt;Scheme&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;R6RS appeared to be incompatible with R5RS and R7RS for a &amp;quot;hello world&amp;quot; program&lt;/li&gt;
&lt;li&gt;Chibi-Scheme&amp;#39;s rational numbers were hundreds of times slower than Chez Scheme/Racket&lt;/li&gt;
&lt;li&gt;In theory, I should prefer Scheme to Common Lisp (fewer concepts overall, better naming in the standard library), but I wish the different Scheme revisions and implementations were more compatible with one other&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;bcpl&quot;&gt;BCPL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The language is conceptually simple, but the syntax was foreign enough that I found it difficult to write&lt;/li&gt;
&lt;li&gt;Only having a single word-sized data type feels limiting--but I guess that&amp;#39;s the price you pay for a tiny compiler&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;matlab&quot;&gt;MATLAB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Everything I tried Just Worked!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;moonscript&quot;&gt;MoonScript&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I like the idea of Lua without so much keyword noise&lt;/li&gt;
&lt;li&gt;But there are some weird syntactical quirks around function arguments within table constructors that lead me to think that requiring parentheses around function arguments might have been better&lt;/li&gt;
&lt;li&gt;Seems like &amp;quot;Lua written in Python&amp;quot; -- oh, the docs actually say it&amp;#39;s inspired by CoffeeScript&lt;/li&gt;
&lt;li&gt;I kept wanting to omit the commas between function arguments for some reason&lt;/li&gt;
&lt;li&gt;Kind of wish there were built-in functions for appending to a list, concatenating lists, reducing lists, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;fennel&quot;&gt;Fennel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I like Lisp and have used Lua a fair amount, so I expected to like combining the two&lt;/li&gt;
&lt;li&gt;But I found mixing Lua semantics and syntax with Lisp was fairly confusing -- I could never decide whether I needed brackets in a macro or not&lt;/li&gt;
&lt;li&gt;Having Macros for Lua is fun! And Fennel papers over some annoyances in Lua&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;erde&quot;&gt;Erde&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Mostly Lua with braces instead of &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Erde still interprets variables with typos in their names as globals -- I wish this was fixed&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;purescript&quot;&gt;PureScript&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;http://try.purescript.org/&quot;&gt;Try PureScript&lt;/a&gt; example renders HTML from code, but I &lt;em&gt;really&lt;/em&gt; dislike the amount of repetition and the lack of support for trailing commas&lt;/li&gt;
&lt;li&gt;First result when searching for &amp;quot;sqrt&amp;quot; in Pursuit is in a package that turned out to be deprecated&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t appear to include a useful standard library by default?&lt;/li&gt;
&lt;li&gt;I couldn&amp;#39;t figure out how to enforce a non-empty array via the type system (&lt;code&gt;Data.NonEmpty&lt;/code&gt;? &lt;code&gt;Data.Array.NonEmpty&lt;/code&gt;?)&lt;/li&gt;
&lt;li&gt;Slow compilation&lt;/li&gt;
&lt;li&gt;Seems to warn whenever types aren&amp;#39;t explicitly stated... so why bother with type inference?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ruby&quot;&gt;Ruby&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Very handy having generators, indefinite ranges, and rational numbers&lt;/li&gt;
&lt;li&gt;Feels pragmatic&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;reason&quot;&gt;Reason&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Official API documentation&amp;#39;s search function can&amp;#39;t find &lt;code&gt;float_of_int&lt;/code&gt; (a function that is mentioned in some error messages I received)&lt;/li&gt;
&lt;li&gt;Line comments (&lt;code&gt;//&lt;/code&gt;) result in syntax errors in the &lt;a href=&quot;https://reasonml.github.io/en/try&quot;&gt;in-browser implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Also in the browser, error line numbers sometimes aren&amp;#39;t correct (and &amp;quot;this has type X but somewhere wanted Y&amp;quot; isn&amp;#39;t helpful without correct line numbers!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;t3x0&quot;&gt;T3X/0&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Has two distinct conditionals, &lt;code&gt;IF&lt;/code&gt; and &lt;code&gt;IE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pascal syntax and BCPL semantics sounds like a good combination for a minimal or bootstrapping compiler!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;assemblyscript&quot;&gt;AssemblyScript&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AssemblyScript&amp;#39;s landing page has the best developer experience I&amp;#39;ve encountered (I suspect it is most of Visual Studio Code embedded, along with type info)&lt;/li&gt;
&lt;li&gt;I don&amp;#39;t like reusing TypeScript&amp;#39;s file extension&lt;/li&gt;
&lt;li&gt;How does its &amp;quot;standard library&amp;quot; get included? I assume the parts that are used are compiled into each WASM blob&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;minilang&quot;&gt;MiniLang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Couldn&amp;#39;t find any math functions, e.g. for finding square roots&lt;/li&gt;
&lt;li&gt;Very nice IDE available on &lt;a href=&quot;https://www.ryugod.com/pages/ide/minilang&quot;&gt;ryugod.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;c&quot;&gt;C&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Had to use C99 to get an official 64-bit integer type&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;zig&quot;&gt;Zig&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Having unused variables be an error when trying to narrow down problems is annoying...&lt;/li&gt;
&lt;li&gt;Being able to compile and reuse C code is convenient!&lt;/li&gt;
&lt;li&gt;Very impressive for a ~40 MB download&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;clojure&quot;&gt;Clojure&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Slow to compile and run&lt;/li&gt;
&lt;li&gt;Took me a long time to figure out that &lt;code&gt;(Math/floor ...)&lt;/code&gt; was the simplest way to invoke the standard library&amp;#39;s math functions&lt;/li&gt;
&lt;li&gt;Hopefully I don&amp;#39;t get a bill in the mail from Oracle for using the JVM&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;raku&quot;&gt;Raku&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Handy functional utilities like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatmap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;But some of those functional utilities have odd names like &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;elems&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;vala&quot;&gt;Vala&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Raw arrays have no bounds checking!&lt;/li&gt;
&lt;li&gt;Collection types are implemented in a separate library&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;prolog&quot;&gt;Prolog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In SWI Prolog, you can interactively add facts/rules by typing &lt;code&gt;[user]&lt;/code&gt;, entering information, and then sending &amp;quot;end of file&amp;quot; (Ctrl+D on Linux, possibly Ctrl+Z on Windows)&lt;/li&gt;
&lt;li&gt;SWI-Prolog treats strings in a way that is incompatible with many tutorials I found on the web -- namely, &lt;a href=&quot;https://www.swi-prolog.org/pldoc/man?section=string&quot;&gt;a double-quoted string is a separate data type than a back-ticked string&lt;/a&gt;, which (as far as I understand) uses the traditional data type of a list of character codes (which, I hope, are now actually Unicode code points)&lt;/li&gt;
&lt;li&gt;It took me a &lt;em&gt;really&lt;/em&gt; long time to figure out that &lt;code&gt;use_module(library(dcg/basics)).&lt;/code&gt; should have been &lt;code&gt;:- use_module(library(dcg/basics))&lt;/code&gt; -- the former doesn&amp;#39;t do anything useful (but doesn&amp;#39;t emit any warnings), whereas the latter actually brings a module into scope&lt;/li&gt;
&lt;li&gt;Accessing documentation via &lt;code&gt;help&lt;/code&gt; loads modules as a side effect&lt;/li&gt;
&lt;li&gt;The actual Sudoku-solving part was just a few lines of readable code&lt;/li&gt;
&lt;li&gt;Getting to use Prolog&amp;#39;s declarative approach was worthwhile, despite my difficulties getting things going&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
</feed>
