<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Schemescape</title>
<id>https://log.schemescape.com/</id>
<link rel="self" href="https://log.schemescape.com/feed.xml"/>
<link rel="alternate" href="https://log.schemescape.com/"/>
<author>
<name>Schemescape</name>
</author>
<updated>2025-01-18T15:15:45.656Z</updated>

<entry>
<title>Beyond 100 programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/beyond-100-languages.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/beyond-100-languages.html"/>
<updated>2025-01-18T00:00:00.000Z</updated>
<summary type="text">Here&apos;s a bunch of interesting programming languages that I didn&apos;t get around to trying out.</summary>
<content type="html">&lt;p&gt;While &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;sampling 100 different programming languages&lt;/a&gt;, I compiled a list of intriguing programming languages. Although I tested out a lot of languages, there are still many I never got around to--not because I didn&amp;#39;t think they were promising--sometimes they just didn&amp;#39;t match what I wanted at the time or they were too similar to other languages I&amp;#39;d recently used.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re looking for inspiration for your own programming language experiments, consider these! I have &lt;strong&gt;bolded&lt;/strong&gt; the ones I personally was most interested in.&lt;/p&gt;
&lt;h1 id=&quot;object-oriented&quot;&gt;Object-oriented&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://pharo.org/&quot;&gt;Pharo&lt;/a&gt;: being a Smalltalk, it includes an entire IDE&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.squirrel-lang.org/&quot;&gt;Squirrel&lt;/a&gt;: object-oriented scripting language for games&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crystal-lang.org/&quot;&gt;Crystal&lt;/a&gt;: Ruby-like compiled language&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://iolanguage.org/&quot;&gt;io&lt;/a&gt;: minimal, pure object-oriented language&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;functional&quot;&gt;Functional&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logo_(programming_language)&quot;&gt;Logo&lt;/a&gt;: educational language from the 60s, with turtle graphics&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://elixir-lang.org/&quot;&gt;Elixir&lt;/a&gt;: Erlang-compatible functional language&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://koka-lang.github.io/koka/doc/index.html&quot;&gt;Koka&lt;/a&gt;: functional language with effect types and handlers&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://scrapscript.org/&quot;&gt;Scrapscript&lt;/a&gt;: sounds kind of like Unison on IPFS?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://gren-lang.org/&quot;&gt;Gren&lt;/a&gt;: compiles to JavaScript&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://eyg.run/&quot;&gt;EYG&lt;/a&gt;: provides a structural editor&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;lisp&quot;&gt;Lisp&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.newlisp.org/&quot;&gt;newLISP&lt;/a&gt;: reimagined, batteries-included Lisp&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Emacs_Lisp&quot;&gt;Emacs Lisp&lt;/a&gt;: (probably) the world&amp;#39;s most popular Lisp (note: not purely functional, as far as I understand)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://basilisp.readthedocs.io/en/latest/gettingstarted.html&quot;&gt;Basilisp&lt;/a&gt;: Clojure-inspired Lisp that targets Python&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jank-lang.org/&quot;&gt;jank&lt;/a&gt;: Clojure-inspired language that is compiled via LLVM&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/yuriy-chumak/OL&quot;&gt;Otus Lisp&lt;/a&gt;: very small Scheme implementation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coalton-lang/coalton&quot;&gt;Coalton&lt;/a&gt;: statically-typed Lisp&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;logic-programming&quot;&gt;Logic programming&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.curry-language.org/&quot;&gt;Curry&lt;/a&gt;: functional logic programming language&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;assembly&quot;&gt;Assembly&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CHIP-8&quot;&gt;CHIP-8&lt;/a&gt;: the world&amp;#39;s oldest fantasy console?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;imperative-compiled&quot;&gt;Imperative (compiled)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Oberon-2&quot;&gt;Oberon-2&lt;/a&gt;: Pascal-like, possibly with a single-pass compiler?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.red-lang.org/&quot;&gt;Red&lt;/a&gt;: systems-level, but inspired by Rebol&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://vale.dev/&quot;&gt;Vale&lt;/a&gt;: memory-safe language that is simpler than Rust (but currently incomplete)&lt;/strong&gt; -- I really wanted to try this one, but I think the compiler required Java and I didn&amp;#39;t have a working Java setup at the time&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://borgo-lang.github.io/&quot;&gt;Borgo&lt;/a&gt;: built on Go, but with a more expressive language&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.modular.com/mojo&quot;&gt;Mojo&lt;/a&gt;: Python, but compiled -- note: closed source, as far as I can tell&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sr.ht/~duangle/scopes/&quot;&gt;Scopes&lt;/a&gt;: another &amp;quot;better C&amp;quot;? -- note: I consider this to be a good thing!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://dlang.org/&quot;&gt;D&lt;/a&gt;: C++-alternative with an optional garbage collector (and tons of other features)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/MUMPS&quot;&gt;MUMPS&lt;/a&gt;: &amp;quot;Massachusetts General Hospital Utility Multi-Programming System&amp;quot; from the 60s&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/travisdoor/bl&quot;&gt;bl&lt;/a&gt;: &amp;quot;simple programming language created for fun&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SerenityOS/jakt&quot;&gt;Jakt&lt;/a&gt;: programming language developed as part of the &lt;a href=&quot;https://serenityos.org/&quot;&gt;SerenityOS project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/xorvoid/sectorc&quot;&gt;SectorC&lt;/a&gt;: a partial C compiler that (somehow) fits in a 512-byte boot sector&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.beeflang.org/&quot;&gt;Beef&lt;/a&gt;: created for game development, includes a full (Windows-only) IDE&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PL/0&quot;&gt;PL/0&lt;/a&gt;: educational programming language by the creator of Pascal&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freepascal.org/&quot;&gt;FreePascal&lt;/a&gt;: modern day Pascal that supports many targets&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;imperative-interpreted&quot;&gt;Imperative (interpreted)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PILOT&quot;&gt;PILOT&lt;/a&gt;: imperative language from the 60s&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/antimony-lang/antimony&quot;&gt;Antimony&lt;/a&gt;: aims to be simple&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://elv.sh/&quot;&gt;Elvish&lt;/a&gt;: modern shell scripting language&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://amber-lang.com/&quot;&gt;Amber&lt;/a&gt;: compiles to Bash&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://miniscript.org/&quot;&gt;MiniScript&lt;/a&gt;: a small, new, embeddable scripting language (think: a modern Lua)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;concatenative&quot;&gt;Concatenative&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Joy_(programming_language)&quot;&gt;Joy&lt;/a&gt;: purely functional, but supposedly similar to Forth&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cesarblum/sectorforth&quot;&gt;SectorForth&lt;/a&gt;: Forth implementation that bootstraps from a 512-byte boot sector&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/luke8086/nf&quot;&gt;nf&lt;/a&gt;: minimal interactive programming language&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;data-driven&quot;&gt;Data-driven&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matz/streem&quot;&gt;Streem&lt;/a&gt;: prototype stream-based programming language&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>I apologize to the Python ecosystem</title>
<id>https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html"/>
<updated>2025-01-17T00:00:00.000Z</updated>
<summary type="text">I shouldn&apos;t disparage Python or, really, any programming language. Let me try and right my wrongs.</summary>
<content type="html">&lt;p&gt;Today, I discovered that my &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html&quot;&gt;Python is the new BASIC&lt;/a&gt; post had been discussed on a popular site. It&amp;#39;s always a joy when people take an interest in your work, right? Well...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In the comments, I was rightly roasted.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consider this post an apology and a promise to do better.&lt;/p&gt;
&lt;p&gt;(Note: I went back and edited the post in question. This commentary applies to the original content.)&lt;/p&gt;
&lt;h1 id=&quot;problems-with-my-post&quot;&gt;Problems with my post&lt;/h1&gt;
&lt;p&gt;First off, &lt;strong&gt;the overall tone of the post crossed the line from criticism to snark--or maybe even scorn&lt;/strong&gt;. In my head, some of the jabs were just good-natured ribbing, but upon re-reading from the perspective of an internet stranger, it&amp;#39;s just oozing with derision. If I&amp;#39;m going to post something publicly, I should remember that &lt;strong&gt;the audience is not myself, but just anyone who happens to come along&lt;/strong&gt; (except AI scrapers, per robots.txt).&lt;/p&gt;
&lt;p&gt;Additionally, I didn&amp;#39;t clearly articulate my complaints with Python. I think some them are legitimate but, besides being better explained elsewhere, &lt;strong&gt;my issues are not even that relevant&lt;/strong&gt;. The things I like about Python outweigh the things I dislike. And &lt;strong&gt;there is a huge advantage to having a common programming language that everyone understands&lt;/strong&gt; (even if only the basics). I like keeping posts short, and a good way to do that is to stay on topic and cut out (most of) the snark.&lt;/p&gt;
&lt;h1 id=&quot;not-just-python&quot;&gt;Not just Python&lt;/h1&gt;
&lt;p&gt;And it&amp;#39;s not just Python. I&amp;#39;ve also whined about perceived bloat on, ahem, more than one occasion. I&amp;#39;ve complained about compilers not working on the first try. And so on. &lt;strong&gt;There isn&amp;#39;t any value in posting shallow dismissals of projects that took enormous amounts of work to produce&lt;/strong&gt;. I&amp;#39;ll try to stop doing that. &lt;strong&gt;Even if I can&amp;#39;t always make the world better, I can at least try to not make it worse&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Mea culpa.&lt;/p&gt;
</content>
</entry>
<entry>
<title>New year, new programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-14.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-14.html"/>
<updated>2025-01-16T00:00:00.000Z</updated>
<summary type="text">I finished my dumb project.</summary>
<content type="html">&lt;p&gt;I just finished &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;solving the first 100 Project Euler problems using 100 different programming languages&lt;/a&gt;. For reference: &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;here is all the code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I&amp;#39;m planning to write up a summary post at some point&lt;/strong&gt;, but this is just my last throwaway post with brief notes on the languages I&amp;#39;ve tried since &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-13.html&quot;&gt;the last update&lt;/a&gt;. Rye and Nelua were the stars of this round.&lt;/p&gt;
&lt;h1 id=&quot;notes&quot;&gt;Notes&lt;/h1&gt;
&lt;h2 id=&quot;ats&quot;&gt;ATS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I didn&amp;#39;t understand some of the syntax, e.g. &lt;code&gt;:&amp;lt;cloref1&amp;gt;&lt;/code&gt; and &lt;code&gt;t@ype&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Error messages were sometimes surprising, e.g. &lt;code&gt;the syntactic entity [impqi0de] is needed.&lt;/code&gt; -- what is &lt;code&gt;[impqi0de]&lt;/code&gt;???&lt;/li&gt;
&lt;li&gt;Another example: copy-pasting &lt;code&gt;fn square (x: double): double = x * x&lt;/code&gt; from the official documentation yields &lt;code&gt;error: ‘PMVtmpltcstmat’ undeclared (first use in this function)&lt;/code&gt; -- solutiong was to put &lt;code&gt;#include &amp;quot;share/atspre_staload.hats&amp;quot;&lt;/code&gt; at the top of the file (my mistake--but the error was unhelpful)&lt;/li&gt;
&lt;li&gt;I didn&amp;#39;t attempt to include any proofs in my code, so I didn&amp;#39;t really leverage ATS to its fullest (or, really, any) extent&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;pre-scheme&quot;&gt;Pre-Scheme&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using the built-in &lt;code&gt;errors&lt;/code&gt; enum resulted in compilation errors&lt;/li&gt;
&lt;li&gt;Static typing in Scheme is awkward because I couldn&amp;#39;t find a clean way to not return anything&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t find an example of asserting types&lt;/li&gt;
&lt;li&gt;Unstripped solution binary was ~50 KB (C is great!)&lt;/li&gt;
&lt;li&gt;Didn&amp;#39;t actually bother deallocating memory (C is great!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;common-lisp&quot;&gt;Common Lisp&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Interactive development is helpful (and fun)&lt;/li&gt;
&lt;li&gt;So many cryptic/inconsistent names, e.g. &lt;code&gt;fmakunbound&lt;/code&gt;, &lt;code&gt;mapcon&lt;/code&gt;, &lt;code&gt;clrhash&lt;/code&gt;, &lt;code&gt;prin1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; vs. &lt;code&gt;equalp&lt;/code&gt; vs. &lt;code&gt;equal&lt;/code&gt; vs. &lt;code&gt;eql&lt;/code&gt; vs. &lt;code&gt;eq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SBCL is fast, but a trivial stand-alone binary can be big and uses more memory than I would like&lt;/li&gt;
&lt;li&gt;Common Lisp isn&amp;#39;t as elegant as Scheme, but the implementations are more mutually compatible than in the Scheme world&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mouse-83&quot;&gt;Mouse-83&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Finally, a programming language with less syntax than Forth!&lt;/li&gt;
&lt;li&gt;Single-letter variables names make it hard to convey their meaning&lt;/li&gt;
&lt;li&gt;Overall, if I wanted a language that was easy to implement, I&amp;#39;d probably opt for Forth, Pascal, or Lisp -- a small increase in complexity is worth unlocking greater readability (easy to say in 2025, I know)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cyber&quot;&gt;Cyber&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Once mature, this could be a fast Lua replacement with more Python-like syntax (and zero-based indexing!)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;varyx&quot;&gt;Varyx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt; loop only works if there&amp;#39;s a blank line before it&lt;/li&gt;
&lt;li&gt;Arrays appear to be lists under the hood, with slow (O(n)) access&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rye&quot;&gt;Rye&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Very compact code&lt;/li&gt;
&lt;li&gt;Surprisingly fast&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rexx&quot;&gt;Rexx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Logical operator for &amp;quot;exclusive or&amp;quot; is unfortunately the same as C&amp;#39;s &amp;quot;logical and&amp;quot;: &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;And &lt;code&gt;%&lt;/code&gt; is integer division, with &lt;code&gt;//&lt;/code&gt; being remainder (the opposite of what I&amp;#39;ve seen elsewhere)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;nelua&quot;&gt;Nelua&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Always nice to see my code compile down to &amp;lt; 100 KB executables!&lt;/li&gt;
&lt;li&gt;It&amp;#39;s like a smaller Nim, but using Lua syntax&lt;/li&gt;
&lt;li&gt;Mostly &amp;quot;just worked&amp;quot; for me -- very easy to pick up&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Yet more programming languages</title>
<id>https://log.schemescape.com/posts/programming-languages/100-languages-13.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/100-languages-13.html"/>
<updated>2024-12-29T00:00:00.000Z</updated>
<summary type="text">Another throwaway post with brief notes about programming languages.</summary>
<content type="html">&lt;p&gt;I&amp;#39;m still &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages.html&quot;&gt;solving the first 100 Project Euler problems using 100 different programming languages&lt;/a&gt;. For reference: &lt;a href=&quot;https://github.com/jaredkrinke/100-languages&quot;&gt;here is code for all my solutions so far&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is basically a throwaway post with brief notes on the languages I&amp;#39;ve tried since &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/100-languages-12.html&quot;&gt;the last update&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&quot;notes&quot;&gt;Notes&lt;/h1&gt;
&lt;h2 id=&quot;odin&quot;&gt;Odin&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Standard library has a lot of depth&lt;/li&gt;
&lt;li&gt;Yet another capable C successor&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;qbasic&quot;&gt;QBasic&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Honestly, the IDE and integrated help are pretty good!&lt;/li&gt;
&lt;li&gt;Have to use a &lt;code&gt;LONG&lt;/code&gt; to get a 32-bit integer type&lt;/li&gt;
&lt;li&gt;Despite having written many QBasic programs in the 90s, this was the first time I used QBasic &lt;code&gt;FUNCTION&lt;/code&gt;s&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;python&quot;&gt;Python&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python has a standard library function that essentially solves Project Euler problem 80&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;8080-assembly-altair-8800&quot;&gt;8080 assembly (Altair 8800)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To my surprise, this is the first time I&amp;#39;ve heard of binary-coded decimals!&lt;/li&gt;
&lt;li&gt;Actually found a bug in &lt;a href=&quot;https://github.com/simh/simh&quot;&gt;SIMH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Solution easily fits in the 256 bytes of a non-upgraded Altair 8800&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;janet&quot;&gt;Janet&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Having non-list syntax was inconvenient when I wanted to splice into a struct literal&lt;/li&gt;
&lt;li&gt;Very impressive Clojure-like scripting language for less than 1 MB!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hazel&quot;&gt;Hazel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Nice not having to worry about whitespace&lt;/li&gt;
&lt;li&gt;Very slow (50,000+ slower than a trivial native code solution), no random-access data structures&lt;/li&gt;
&lt;li&gt;Hard-coded 20-second time limit on evaluation -- I ended up modifying the time limit in the minified JavaScript source file, as a work around&lt;/li&gt;
&lt;li&gt;I like the mix of ML and C-style syntax&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ada&quot;&gt;Ada&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Seems like a lot of boilerplate, but that might be intentional&lt;/li&gt;
&lt;li&gt;I wasn&amp;#39;t sure how big Ada.Containers.Count_Type could be and it turns out it&amp;#39;s implementation defined -- not what I expected!&lt;/li&gt;
&lt;li&gt;Structure and syntax is similar to Pascal&lt;/li&gt;
&lt;li&gt;Can only have one top-level procedure per file?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;shen&quot;&gt;Shen&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lots of details are in the &amp;quot;Shen Book&amp;quot;, but it only seems to be available in a scanned, non-OCR&amp;#39;d JPEG format&lt;/li&gt;
&lt;li&gt;None of the implementations I tried seemed to  include the standard library...?&lt;/li&gt;
&lt;li&gt;Having Prolog embedded in a Lisp sounded great, but I found it awkward to use since it&amp;#39;s lacking Prolog&amp;#39;s standard library&lt;/li&gt;
&lt;li&gt;I was skeptical of the lack of quote/quasiquote in a Lisp, but I didn&amp;#39;t actually end up needing either of them!&lt;/li&gt;
&lt;li&gt;I feel like there are some intriguing ideas in Shen, but overall I found Shen somewhat impenetrable&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kitten&quot;&gt;Kitten&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I liked the idea of a simple, functional, statically typed concatenative language&lt;/li&gt;
&lt;li&gt;Switching between Forth-style syntax and C (or Python) syntax feels odd (and I don&amp;#39;t like all the commas)&lt;/li&gt;
&lt;li&gt;Seemed to use a lot of memory&lt;/li&gt;
&lt;li&gt;Logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; have no special meaning, so short-circuiting is implemented using (explicit) anonymous functions&lt;/li&gt;
&lt;li&gt;Fun to play with!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lo&quot;&gt;LO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dislike &lt;code&gt;0 as i32&lt;/code&gt; for a signed integer type zero (but I discovered that &lt;code&gt;+0&lt;/code&gt; is equivalent)&lt;/li&gt;
&lt;li&gt;Vectors return pointers, so the underlying element can change!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;bend&quot;&gt;Bend&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Number types are only 24-bit (probably normal for GPU work, but pretty small for Project Euler!)&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t seem to run anything on a VM with &amp;lt; 8 GB of memory&lt;/li&gt;
&lt;li&gt;Have to be &lt;em&gt;very&lt;/em&gt; careful about data types -- there is &lt;em&gt;no&lt;/em&gt; type-checking at all!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;v&quot;&gt;V&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Fast to compile and run&lt;/li&gt;
&lt;li&gt;Easy to pick up if you&amp;#39;ve used a C-like language&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;futhark&quot;&gt;Futhark&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Just by using &lt;code&gt;map&lt;/code&gt;, I was able to get a parallel program with no extra effort&lt;/li&gt;
&lt;li&gt;Confirmed the &lt;code&gt;multicore&lt;/code&gt; build ran twice as fast on my dual-core laptop!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;lobster&quot;&gt;Lobster&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Easy to write code, thanks to simple and terse syntax&lt;/li&gt;
&lt;li&gt;Couldn&amp;#39;t get &amp;quot;exceptions&amp;quot; working -- never figured out why&lt;/li&gt;
&lt;li&gt;Didn&amp;#39;t have to specify any types, which was convenient&lt;/li&gt;
&lt;li&gt;I was excited to see how fast a static, compiled solution was, but for some reason it was slower than Python&lt;/li&gt;
&lt;li&gt;Overall, it felt a bit like Nim&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;dylan&quot;&gt;Dylan&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Building a &amp;quot;hello world&amp;quot; program the first time took minutes and required creating multiple text files&lt;/li&gt;
&lt;li&gt;Multiple dispatch, macros, etc. make this feel like Common Lisp, but with conventional syntax -- I&amp;#39;m surprised Dylan wasn&amp;#39;t more popular, honestly!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;quackery&quot;&gt;Quackery&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ancillary stacks are a nice addition to stack-based languages&lt;/li&gt;
&lt;li&gt;Feels like a cross between Forth and Lisp, but with arrays instead of lists&lt;/li&gt;
&lt;li&gt;Quackery doesn&amp;#39;t have variables... but I kind of wish it did&lt;/li&gt;
&lt;li&gt;The foreword from The Book of Quackery was a fun read&lt;/li&gt;
&lt;/ul&gt;
</content>
</entry>
<entry>
<title>Python is the new BASIC</title>
<id>https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html</id>
<link rel="alternate" href="https://log.schemescape.com/posts/programming-languages/python-as-a-modern-basic.html"/>
<updated>2024-11-20T00:00:00.000Z</updated>
<summary type="text">What makes Python the BASIC of today?</summary>
<content type="html">&lt;p&gt;(Note: This post has been &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/python-is-good-actually.html&quot;&gt;updated to remove irrelevant snark&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;As far as programming languages go, &lt;a href=&quot;https://en.wikipedia.org/wiki/BASIC&quot;&gt;BASIC&lt;/a&gt; (&amp;quot;Beginners&amp;#39; All-purpose Symbolic Instruction Code&amp;quot;) is... &lt;strong&gt;not a language I would choose today&lt;/strong&gt;. Granted, when it was originally developed in the 60s, line numbers and single-character identifiers were &lt;em&gt;an improvement&lt;/em&gt;. But in its heyday (which I&amp;#39;m going to claim, without evidence, was in the late 70s and early 80s), there were other options I like better (Pascal, Lisp, Forth, even C!). Yet, &lt;strong&gt;BASIC was everywhere! It &lt;em&gt;was&lt;/em&gt; the interface for many old computers, like the Commodore 64.&lt;/strong&gt; Why? I&amp;#39;d say (again, without evidence) it&amp;#39;s because BASIC was designed to be usable by anyone--not just experienced programmers.&lt;/p&gt;
&lt;p&gt;Today, there&amp;#39;s a &lt;em&gt;different&lt;/em&gt; language which enjoys a strong following, often as a first language. That language is Python.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Python is the new BASIC.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;back-to-basic&quot;&gt;Back to BASIC&lt;/h1&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;BASIC was created at Dartmouth College in 1963 by John G. Kemeny and Thomas E. Kurtz (see &lt;a href=&quot;https://computerhistory.org/blog/in-memoriam-thomas-e-kurtz-1928-2024/&quot;&gt;In Memoriam: Thomas E. Kurtz, 1928–2024&lt;/a&gt;). If you want a historical account, there is an &lt;a href=&quot;https://podcasts.apple.com/us/podcast/keeping-things-basic/id1459202600?i=1000502282724&quot;&gt;Advent of Computing podcast episode about BASIC&lt;/a&gt; that is excellent (as is the entire podcast).&lt;/p&gt;
&lt;h2 id=&quot;commodore-basic&quot;&gt;Commodore BASIC&lt;/h2&gt;
&lt;p&gt;My personal history with BASIC goes back to &lt;a href=&quot;https://log.schemescape.com/posts/programming-languages/../vintage-computing/40-year-old-dev-environment.html&quot;&gt;the first computer I ever used, the Commodore 64&lt;/a&gt;. That computer booted directly into BASIC. Although I didn&amp;#39;t realize it at the time, to launch programs, you had to type in BASIC code. &lt;strong&gt;Every user was secretly a programmer!&lt;/strong&gt; I don&amp;#39;t think I wrote any programs beyond &lt;code&gt;10 PRINT &amp;quot;HAHA&amp;quot;&lt;/code&gt;; &lt;code&gt;20 GOTO 10&lt;/code&gt;, but I suppose I at least learned about commands and quotation marks.&lt;/p&gt;
&lt;h2 id=&quot;qbasic&quot;&gt;QBasic&lt;/h2&gt;
&lt;p&gt;At some point, I decided that I wanted to make a computer do whatever I wanted, so I needed to learn how to program. Fortunately, my &lt;a href=&quot;https://en.wikipedia.org/wiki/MS-DOS&quot;&gt;MS-DOS&lt;/a&gt; computer included a development environment--impressively fully-featured, in retrospect--named &lt;a href=&quot;https://en.wikipedia.org/wiki/QBasic&quot;&gt;QBasic&lt;/a&gt;. Yes, BASIC (specifically QBasic) was the first programming language I attempted to learn. I don&amp;#39;t think I ever discovered subroutines in QBasic, but I did at least learn about conditionals, loops, and arrays.&lt;/p&gt;
&lt;p&gt;Regardless, BASIC served its purpose. I, with no prior experience, learned how to write some simple programs without throwing up my hands in despair and swearing off computers forever. &lt;strong&gt;I guess I&amp;#39;m a BASIC success story!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As an aside, I recently found an old box of floppy disks, including one &amp;quot;double density&amp;quot; disk with my first name written on the label. That disk contained several programs I had written using QBasic, circa 1997. The code was... not good--again, I hadn&amp;#39;t discovered subroutines yet.&lt;/p&gt;
&lt;h1 id=&quot;back-to-python&quot;&gt;Back to Python&lt;/h1&gt;
&lt;p&gt;Although not perfect, Python has a lot going for it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It&amp;#39;s &lt;strong&gt;ubiquitous&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It comes with &amp;quot;batteries included&amp;quot;&lt;/strong&gt;, i.e. a comprehensive standard library&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It&amp;#39;s simple&lt;/strong&gt; (or, at least, you can pretend it is, for casual use)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Python is often good enough.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;why-python-is-the-new-basic&quot;&gt;Why Python is the new BASIC&lt;/h2&gt;
&lt;p&gt;But why is Python the new BASIC? The answer is simple: &lt;strong&gt;Python is the new BASIC because Python is the language that new programmers always seem to use&lt;/strong&gt;. It&amp;#39;s reached critical mass. Python has won!&lt;/p&gt;
&lt;p&gt;Of course, that is more of an observation than a reason. I honestly have no idea why people originally gravitated to Python (apologies for implying otherwise), but if I had to guess it would be some combination of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python emerged when the world desperately needed a scripting language that was more approachable than &lt;a href=&quot;https://www.perl.org/&quot;&gt;Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python often includes everything you need, right in the standard library&lt;/li&gt;
&lt;li&gt;Python was math-friendly enough to gain a foothold in physics, finance, etc. research, thus broadening its ecosystem and influence&lt;/li&gt;
&lt;li&gt;Python smartly borrowed convenient features from more complex languages, while retaining a simple look&lt;/li&gt;
&lt;li&gt;Python was never owned by a litigious corporation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In other words: &lt;strong&gt;some combination of smart design, community management, and happenstance&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;definitive-proof-of-pythons-dominance&quot;&gt;Definitive proof of Python&amp;#39;s dominance&lt;/h2&gt;
&lt;p&gt;Despite preferred other programming languages for my entire adult life, &lt;strong&gt;I recently gave in and wrote a personal utility program in Python&lt;/strong&gt; because I knew Python would have everything I needed and I had confidence that Python was entrenched enough that I&amp;#39;d still be able to use my program for the foreseeable future.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If even a Python-avoider like me defaults to using Python, then I think it&amp;#39;s pretty clear that Python has taken over the world, just as BASIC once did.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One parting thought: how long will Python&amp;#39;s reign last?&lt;/p&gt;
</content>
</entry>
</feed>
